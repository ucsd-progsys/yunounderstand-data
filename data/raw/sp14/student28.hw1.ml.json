{"ocaml":[],"event":{"region":{"start":0,"stop":50},"type":"eval"},"cursor":50,"time":1.396644757788964e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = failwith \"TBD:sumList\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":0,"stop":50},"type":"eval"},"cursor":50,"time":1.396644759574417e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = failwith \"TBD:sumList\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = failwith \"TBD:sumList\"","min":"\nlet rec sumList xs = failwith \"TBD:sumList\";;\n","type":"","out":""},{"in":"let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5547},"type":"eval"},"cursor":50,"time":1.396644768337793e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = failwith \"TBD:sumList\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = failwith \"TBD:sumList\"","min":"\nlet rec sumList xs = failwith \"TBD:sumList\";;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":127},"type":"eval"},"cursor":128,"time":1.396685100293215e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = failwith \"TBD:sumList\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5581},"type":"eval"},"cursor":160,"time":1.396685210889335e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []","min":"\nlet rec digitsOfInt n = if n < 0 then [];;\n","type":"type","out":"Characters 41-43:\n  if( n < 0 ) then [];;\n                   ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}],"event":{"region":{"start":316,"stop":557},"type":"eval"},"cursor":557,"time":1.396685974807582e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n =\nif( n < 0 ) then -> []","min":"","type":"syntax","out":"Characters 41-43:\n  if( n < 0 ) then -> [];;\n                   ^^\nError: Syntax error\n"},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":316,"stop":5577},"type":"eval"},"cursor":558,"time":1.39668598541931e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if( n < 0 ) then -> []\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n =\nif( n < 0 ) []","min":"","type":"syntax","out":"Characters 38-40:\n  if( n < 0 ) [];;\n                ^^\nError: Syntax error\n"},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":316,"stop":5569},"type":"eval"},"cursor":537,"time":1.396686004805465e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if( n < 0 ) []\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n =\nif( n < 0 ) []\nelse helperDigits (n, [])","min":"","type":"syntax","out":"Characters 39-43:\n  else helperDigits (n, []);;\n  ^^^^\nError: Syntax error\n"},{"in":"let rec helperDigits (num, newList) = \nif( num < 10) then num :: newList\nelse (num/10, (num mod 10) :: newList)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else ((num / 10), ((num mod 10) :: newList));;\n","type":"type","out":"Characters 78-111:\n  else (num/10, (num mod 10) :: newList);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":316,"stop":5712},"type":"eval"},"cursor":612,"time":1.396686874205064e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if( n < 0 ) []\nelse helperDigits (n, []);;\n\nlet rec helperDigits (num, newList) = \n  if( num < 10) then num :: newList\n  else (num/10, (num mod 10) :: newList);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"scope","out":"Characters 49-61:\n  else helperDigits (n, []);;\n       ^^^^^^^^^^^^\nError: Unbound value helperDigits\n"},{"in":"let rec helperDigits (num, newList) = \nif( num < 10) then num :: newList\nelse (num/10, (num mod 10) :: newList)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else ((num / 10), ((num mod 10) :: newList));;\n","type":"type","out":"Characters 78-111:\n  else (num/10, (num mod 10) :: newList);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5718},"type":"eval"},"cursor":658,"time":1.396687015712735e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\nlet rec helperDigits (num, newList) = \n  if( num < 10) then num :: newList\n  else (num/10, (num mod 10) :: newList);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (num/10, (num mod 10) :: newList)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else ((num / 10), ((num mod 10) :: newList));;\n","type":"type","out":"Characters 77-110:\n  else (num/10, (num mod 10) :: newList);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"scope","out":"Characters 49-61:\n  else helperDigits (n, []);;\n       ^^^^^^^^^^^^\nError: Unbound value helperDigits\n"},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":281,"stop":5719},"type":"eval"},"cursor":514,"time":1.3966870726732e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (num/10, (num mod 10) :: newList);;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (num/10, (num mod 10)::newList)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else ((num / 10), ((num mod 10) :: newList));;\n","type":"type","out":"Characters 77-108:\n  else (num/10, (num mod 10)::newList);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"scope","out":"Characters 49-61:\n  else helperDigits (n, []);;\n       ^^^^^^^^^^^^\nError: Unbound value helperDigits\n"},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":316,"stop":5717},"type":"eval"},"cursor":613,"time":1.396687116623115e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (num/10, (num mod 10)::newList);;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits num/10, (num mod 10)::newList)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else (((helperDigits num) / 10), ((num mod 10) :: newList));;\n","type":"type","out":"Characters 77-121:\n  else (helperDigits num/10, (num mod 10)::newList);;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"scope","out":"Characters 49-61:\n  else helperDigits (n, []);;\n       ^^^^^^^^^^^^\nError: Unbound value helperDigits\n"},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":316,"stop":5730},"type":"eval"},"cursor":606,"time":1.396687160973819e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits num/10, (num mod 10)::newList);;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":281,"stop":5733},"type":"eval"},"cursor":319,"time":1.396687174909189e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":713,"stop":5732},"type":"eval"},"cursor":836,"time":1.396687191975353e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt -1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt - 1;;\n","type":"type","out":"Characters 8-19:\n  let _ = digitsOfInt -1;;\n          ^^^^^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":834,"stop":5755},"type":"eval"},"cursor":857,"time":1.39668722599309e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt -1\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":834,"stop":5758},"type":"eval"},"cursor":860,"time":1.39668725070994e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-1)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""}],"event":{"region":{"start":835,"stop":859},"type":"eval"},"cursor":835,"time":1.396687294538141e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-1)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let_ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = let_ = (digitsOfInt 0);;\n","type":"scope","out":"Characters 0-4:\n  let_ = digitsOfInt 0;;\n  ^^^^\nError: Unbound value let_\n"}],"event":{"region":{"start":862,"stop":882},"type":"eval"},"cursor":862,"time":1.396687318856023e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-1);;\nlet_ = digitsOfInt 0\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""}],"event":{"region":{"start":862,"stop":883},"type":"eval"},"cursor":862,"time":1.396687328605463e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""}],"event":{"region":{"start":899,"stop":921},"type":"eval"},"cursor":899,"time":1.396687356272428e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 10","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 10;;\n","type":"","out":""}],"event":{"region":{"start":922,"stop":944},"type":"eval"},"cursor":922,"time":1.396687373753061e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 10\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 01","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""}],"event":{"region":{"start":922,"stop":944},"type":"eval"},"cursor":922,"time":1.396687381327956e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 01\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec addPHelper (num, sum, count) = \nif(num < 10 && sum < 10) then count\nelse begin\nif(num = 0) then addPHelper(sum, 0, count + 1)\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 0)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 0);;\n","type":"","out":""}],"event":{"region":{"start":1864,"stop":2106},"type":"eval"},"cursor":1864,"time":1.396688064146827e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\nlet rec additivePersistence n = \n  addPHelper(n, 0, 0)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec addPHelper (num, sum, count) = \nif(num < 10 && sum < 10) then count\nelse begin\nif(num = 0) then addPHelper(sum, 0, count + 1)\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 0)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 0);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 0);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":1864,"stop":2214},"type":"eval"},"cursor":1864,"time":1.396688089903335e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\nlet rec additivePersistence n = \n  addPHelper(n, 0, 0)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 0);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":2182,"stop":2214},"type":"eval"},"cursor":2182,"time":1.396688107580711e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\nlet rec additivePersistence n = \n  addPHelper(n, 0, 0)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num < 10 && sum < 10) then count\nelse begin\nif(num = 0) then addPHelper(sum, 0, count + 1)\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 0)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 0);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 0);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":834,"stop":6073},"type":"eval"},"cursor":1463,"time":1.396688118244307e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\nlet rec additivePersistence n = \n  addPHelper(n, 0, 0)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num < 10 && sum < 10) then count\nelse begin\nif(num = 0) then addPHelper(sum, 0, count + 1)\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 0)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 0);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 0);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":1173,"stop":6073},"type":"eval"},"cursor":1782,"time":1.396688124493795e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\nlet rec additivePersistence n = \n  addPHelper(n, 0, 0)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":2052,"stop":6073},"type":"eval"},"cursor":2107,"time":1.396688175496106e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""}],"event":{"region":{"start":2221,"stop":2283},"type":"eval"},"cursor":2221,"time":1.396688222782962e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""}],"event":{"region":{"start":2254,"stop":2283},"type":"eval"},"cursor":2254,"time":1.396688230394924e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 01","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""}],"event":{"region":{"start":2254,"stop":2284},"type":"eval"},"cursor":2254,"time":1.396688237885217e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 01\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""}],"event":{"region":{"start":2284,"stop":2313},"type":"eval"},"cursor":2284,"time":1.396688289054311e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""}],"event":{"region":{"start":2314,"stop":2344},"type":"eval"},"cursor":2314,"time":1.396688301645378e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""}],"event":{"region":{"start":2360,"stop":2391},"type":"eval"},"cursor":2360,"time":1.396688330165741e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""}],"event":{"region":{"start":2392,"stop":2424},"type":"eval"},"cursor":2392,"time":1.396688349777642e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""}],"event":{"region":{"start":2425,"stop":2457},"type":"eval"},"cursor":2425,"time":1.396688447707548e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1)\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""}],"event":{"region":{"start":2499,"stop":2531},"type":"eval"},"cursor":2499,"time":1.396688567476031e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1);\n    Printf.printf \"num is %d and sum is %d and count is %d\\n\" num sum count;\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""}],"event":{"region":{"start":2499,"stop":2531},"type":"eval"},"cursor":2499,"time":1.396688570524781e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1);\n    Printf.printf \"num is %d and sum is %d and count is %d\\n\" num sum count;\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""}],"event":{"region":{"start":2501,"stop":2533},"type":"eval"},"cursor":2501,"time":1.396688585612742e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1);\n    Printf.printf \"num is %d and sum is %d and count is %d\\n\" num sum count;\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""}],"event":{"region":{"start":2524,"stop":2556},"type":"eval"},"cursor":2524,"time":1.396688683765964e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then addPHelper(sum, 0, count + 1);\n    Printf.printf \"num is %d and sum is %d and count is %d\\n\" num sum count;\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  Printf.printf \"hello\";\n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num < 10 && sum < 10) then count\nelse begin\nif(num = 0) then begin addPHelper(sum, 0, count + 1);\nPrintf.printf \"num is %d and sum is %d and count is %d\\n\" num sum count;\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then\n      (addPHelper (sum, 0, (count + 1));\n       Printf.printf \"num is %d and sum is %d and count is %d\\n\" num sum\n         count)\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"type","out":"Characters 141-213:\n  Printf.printf \"num is %d and sum is %d and count is %d\\n\" num sum count;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit but an expression was expected of type\n         int\n"}],"event":{"region":{"start":0,"stop":2136},"type":"eval"},"cursor":1976,"time":1.396689180491173e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num < 10 && sum < 10) then count\n  else begin\n    if(num = 0) then begin addPHelper(sum, 0, count + 1);\n      Printf.printf \"num is %d and sum is %d and count is %d\\n\" num sum count;\n    end\n    else addPHelper(num/10, (num mod 10) + sum, count)\n  end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  Printf.printf \"hello\";\n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2471},"type":"eval"},"cursor":2471,"time":1.396760695270024e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":2283,"stop":6329},"type":"eval"},"cursor":2312,"time":1.396760908686561e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitalHelper(num, sum) = \nif(num = 0 && sum < 10) then sum\nelse begin\nif(num = 0) then digitalHelper(sum, 0)\nelse digitalHelper(num/10, (num mod 10) + sum)\nend","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n","type":"","out":""},{"in":"let rec digitalRoot n = \ndigitalHelper(n, 0)","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":2471,"stop":2852},"type":"eval"},"cursor":2854,"time":1.396761047469882e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""}],"event":{"region":{"start":2852,"stop":2993},"type":"eval"},"cursor":2995,"time":1.396761099024087e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9884","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":2969,"stop":6646},"type":"eval"},"cursor":2995,"time":1.396761124043942e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""}],"event":{"region":{"start":2852,"stop":3318},"type":"eval"},"cursor":3319,"time":1.396761413890794e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":3278,"stop":6791},"type":"eval"},"cursor":3319,"time":1.396761419029893e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (reverse w)) then true\nelse false","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (reverse w) then true else false;;\n","type":"scope","out":"Characters 66-73:\n  if(converted = (reverse w)) then true\n                  ^^^^^^^\nError: Unbound value reverse\n"},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet palindrome w = failwith \"TBD\";;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet palindrome w = failwith \"TBD\";;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""}],"event":{"region":{"start":3607,"stop":3838},"type":"eval"},"cursor":3839,"time":1.396761589355997e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (reverse w)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse w)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse w) then true else false;;\n","type":"type","out":"Characters 78-79:\n  if(converted = (listReverse w)) then true\n                              ^\nError: This expression has type string but an expression was expected of type\n         'a list\n"},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet palindrome w = failwith \"TBD\";;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet palindrome w = failwith \"TBD\";;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""}],"event":{"region":{"start":3607,"stop":3842},"type":"eval"},"cursor":3848,"time":1.396761601265706e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse w)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""}],"event":{"region":{"start":3607,"stop":3850},"type":"eval"},"cursor":3853,"time":1.396761628676332e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""}],"event":{"region":{"start":3850,"stop":3879},"type":"eval"},"cursor":3881,"time":1.396761648646247e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalHelper(num, sum) = \nif(num = 0 && sum < 10) then sum\nelse begin\nif(num = 0) then digitalHelper(sum, 0)\nelse digitalHelper(num/10, (num mod 10) + sum)\nend","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n","type":"","out":""},{"in":"let rec digitalRoot n = \ndigitalHelper(n, 0)","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3328},"type":"eval"},"cursor":3328,"time":1.396763493722258e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9552","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""}],"event":{"region":{"start":3168,"stop":3288},"type":"eval"},"cursor":3289,"time":1.396763537833379e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"Printf.printf \"hi\"","min":"\nlet _ = Printf.printf \"hi\";;\n","type":"","out":""}],"event":{"region":{"start":85,"stop":105},"type":"eval"},"cursor":85,"time":1.39699777873935e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nPrintf.printf \"hi\";;\n\nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"Printf.printf \"hi %d \" 2","min":"\nlet _ = Printf.printf \"hi %d \" 2;;\n","type":"","out":""}],"event":{"region":{"start":85,"stop":111},"type":"eval"},"cursor":85,"time":1.396997790456339e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nPrintf.printf \"hi %d \" 2;;\n\nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"Printf.printf \"hi %d \"","min":"\nlet _ = Printf.printf \"hi %d \";;\n","type":"","out":""}],"event":{"region":{"start":85,"stop":110},"type":"eval"},"cursor":85,"time":1.396997805266939e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nPrintf.printf \"hi %d \" ;;\n\nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"Printf.printf \"hi %d \" ;","min":"\nlet _ = Printf.printf \"hi %d \";;\n","type":"","out":""}],"event":{"region":{"start":85,"stop":109},"type":"eval"},"cursor":85,"time":1.396997812274668e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nPrintf.printf \"hi %d \" ;\n\nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"Printf.printf \"hi %d \" 2 ;","min":"\nlet _ = Printf.printf \"hi %d \" 2;;\n","type":"","out":""}],"event":{"region":{"start":85,"stop":111},"type":"eval"},"cursor":85,"time":1.396997820430669e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \n\nPrintf.printf \"hi %d \" 2 ;\n\nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in\nif(n < 10) then n\nelse additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if n < 10 then n else additivePersistence sum;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if n < 10 then n else additivePersistence sum;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":2167,"stop":2413},"type":"eval"},"cursor":2167,"time":1.397000169079943e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n    if(n < 10) then n\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n","min":"","type":"syntax","out":"Characters 60-62:\n  let newList = digitsOfInt n;;\n                             ^^\nError: Syntax error\n"}],"event":{"region":{"start":0,"stop":2227},"type":"eval"},"cursor":2227,"time":1.397000207579987e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n (*XX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n","min":"","type":"syntax","out":"Characters 60-62:\n  let newList = digitsOfInt n;;\n                             ^^\nError: Syntax error\n"}],"event":{"region":{"start":2167,"stop":2230},"type":"eval"},"cursor":2167,"time":1.397000318776335e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n;; (*XX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in 1 + 2","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec additivePersistence n = let newList = digitsOfInt n in 1 + 2;;\n","type":"","out":""}],"event":{"region":{"start":2167,"stop":2238},"type":"eval"},"cursor":2167,"time":1.397000412722432e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in 1 + 2;; (*XX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in 1 + 2","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in let sum = sumList newList in 1 + 2;;\n","type":"","out":""}],"event":{"region":{"start":2167,"stop":2265},"type":"eval"},"cursor":2167,"time":1.397000440940689e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in 1 + 2\n(*\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then sum else additivePersistence sum;;\n","type":"","out":""}],"event":{"region":{"start":2167,"stop":2311},"type":"eval"},"cursor":2167,"time":1.397000490331102e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then sum else additivePersistence sum;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":2386,"stop":2418},"type":"eval"},"cursor":2386,"time":1.397000495099332e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9876","min":"\nlet _ = digitalRoot2 9876;;\n","type":"scope","out":"Characters 8-20:\n  let _ = digitalRoot2 9876;;\n          ^^^^^^^^^^^^\nError: Unbound value digitalRoot2\n"}],"event":{"region":{"start":3276,"stop":3326},"type":"eval"},"cursor":3276,"time":1.397000561406412e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9876","min":"\nlet _ = digitalRoot2 9876;;\n","type":"scope","out":"Characters 8-20:\n  let _ = digitalRoot2 9876;;\n          ^^^^^^^^^^^^\nError: Unbound value digitalRoot2\n"}],"event":{"region":{"start":3272,"stop":3322},"type":"eval"},"cursor":3272,"time":1.397000576386241e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":3272,"stop":3296},"type":"eval"},"cursor":3272,"time":1.397000592740535e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot2 9876","min":"\nlet _ = digitalRoot2 9876;;\n","type":"scope","out":"Characters 8-20:\n  let _ = digitalRoot2 9876;;\n          ^^^^^^^^^^^^\nError: Unbound value digitalRoot2\n"}],"event":{"region":{"start":3297,"stop":3322},"type":"eval"},"cursor":3297,"time":1.397000603225159e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":3276,"stop":3300},"type":"eval"},"cursor":3276,"time":1.397000623075467e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":3280,"stop":3304},"type":"eval"},"cursor":3280,"time":1.397000644351484e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":3280,"stop":3304},"type":"eval"},"cursor":3280,"time":1.39700066233826e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":3280,"stop":3304},"type":"eval"},"cursor":3280,"time":1.397000681287254e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""}],"event":{"region":{"start":3319,"stop":3340},"type":"eval"},"cursor":3319,"time":1.397000703527835e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":3278,"stop":3302},"type":"eval"},"cursor":3278,"time":1.397000712200948e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then sum else additivePersistence sum;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":2386,"stop":2418},"type":"eval"},"cursor":2386,"time":1.397000717540156e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""}],"event":{"region":{"start":783,"stop":807},"type":"eval"},"cursor":783,"time":1.397000725284295e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXX\nXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \naddPHelper(n, 0, 1);;\n*)\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence sum\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalHelper(num, sum) = \nif(num = 0 && sum < 10) then sum\nelse begin\nif(num = 0) then digitalHelper(sum, 0)\nelse digitalHelper(num/10, (num mod 10) + sum)\nend","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n","type":"","out":""},{"in":"let rec digitalRoot n = \ndigitalHelper(n, 0)","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7474},"type":"eval"},"cursor":2066,"time":1.397000749418793e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":2388,"stop":2420},"type":"eval"},"cursor":2388,"time":1.397000756933379e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""}],"event":{"region":{"start":2158,"stop":2345},"type":"eval"},"cursor":2338,"time":1.397000769405619e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""}],"event":{"region":{"start":2238,"stop":2315},"type":"eval"},"cursor":2238,"time":1.397000776505367e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0)\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalHelper(num, sum) = \nif(num = 0 && sum < 10) then sum\nelse begin\nif(num = 0) then digitalHelper(sum, 0)\nelse digitalHelper(num/10, (num mod 10) + sum)\nend","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n","type":"","out":""},{"in":"let rec digitalRoot n = \ndigitalHelper(n, 0)","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""}],"event":{"region":{"start":2345,"stop":3434},"type":"eval"},"cursor":3434,"time":1.39700080795356e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitalRoot2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""}],"event":{"region":{"start":2925,"stop":3190},"type":"eval"},"cursor":3191,"time":1.397000815010263e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":3128,"stop":3152},"type":"eval"},"cursor":3128,"time":1.397000820243576e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9876;;\n","type":"","out":""}],"event":{"region":{"start":3128,"stop":3178},"type":"eval"},"cursor":3128,"time":1.397000841347372e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9876;;\n","type":"","out":""}],"event":{"region":{"start":3128,"stop":3178},"type":"eval"},"cursor":3128,"time":1.397000851247328e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 458;;\n","type":"","out":""}],"event":{"region":{"start":3128,"stop":3734},"type":"eval"},"cursor":3128,"time":1.397000939891853e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot2 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot2 1\n\nlet _ = digitalRoot 11\nlet _ = digitalRoot2 11\n\nlet _ = digitalRoot 999\nlet _ = digitalRoot2 999\n\nlet _ = digitalRoot 9999\nlet _ = digitalRoot2 9999\n\nlet _ = digitalRoot 9884\nlet _ = digitalRoot2 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot2 9552\n\nlet _ = digitalRoot 48\nlet _ = digitalRoot2 48\n\nlet _ = digitalRoot 7\nlet _ = digitalRoot2 7\n\nlet _ = digitalRoot 1486\nlet _ = digitalRoot2 1486\n\nlet _ = digitalRoot 458\nlet _ = digitalRoot2 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9876;;\n","type":"","out":""}],"event":{"region":{"start":3128,"stop":3178},"type":"eval"},"cursor":3128,"time":1.397000950213779e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot2 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot2 1\n\nlet _ = digitalRoot 11\nlet _ = digitalRoot2 11\n\nlet _ = digitalRoot 999\nlet _ = digitalRoot2 999\n\nlet _ = digitalRoot 9999\nlet _ = digitalRoot2 9999\n\nlet _ = digitalRoot 9884\nlet _ = digitalRoot2 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot2 9552\n\nlet _ = digitalRoot 48\nlet _ = digitalRoot2 48\n\nlet _ = digitalRoot 7\nlet _ = digitalRoot2 7\n\nlet _ = digitalRoot 1486\nlet _ = digitalRoot2 1486\n\nlet _ = digitalRoot 458\nlet _ = digitalRoot2 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":3128,"stop":3152},"type":"eval"},"cursor":3128,"time":1.397000991216449e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":3133,"stop":3157},"type":"eval"},"cursor":3133,"time":1.397001002353818e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":3133,"stop":3157},"type":"eval"},"cursor":3133,"time":1.397001005440381e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalHelper(num, sum) = \nif(num = 0 && sum < 10) then sum\nelse begin\nif(num = 0) then digitalHelper(sum, 0)\nelse digitalHelper(num/10, (num mod 10) + sum)\nend","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n","type":"","out":""},{"in":"let rec digitalRoot n = \ndigitalHelper(n, 0)","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3290},"type":"eval"},"cursor":3289,"time":1.397001013307578e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":3133,"stop":3157},"type":"eval"},"cursor":3133,"time":1.397001018203195e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitalRoot n = \ndigitalHelper(n, 0)","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n","type":"","out":""},{"in":"let rec digitalRoot2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":2881,"stop":7349},"type":"eval"},"cursor":2928,"time":1.397001050412258e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalHelper(num, sum) = \nif(num = 0 && sum < 10) then sum\nelse begin\nif(num = 0) then digitalHelper(sum, 0)\nelse digitalHelper(num/10, (num mod 10) + sum)\nend","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n","type":"","out":""},{"in":"let rec digitalRoot n = \ndigitalHelper(n, 0)","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n","type":"","out":""},{"in":"let rec digitalRoot2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3179},"type":"eval"},"cursor":3180,"time":1.39700105551543e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalHelper(num, sum) = \nif(num = 0 && sum < 10) then sum\nelse begin\nif(num = 0) then digitalHelper(sum, 0)\nelse digitalHelper(num/10, (num mod 10) + sum)\nend","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n","type":"","out":""},{"in":"let rec digitalRoot n = \ndigitalHelper(n, 0)","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n","type":"","out":""},{"in":"let rec digitalRoot2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 1;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3286},"type":"eval"},"cursor":3287,"time":1.39700109472276e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot2 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot2 1\n\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalHelper(num, sum) = \nif(num = 0 && sum < 10) then sum\nelse begin\nif(num = 0) then digitalHelper(sum, 0)\nelse digitalHelper(num/10, (num mod 10) + sum)\nend","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n","type":"","out":""},{"in":"let rec digitalRoot n = \ndigitalHelper(n, 0)","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n","type":"","out":""},{"in":"let rec digitalRoot2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 458;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3733},"type":"eval"},"cursor":3734,"time":1.397001167197942e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot2 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot2 1\n\nlet _ = digitalRoot 11\nlet _ = digitalRoot2 11\n\nlet _ = digitalRoot 999\nlet _ = digitalRoot2 999\n\nlet _ = digitalRoot 9999\nlet _ = digitalRoot2 1\n\nlet _ = digitalRoot 9884\nlet _ = digitalRoot2 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot2 9552\n\nlet _ = digitalRoot 48\nlet _ = digitalRoot2 48\n\nlet _ = digitalRoot 7\nlet _ = digitalRoot2 7\n\nlet _ = digitalRoot 1486\nlet _ = digitalRoot2 1486\n\nlet _ = digitalRoot 458\nlet _ = digitalRoot2 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalHelper(num, sum) = \nif(num = 0 && sum < 10) then sum\nelse begin\nif(num = 0) then digitalHelper(sum, 0)\nelse digitalHelper(num/10, (num mod 10) + sum)\nend","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n","type":"","out":""},{"in":"let rec digitalRoot n = \ndigitalHelper(n, 0)","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n","type":"","out":""},{"in":"let rec digitalRoot2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let _ = digitalRoot2 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n\nlet _ = digitalRoot2 458;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3736},"type":"eval"},"cursor":3738,"time":1.39700120633256e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot2 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot2 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot2 1\n\nlet _ = digitalRoot 11\nlet _ = digitalRoot2 11\n\nlet _ = digitalRoot 999\nlet _ = digitalRoot2 999\n\nlet _ = digitalRoot 9999\nlet _ = digitalRoot2 9999\n\nlet _ = digitalRoot 9884\nlet _ = digitalRoot2 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot2 9552\n\nlet _ = digitalRoot 48\nlet _ = digitalRoot2 48\n\nlet _ = digitalRoot 7\nlet _ = digitalRoot2 7\n\nlet _ = digitalRoot 1486\nlet _ = digitalRoot2 1486\n\nlet _ = digitalRoot 458\nlet _ = digitalRoot2 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3448},"type":"eval"},"cursor":3449,"time":1.397001280799354e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\n\nlet _ = digitalRoot 11\n\nlet _ = digitalRoot 999\n\nlet _ = digitalRoot 9999\n\n\nlet _ = digitalRoot 9884\n\n\nlet _ = digitalRoot 9552\n\n\nlet _ = digitalRoot 48\n\n\nlet _ = digitalRoot 7\n\n\nlet _ = digitalRoot 1486\n\n\nlet _ = digitalRoot 458\n\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = \nif(sum < 10) then count\nelse 1 + additivePersistence sum","min":"","type":"syntax","out":"Characters 163-165:\n  else 1 + additivePersistence sum;;\n                                  ^^\nError: Syntax error\n"}],"event":{"region":{"start":2161,"stop":2327},"type":"eval"},"cursor":2161,"time":1.397001532165524e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count = \n    if(sum < 10) then count\n    else 1 + additivePersistence sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = \nif(sum < 10) then count\nelse 1 + additivePersistence2 sum","min":"","type":"syntax","out":"Characters 165-167:\n  else 1 + additivePersistence2 sum;;\n                                   ^^\nError: Syntax error\n"},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7493},"type":"eval"},"cursor":2329,"time":1.397001565424036e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count = \n    if(sum < 10) then count\n    else 1 + additivePersistence2 sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count 2 in = \nif(sum < 10) then count\nelse 1 + additivePersistence2 sum","min":"","type":"syntax","out":"Characters 107-109:\n  let count 2 in = \n              ^^\nError: Syntax error\n"}],"event":{"region":{"start":2162,"stop":2334},"type":"eval"},"cursor":2162,"time":1.397001746926931e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count 2 in = \n  if(sum < 10) then count\n  else 1 + additivePersistence2 sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 2 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 2 in if sum < 10 then count else 1 + (additivePersistence2 sum);;\n","type":"","out":""}],"event":{"region":{"start":2162,"stop":2333},"type":"eval"},"cursor":2162,"time":1.397001756255521e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count = 2 in\n    if(sum < 10) then count\n    else 1 + additivePersistence2 sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 0 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 0 in if sum < 10 then count else 1 + (additivePersistence2 sum);;\n","type":"","out":""}],"event":{"region":{"start":2162,"stop":2333},"type":"eval"},"cursor":2162,"time":1.397001775227366e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count = 0 in\n    if(sum < 10) then count\n    else 1 + additivePersistence2 sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 0 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 0 in if sum < 10 then count else 1 + (additivePersistence2 sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 0 in if sum < 10 then count else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2444},"type":"eval"},"cursor":2444,"time":1.397001784686677e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count = 0 in\n    if(sum < 10) then count\n    else 1 + additivePersistence2 sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 0 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 0 in if sum < 10 then count else 1 + (additivePersistence2 sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2443},"type":"eval"},"cursor":2443,"time":1.397001797932491e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count = 0 in\n    if(sum < 10) then count\n    else 1 + additivePersistence2 sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 0 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 0 in if sum < 10 then count else 1 + (additivePersistence2 sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 0 in if sum < 10 then count else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2444},"type":"eval"},"cursor":2444,"time":1.397001809463188e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count = 0 in\n    if(sum < 10) then count\n    else 1 + additivePersistence2 sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 0 in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 0 in if sum < 10 then count else 1 + (additivePersistence2 sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2443},"type":"eval"},"cursor":2443,"time":1.397001816669758e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count = 0 in\n    if(sum < 10) then count\n    else 1 + additivePersistence2 sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 1 + additivePersistence2 sum in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 1 + (additivePersistence2 sum) in\n  if sum < 10 then count else 1 + (additivePersistence2 sum);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2358},"type":"eval"},"cursor":2362,"time":1.397001919479833e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count = 1 + additivePersistence2 sum in\n    if(sum < 10) then count\n    else 1 + additivePersistence2 sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 1 + additivePersistence2 sum in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 1 + (additivePersistence2 sum) in\n  if sum < 10 then count else 1 + (additivePersistence2 sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2470},"type":"eval"},"cursor":2470,"time":1.397001923247346e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count = 1 + additivePersistence2 sum in\n    if(sum < 10) then count\n    else 1 + additivePersistence2 sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nlet count = 1 + additivePersistence2 sum in\nif(sum < 10) then count\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 1 + (additivePersistence2 sum) in\n  if sum < 10 then count else 1 + (additivePersistence2 sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 1 + (additivePersistence2 sum) in\n  if sum < 10 then count else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2471},"type":"eval"},"cursor":2471,"time":1.397001938526574e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n  let count = 1 + additivePersistence2 sum in\n    if(sum < 10) then count\n    else 1 + additivePersistence2 sum;;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":0,"stop":0},"type":"eval"},"cursor":0,"time":1.397002185590331e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":0,"stop":0},"type":"eval"},"cursor":0,"time":1.397002186310785e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalHelper(num, sum) = \nif(num = 0 && sum < 10) then sum\nelse begin\nif(num = 0) then digitalHelper(sum, 0)\nelse digitalHelper(num/10, (num mod 10) + sum)\nend","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n","type":"","out":""},{"in":"let rec digitalRoot n = \ndigitalHelper(n, 0)","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n","type":"","out":""},{"in":"let rec digitalRoot2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot2 sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec digitalHelper (num,sum) =\n  if (num = 0) && (sum < 10)\n  then sum\n  else\n    if num = 0\n    then digitalHelper (sum, 0)\n    else digitalHelper ((num / 10), ((num mod 10) + sum));;\n\nlet rec digitalRoot n = digitalHelper (n, 0);;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7322},"type":"eval"},"cursor":0,"time":1.397002187143888e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalHelper(num, sum) = \n  if(num = 0 && sum < 10) then sum\n  else begin\n    if(num = 0) then digitalHelper(sum, 0)\n    else digitalHelper(num/10, (num mod 10) + sum)\n  end\n\n\nlet rec digitalRoot n = \n  digitalHelper(n, 0);;\n\n\nlet rec digitalRoot2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot2 sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitalRoot n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":2634,"stop":7324},"type":"eval"},"cursor":3170,"time":1.397002222799934e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7324},"type":"eval"},"cursor":2933,"time":1.397002230117856e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec addPersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  let count = 1 + (additivePersistence2 sum) in\n  if sum < 10 then count else 1 + (additivePersistence2 sum);;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec addPersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then sum else additivePersistence2 sum;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7467},"type":"eval"},"cursor":2551,"time":1.39700228621913e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec addPersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence2 sum;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then sum else additivePersistence2 sum;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7472},"type":"eval"},"cursor":2310,"time":1.397002307083379e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence2 sum;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":2386,"stop":2418},"type":"eval"},"cursor":2386,"time":1.397002769544967e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else additivePersistence2 sum;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then 0\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence2 sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2422},"type":"eval"},"cursor":2422,"time":1.397175030700522e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 0\n    else 1 + additivePersistence2 sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":2310,"stop":2421},"type":"eval"},"cursor":2416,"time":1.397175046127501e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1);;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 0\n    else 1 + additivePersistence2 sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar);;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec mylength xs = match xs with \n|[] -> 0\n|hd::tl -> 1 + mylength xs","min":"\nlet rec mylength xs = match xs with | [] -> 0 | hd::tl -> 1 + (mylength xs);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":124},"type":"eval"},"cursor":128,"time":1.397175203087376e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\nlet rec mylength xs = match xs with \n  |[] -> 0\n  |hd::tl -> 1 + mylength xs\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 0\n    else 1 + additivePersistence2 sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = mylength[1;2;3;4]","min":"\nlet rec mylength xs = match xs with | [] -> 0 | hd::tl -> 1 + (mylength xs);;\n\nlet _ = mylength [1; 2; 3; 4];;\n","type":"","out":""}],"event":{"region":{"start":124,"stop":154},"type":"eval"},"cursor":156,"time":1.397175221044749e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\nlet rec mylength xs = match xs with \n  |[] -> 0\n  |hd::tl -> 1 + mylength xs\n;;\n\nlet _ = mylength[1;2;3;4]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 0\n    else 1 + additivePersistence2 sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec mylength xs = match xs with \n|[] -> 0\n|hd::tl -> 1 + mylength tl","min":"\nlet rec mylength xs = match xs with | [] -> 0 | hd::tl -> 1 + (mylength tl);;\n","type":"","out":""},{"in":"let _ = mylength[1;2;3;4]","min":"\nlet rec mylength xs = match xs with | [] -> 0 | hd::tl -> 1 + (mylength tl);;\n\nlet _ = mylength [1; 2; 3; 4];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":154},"type":"eval"},"cursor":155,"time":1.397175239434608e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\nlet rec mylength xs = match xs with \n  |[] -> 0\n  |hd::tl -> 1 + mylength tl\n;;\n\nlet _ = mylength[1;2;3;4]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 0\n    else 1 + additivePersistence2 sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then 0\nelse 5 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 5 + (additivePersistence2 sum);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2313},"type":"eval"},"cursor":2318,"time":1.397175376176622e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 0\n    else 5 + additivePersistence2 sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":2313,"stop":2424},"type":"eval"},"cursor":2424,"time":1.397175381759694e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 0\n    else 5 + additivePersistence2 sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 5 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""}],"event":{"region":{"start":2313,"stop":2425},"type":"eval"},"cursor":2425,"time":1.397175393376165e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 0\n    else 5 + additivePersistence2 sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then Printf.printf \"hi\"; 0\nelse 1 + additivePersistence2 sum","min":"","type":"syntax","out":"Characters 135-139:\n  else 1 + additivePersistence2 sum;;\n  ^^^^\nError: Syntax error\n"},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 5 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""}],"event":{"region":{"start":2160,"stop":2445},"type":"eval"},"cursor":2460,"time":1.397175422805045e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then Printf.printf \"hi\"; 0\nelse 1 + additivePersistence2 sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 0 end\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else 1 + (additivePersistence2 sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""}],"event":{"region":{"start":2160,"stop":2455},"type":"eval"},"cursor":2455,"time":1.397175436099071e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then begin Printf.printf \"hi\"; 0 end\n    else 1 + additivePersistence2 sum\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 0 end\nelse then begin Printf.printf \"bye\" 1 + additivePersistence2 sum end","min":"","type":"syntax","out":"Characters 150-154:\n  else then begin Printf.printf \"bye\" 1 + additivePersistence2 sum end;;\n       ^^^^\nError: Syntax error\n"},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""}],"event":{"region":{"start":2160,"stop":2490},"type":"eval"},"cursor":2490,"time":1.397175467232937e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then begin Printf.printf \"hi\"; 0 end\n    else then begin Printf.printf \"bye\" 1 + additivePersistence2 sum end\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 0 end\nelse begin Printf.printf \"bye\" 1 + additivePersistence2 sum end","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else (Printf.printf \"bye\" 1) + (additivePersistence2 sum);;\n","type":"type","out":"Characters 170-175:\n  else begin Printf.printf \"bye\" 1 + additivePersistence2 sum end;;\n                           ^^^^^\nError: This expression has type\n         ('a -> 'b, out_channel, unit, unit, unit, 'a -> 'b)\n         CamlinternalFormatBasics.fmt\n       but an expression was expected of type\n         ('a -> 'b, out_channel, unit, unit, unit, unit)\n         CamlinternalFormatBasics.fmt\n       Type 'a -> 'b is not compatible with type unit \n"},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""}],"event":{"region":{"start":2160,"stop":2485},"type":"eval"},"cursor":2485,"time":1.397175478462334e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then begin Printf.printf \"hi\"; 0 end\n    else begin Printf.printf \"bye\" 1 + additivePersistence2 sum end\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 0 end\nelse begin Printf.printf \"bye\"; 1 + additivePersistence2 sum end","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else (Printf.printf \"bye\"; 1 + (additivePersistence2 sum));;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 0)\n  else (Printf.printf \"bye\"; 1 + (additivePersistence2 sum));;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""}],"event":{"region":{"start":2160,"stop":2486},"type":"eval"},"cursor":2486,"time":1.39717548714758e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then begin Printf.printf \"hi\"; 0 end\n    else begin Printf.printf \"bye\"; 1 + additivePersistence2 sum end\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then begin Printf.printf \"hi\"; 1 end\nelse begin Printf.printf \"bye\"; 1 + additivePersistence2 sum end","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 1)\n  else (Printf.printf \"bye\"; 1 + (additivePersistence2 sum));;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10\n  then (Printf.printf \"hi\"; 1)\n  else (Printf.printf \"bye\"; 1 + (additivePersistence2 sum));;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""}],"event":{"region":{"start":2160,"stop":2486},"type":"eval"},"cursor":2486,"time":1.397175502227498e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then begin Printf.printf \"hi\"; 1 end\n    else begin Printf.printf \"bye\"; 1 + additivePersistence2 sum end\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence2\n1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 458;;\n","type":"","out":""}],"event":{"region":{"start":2160,"stop":3190},"type":"eval"},"cursor":3190,"time":1.397175666938579e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 1\n    else 1 + additivePersistence2 sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence2 0\n\nlet _ = additivePersistence 1\nlet _ = additivePersistence2\n          1\nlet _ = additivePersistence 11\nlet _ = additivePersistence2 11\n\nlet _ = additivePersistence 999\nlet _ = additivePersistence2 999\n\nlet _ = additivePersistence 9999\nlet _ = additivePersistence2 9999\n\nlet _ = additivePersistence 9884\nlet _ = additivePersistence2 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence2 9552\n\nlet _ = additivePersistence 48\nlet _ = additivePersistence2 48\n\nlet _ = additivePersistence 7\nlet _ = additivePersistence2 7\n\nlet _ = additivePersistence 1486\nlet _ = additivePersistence2 1486\n\nlet _ = additivePersistence 458\nlet _ = additivePersistence2 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence2 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 458;;\n","type":"","out":""}],"event":{"region":{"start":2566,"stop":3190},"type":"eval"},"cursor":3190,"time":1.397175699252633e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 1\n    else 1 + additivePersistence2 sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence2 0\n\nlet _ = additivePersistence 1\nlet _ = additivePersistence2 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence2 11\n\nlet _ = additivePersistence 999\nlet _ = additivePersistence2 999\n\nlet _ = additivePersistence 9999\nlet _ = additivePersistence2 9999\n\nlet _ = additivePersistence 9884\nlet _ = additivePersistence2 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence2 9552\n\nlet _ = additivePersistence 48\nlet _ = additivePersistence2 48\n\nlet _ = additivePersistence 7\nlet _ = additivePersistence2 7\n\nlet _ = additivePersistence 1486\nlet _ = additivePersistence2 1486\n\nlet _ = additivePersistence 458\nlet _ = additivePersistence2 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec addPHelper (num, sum, count) = \nif(num = 0 && sum < 10) then count\nelse \nbegin\nif(num = 0) then begin \naddPHelper(sum, 0, count + 1);\nend\nelse addPHelper(num/10, (num mod 10) + sum, count)\nend","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \naddPHelper(n, 0, 1)","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n","type":"","out":""},{"in":"let rec additivePersistence2 n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence2 sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec addPHelper (num,sum,count) =\n  if (num = 0) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then addPHelper (sum, 0, (count + 1))\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n\nlet rec additivePersistence n = addPHelper (n, 0, 1);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let _ = additivePersistence2 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence2 n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence2 sum);;\n\nlet _ = additivePersistence2 458;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3190},"type":"eval"},"cursor":3190,"time":1.397175715811803e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec addPHelper (num, sum, count) = \n  if(num = 0 && sum < 10) then count\n  else \n    begin\n      if(num = 0) then begin \n        addPHelper(sum, 0, count + 1);\n      end\n      else addPHelper(num/10, (num mod 10) + sum, count)\n    end\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec additivePersistence n = \n  addPHelper(n, 0, 1)\n;;\n\nlet rec additivePersistence2 n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 1\n    else 1 + additivePersistence2 sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence2 9876\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence2 0\n\nlet _ = additivePersistence 1\nlet _ = additivePersistence2 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence2 11\n\nlet _ = additivePersistence 999\nlet _ = additivePersistence2 999\n\nlet _ = additivePersistence 9999\nlet _ = additivePersistence2 9999\n\nlet _ = additivePersistence 9884\nlet _ = additivePersistence2 9884\n\nlet _ = additivePersistence 9552\nlet _ = additivePersistence2 9552\n\nlet _ = additivePersistence 48\nlet _ = additivePersistence2 48\n\nlet _ = additivePersistence 7\nlet _ = additivePersistence2 7\n\nlet _ = additivePersistence 1486\nlet _ = additivePersistence2 1486\n\nlet _ = additivePersistence 458\nlet _ = additivePersistence2 458\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXX\n\n\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6960},"type":"eval"},"cursor":2489,"time":1.397175897028663e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 1\n    else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2489},"type":"eval"},"cursor":2489,"time":1.397175904140975e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 1\n    else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n < 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2125},"type":"eval"},"cursor":2125,"time":1.397198524403149e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 1\n    else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n < 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":2093,"stop":6960},"type":"eval"},"cursor":2125,"time":1.397198527236294e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n < 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 1\n    else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n <= 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":946},"type":"eval"},"cursor":984,"time":1.397353077310737e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 1\n    else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then 0\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""}],"event":{"region":{"start":946,"stop":2490},"type":"eval"},"cursor":2490,"time":1.397353093213289e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 0\n    else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 11\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 10","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 10;;\n","type":"","out":""},{"in":"let _ = additivePersistence 19","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 19;;\n","type":"","out":""},{"in":"let _ = additivePersistence 20","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 20;;\n","type":"","out":""}],"event":{"region":{"start":2202,"stop":2295},"type":"eval"},"cursor":2295,"time":1.397353186207362e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 0\n    else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 10\nlet _ = additivePersistence 19\nlet _ = additivePersistence 20\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n <= 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then 0\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 10","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 10;;\n","type":"","out":""},{"in":"let _ = additivePersistence 19","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 19;;\n","type":"","out":""},{"in":"let _ = additivePersistence 20","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 20;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2327},"type":"eval"},"cursor":2327,"time":1.397353194793218e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then 0\n    else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 10\nlet _ = additivePersistence 19\nlet _ = additivePersistence 20\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nif n < 10 then 0 \nelse \nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":1210,"stop":2150},"type":"eval"},"cursor":2151,"time":1.397353778258028e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n    if n < 10 then 0 \n    else \n      let sum = sumList newList in \n        if(sum < 10) then 1\n        else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 10\nlet _ = additivePersistence 19\nlet _ = additivePersistence 20\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n <= 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nif n < 10 then 0 \nelse \nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 10","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 10;;\n","type":"","out":""},{"in":"let _ = additivePersistence 19","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 19;;\n","type":"","out":""},{"in":"let _ = additivePersistence 20","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 20;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2351},"type":"eval"},"cursor":2351,"time":1.397353785198588e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n    if n < 10 then 0 \n    else \n      let sum = sumList newList in \n        if(sum < 10) then 1\n        else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 10\nlet _ = additivePersistence 19\nlet _ = additivePersistence 20\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n <= 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nif n < 10 then 0 \nelse \nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 2","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 2;;\n","type":"","out":""},{"in":"let _ = additivePersistence 3","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 3;;\n","type":"","out":""},{"in":"let _ = additivePersistence 4","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 4;;\n","type":"","out":""},{"in":"let _ = additivePersistence 5","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 5;;\n","type":"","out":""},{"in":"let _ = additivePersistence 6","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 6;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 8","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 8;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9;;\n","type":"","out":""},{"in":"let _ = additivePersistence 10","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 10;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 12","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 12;;\n","type":"","out":""},{"in":"let _ = additivePersistence 13","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 13;;\n","type":"","out":""},{"in":"let _ = additivePersistence 14","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 14;;\n","type":"","out":""},{"in":"let _ = additivePersistence 15","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 15;;\n","type":"","out":""},{"in":"let _ = additivePersistence 16","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 16;;\n","type":"","out":""},{"in":"let _ = additivePersistence 17","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 17;;\n","type":"","out":""},{"in":"let _ = additivePersistence 18","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 18;;\n","type":"","out":""},{"in":"let _ = additivePersistence 19","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 19;;\n","type":"","out":""},{"in":"let _ = additivePersistence 20","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 20;;\n","type":"","out":""},{"in":"let _ = additivePersistence 21","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 21;;\n","type":"","out":""},{"in":"let _ = additivePersistence 22","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 22;;\n","type":"","out":""},{"in":"let _ = additivePersistence 23","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 23;;\n","type":"","out":""},{"in":"let _ = additivePersistence 24","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 24;;\n","type":"","out":""},{"in":"let _ = additivePersistence 25","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 25;;\n","type":"","out":""},{"in":"let _ = additivePersistence 26","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 26;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2993},"type":"eval"},"cursor":2992,"time":1.397353908355805e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n    if n < 10 then 0 \n    else \n      let sum = sumList newList in \n        if(sum < 10) then 1\n        else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 2\nlet _ = additivePersistence 3\nlet _ = additivePersistence 4\nlet _ = additivePersistence 5\nlet _ = additivePersistence 6\nlet _ = additivePersistence 7\nlet _ = additivePersistence 8\nlet _ = additivePersistence 9\nlet _ = additivePersistence 10\nlet _ = additivePersistence 11\nlet _ = additivePersistence 12\nlet _ = additivePersistence 13\nlet _ = additivePersistence 14\nlet _ = additivePersistence 15\nlet _ = additivePersistence 16\nlet _ = additivePersistence 17\nlet _ = additivePersistence 18\nlet _ = additivePersistence 19\nlet _ = additivePersistence 20\nlet _ = additivePersistence 21\nlet _ = additivePersistence 22\nlet _ = additivePersistence 23\nlet _ = additivePersistence 24\nlet _ = additivePersistence 25\nlet _ = additivePersistence 26\n\n\n\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n <= 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nif n < 10 then 0 \nelse \nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 2","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 2;;\n","type":"","out":""},{"in":"let _ = additivePersistence 3","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 3;;\n","type":"","out":""},{"in":"let _ = additivePersistence 4","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 4;;\n","type":"","out":""},{"in":"let _ = additivePersistence 5","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 5;;\n","type":"","out":""},{"in":"let _ = additivePersistence 6","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 6;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 8","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 8;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9;;\n","type":"","out":""},{"in":"let _ = additivePersistence 10","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 10;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 12","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 12;;\n","type":"","out":""},{"in":"let _ = additivePersistence 13","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 13;;\n","type":"","out":""},{"in":"let _ = additivePersistence 14","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 14;;\n","type":"","out":""},{"in":"let _ = additivePersistence 15","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 15;;\n","type":"","out":""},{"in":"let _ = additivePersistence 16","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 16;;\n","type":"","out":""},{"in":"let _ = additivePersistence 17","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 17;;\n","type":"","out":""},{"in":"let _ = additivePersistence 18","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 18;;\n","type":"","out":""},{"in":"let _ = additivePersistence 19","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 19;;\n","type":"","out":""},{"in":"let _ = additivePersistence 20","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 20;;\n","type":"","out":""},{"in":"let _ = additivePersistence 21","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 21;;\n","type":"","out":""},{"in":"let _ = additivePersistence 22","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 22;;\n","type":"","out":""},{"in":"let _ = additivePersistence 23","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 23;;\n","type":"","out":""},{"in":"let _ = additivePersistence 24","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 24;;\n","type":"","out":""},{"in":"let _ = additivePersistence 25","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 25;;\n","type":"","out":""},{"in":"let _ = additivePersistence 26","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 26;;\n","type":"","out":""},{"in":"let _ = additivePersistence 27","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 27;;\n","type":"","out":""},{"in":"let _ = additivePersistence 28","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 28;;\n","type":"","out":""},{"in":"let _ = additivePersistence 29","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 29;;\n","type":"","out":""},{"in":"let _ = additivePersistence 30","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 30;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3117},"type":"eval"},"cursor":3120,"time":1.397353976447634e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n    if n < 10 then 0 \n    else \n      let sum = sumList newList in \n        if(sum < 10) then 1\n        else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 2\nlet _ = additivePersistence 3\nlet _ = additivePersistence 4\nlet _ = additivePersistence 5\nlet _ = additivePersistence 6\nlet _ = additivePersistence 7\nlet _ = additivePersistence 8\nlet _ = additivePersistence 9\nlet _ = additivePersistence 10\nlet _ = additivePersistence 11\nlet _ = additivePersistence 12\nlet _ = additivePersistence 13\nlet _ = additivePersistence 14\nlet _ = additivePersistence 15\nlet _ = additivePersistence 16\nlet _ = additivePersistence 17\nlet _ = additivePersistence 18\nlet _ = additivePersistence 19\nlet _ = additivePersistence 20\nlet _ = additivePersistence 21\nlet _ = additivePersistence 22\nlet _ = additivePersistence 23\nlet _ = additivePersistence 24\nlet _ = additivePersistence 25\nlet _ = additivePersistence 26\nlet _ = additivePersistence 27\nlet _ = additivePersistence 28\nlet _ = additivePersistence 29\nlet _ = additivePersistence 30\n\n\n\n\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n <= 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nif n < 10 then 0 \nelse \nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 2","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 2;;\n","type":"","out":""},{"in":"let _ = additivePersistence 3","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 3;;\n","type":"","out":""},{"in":"let _ = additivePersistence 4","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 4;;\n","type":"","out":""},{"in":"let _ = additivePersistence 5","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 5;;\n","type":"","out":""},{"in":"let _ = additivePersistence 6","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 6;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 8","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 8;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9;;\n","type":"","out":""},{"in":"let _ = additivePersistence 10","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 10;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 12","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 12;;\n","type":"","out":""},{"in":"let _ = additivePersistence 13","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 13;;\n","type":"","out":""},{"in":"let _ = additivePersistence 14","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 14;;\n","type":"","out":""},{"in":"let _ = additivePersistence 15","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 15;;\n","type":"","out":""},{"in":"let _ = additivePersistence 16","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 16;;\n","type":"","out":""},{"in":"let _ = additivePersistence 17","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 17;;\n","type":"","out":""},{"in":"let _ = additivePersistence 18","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 18;;\n","type":"","out":""},{"in":"let _ = additivePersistence 19","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 19;;\n","type":"","out":""},{"in":"let _ = additivePersistence 20","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 20;;\n","type":"","out":""},{"in":"let _ = additivePersistence 21","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 21;;\n","type":"","out":""},{"in":"let _ = additivePersistence 22","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 22;;\n","type":"","out":""},{"in":"let _ = additivePersistence 23","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 23;;\n","type":"","out":""},{"in":"let _ = additivePersistence 24","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 24;;\n","type":"","out":""},{"in":"let _ = additivePersistence 25","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 25;;\n","type":"","out":""},{"in":"let _ = additivePersistence 26","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 26;;\n","type":"","out":""},{"in":"let _ = additivePersistence 27","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 27;;\n","type":"","out":""},{"in":"let _ = additivePersistence 28","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 28;;\n","type":"","out":""},{"in":"let _ = additivePersistence 29","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 29;;\n","type":"","out":""},{"in":"let _ = additivePersistence 30","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 30;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":3378},"type":"eval"},"cursor":3379,"time":1.397354075114689e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n    if n < 10 then 0 \n    else \n      let sum = sumList newList in \n        if(sum < 10) then 1\n        else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 2\nlet _ = additivePersistence 3\nlet _ = additivePersistence 4\nlet _ = additivePersistence 5\nlet _ = additivePersistence 6\nlet _ = additivePersistence 7\nlet _ = additivePersistence 8\nlet _ = additivePersistence 9\nlet _ = additivePersistence 10\nlet _ = additivePersistence 11\nlet _ = additivePersistence 12\nlet _ = additivePersistence 13\nlet _ = additivePersistence 14\nlet _ = additivePersistence 15\nlet _ = additivePersistence 16\nlet _ = additivePersistence 17\nlet _ = additivePersistence 18\nlet _ = additivePersistence 19\nlet _ = additivePersistence 20\nlet _ = additivePersistence 21\nlet _ = additivePersistence 22\nlet _ = additivePersistence 23\nlet _ = additivePersistence 24\nlet _ = additivePersistence 25\nlet _ = additivePersistence 26\nlet _ = additivePersistence 27\nlet _ = additivePersistence 28\nlet _ = additivePersistence 29\nlet _ = additivePersistence 30\n\n\n\n\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n <= 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nif n < 10 then 0 \nelse \nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9;;\n","type":"","out":""},{"in":"let _ = additivePersistence 10","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 10;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 18","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 18;;\n","type":"","out":""},{"in":"let _ = additivePersistence 19","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 19;;\n","type":"","out":""},{"in":"let _ = additivePersistence 20","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 20;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2669},"type":"eval"},"cursor":2670,"time":1.397354146113704e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n    if n < 10 then 0 \n    else \n      let sum = sumList newList in \n        if(sum < 10) then 1\n        else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 9\nlet _ = additivePersistence 10\nlet _ = additivePersistence 11\nlet _ = additivePersistence 18\nlet _ = additivePersistence 19\nlet _ = additivePersistence 20\n\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n <= 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nif n < 10 then 0 \nelse \nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9;;\n","type":"","out":""},{"in":"let _ = additivePersistence 10","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 10;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 18","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 18;;\n","type":"","out":""},{"in":"let _ = additivePersistence 19","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 19;;\n","type":"","out":""},{"in":"let _ = additivePersistence 20","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 20;;\n","type":"","out":""},{"in":"let _ = additivePersistence 199","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 199;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 19999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 19999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":2769},"type":"eval"},"cursor":2770,"time":1.397354217218376e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n    if n < 10 then 0 \n    else \n      let sum = sumList newList in \n        if(sum < 10) then 1\n        else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 9\nlet _ = additivePersistence 10\nlet _ = additivePersistence 11\nlet _ = additivePersistence 18\nlet _ = additivePersistence 19\nlet _ = additivePersistence 20\n\nlet _ = additivePersistence 199\nlet _ = additivePersistence 1999\nlet _ = additivePersistence 19999\n\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| [] -> 0\n| hd :: tl -> hd + sumList tl","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec helperDigits (num, newList) = \nif(num < 10) then num :: newList\nelse (helperDigits (num/10, (num mod 10)::newList) )","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif( n <= 0 ) then []\nelse helperDigits (n, [])","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-1)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt (-1);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 11;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet _ = digitsOfInt 1;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet newList = digitsOfInt n in\nif n < 10 then 0 \nelse \nlet sum = sumList newList in \nif(sum < 10) then 1\nelse 1 + additivePersistence sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9;;\n","type":"","out":""},{"in":"let _ = additivePersistence 10","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 10;;\n","type":"","out":""},{"in":"let _ = additivePersistence 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 11;;\n","type":"","out":""},{"in":"let _ = additivePersistence 18","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 18;;\n","type":"","out":""},{"in":"let _ = additivePersistence 19","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 19;;\n","type":"","out":""},{"in":"let _ = additivePersistence 20","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 20;;\n","type":"","out":""},{"in":"let _ = additivePersistence 199","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 199;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 19999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 19999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9999;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9884;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 9552;;\n","type":"","out":""},{"in":"let _ = additivePersistence 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 48;;\n","type":"","out":""},{"in":"let _ = additivePersistence 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 7;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 1486;;\n","type":"","out":""},{"in":"let _ = additivePersistence 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  let newList = digitsOfInt n in\n  if n < 10\n  then 0\n  else\n    (let sum = sumList newList in\n     if sum < 10 then 1 else 1 + (additivePersistence sum));;\n\nlet _ = additivePersistence 458;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet newList = digitsOfInt n in\nlet sum = sumList newList in \nif(sum < 10) then sum\nelse digitalRoot sum","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 11","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 11;;\n","type":"","out":""},{"in":"let _ = digitalRoot 999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9884","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9884;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9552","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 9552;;\n","type":"","out":""},{"in":"let _ = digitalRoot 48","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 48;;\n","type":"","out":""},{"in":"let _ = digitalRoot 7","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 7;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1486","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 1486;;\n","type":"","out":""},{"in":"let _ = digitalRoot 458","min":"\nlet rec helperDigits (num,newList) =\n  if num < 10\n  then num :: newList\n  else helperDigits ((num / 10), ((num mod 10) :: newList));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else helperDigits (n, []);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec digitalRoot n =\n  let newList = digitsOfInt n in\n  let sum = sumList newList in if sum < 10 then sum else digitalRoot sum;;\n\nlet _ = digitalRoot 458;;\n","type":"","out":""},{"in":"let rec reverseHelper(original, sofar) = match original with\n| [] -> sofar\n| hd :: tl -> reverseHelper(tl, hd::sofar)","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n","type":"","out":""},{"in":"let rec listReverse l = reverseHelper (l, [])","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet converted = explode w in \nif(converted = (listReverse converted)) then true\nelse false","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec reverseHelper (original,sofar) =\n  match original with\n  | [] -> sofar\n  | hd::tl -> reverseHelper (tl, (hd :: sofar));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\nlet palindrome w =\n  let converted = explode w in\n  if converted = (listReverse converted) then true else false;;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":7240},"type":"eval"},"cursor":252,"time":1.397454850218173e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | [] -> 0\n  | hd :: tl -> hd + sumList tl;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec helperDigits (num, newList) = \n  if(num < 10) then num :: newList\n  else (helperDigits (num/10, (num mod 10)::newList) );;\n\n\nlet rec digitsOfInt n =\n  if( n <= 0 ) then []\n  else helperDigits (n, []);;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n(*XXXXXXXXXX*)\nlet _ = digitsOfInt (-1);;\nlet _ = digitsOfInt 0\nlet _ = digitsOfInt 11\nlet _ = digitsOfInt 1 (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  let newList = digitsOfInt n in\n    if n < 10 then 0 \n    else \n      let sum = sumList newList in \n        if(sum < 10) then 1\n        else 1 + additivePersistence sum \n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXX*)\nlet _ = additivePersistence 0\nlet _ = additivePersistence 1\nlet _ = additivePersistence 9\nlet _ = additivePersistence 10\nlet _ = additivePersistence 11\nlet _ = additivePersistence 18\nlet _ = additivePersistence 19\nlet _ = additivePersistence 20\n\nlet _ = additivePersistence 199\nlet _ = additivePersistence 1999\nlet _ = additivePersistence 19999\n\nlet _ = additivePersistence 999\nlet _ = additivePersistence 9999\nlet _ = additivePersistence 9884\nlet _ = additivePersistence 9552\nlet _ = additivePersistence 48\nlet _ = additivePersistence 7\nlet _ = additivePersistence 1486\nlet _ = additivePersistence 458\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let newList = digitsOfInt n in\n  let sum = sumList newList in \n    if(sum < 10) then sum\n    else digitalRoot sum\n;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = digitalRoot 9876\n\n(*XXXXXXXXXX*)\nlet _ = digitalRoot 0\n\nlet _ = digitalRoot 1\nlet _ = digitalRoot 11\nlet _ = digitalRoot 999\nlet _ = digitalRoot 9999\nlet _ = digitalRoot 9884\n\nlet _ = digitalRoot 9552\nlet _ = digitalRoot 48\nlet _ = digitalRoot 7\nlet _ = digitalRoot 1486\nlet _ = digitalRoot 458\n\n\n\nlet rec reverseHelper(original, sofar) = match original with\n  | [] -> sofar\n  | hd :: tl -> reverseHelper(tl, hd::sofar)\n;;\n\nlet rec listReverse l = reverseHelper (l, []);;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\n\nlet palindrome w = \n  let converted = explode w in \n    if(converted = (listReverse converted)) then true\n    else false\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
