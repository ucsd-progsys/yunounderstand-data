{"ocaml":[],"event":{"region":{"start":5815,"stop":5973},"type":"eval"},"cursor":5973,"time":1.396598520481725e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec compareLists l1 l2 = \n  match (l1, l2) with\n    | ([],[]) -> true;\n    | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":5815,"stop":5973},"type":"eval"},"cursor":5973,"time":1.396598524443323e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec compareLists l1 l2 = \n  match (l1, l2) with\n    | ([],[]) -> true;\n    | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":5815,"stop":5973},"type":"eval"},"cursor":5973,"time":1.396598527053955e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec compareLists l1 l2 = \n  match (l1, l2) with\n    | ([],[]) -> true;\n    | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":5815,"stop":5973},"type":"eval"},"cursor":5973,"time":1.396598527920326e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec compareLists l1 l2 = \n  match (l1, l2) with\n    | ([],[]) -> true;\n    | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":5815,"stop":5973},"type":"eval"},"cursor":5973,"time":1.39659852897202e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec compareLists l1 l2 = \n  match (l1, l2) with\n    | ([],[]) -> true;\n    | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":5815,"stop":5973},"type":"eval"},"cursor":5973,"time":1.39659853131374e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec compareLists l1 l2 = \n  match (l1, l2) with\n    | ([],[]) -> true;\n    | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":5815,"stop":5972},"type":"eval"},"cursor":5973,"time":1.396598534698732e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec compareLists l1 l2 = \n  match (l1, l2) with\n    | ([],[]) -> true;\n    | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":4825,"stop":5812},"type":"eval"},"cursor":5654,"time":1.396598537751769e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec compareLists l1 l2 = \n  match (l1, l2) with\n    | ([],[]) -> true;\n    | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":4825,"stop":5973},"type":"eval"},"cursor":5654,"time":1.39659853989813e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec compareLists l1 l2 = \n  match (l1, l2) with\n    | ([],[]) -> true;\n    | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif (n > 0)\nthen (digitsOfInt (n/10)) @ [(n mod 10)]\nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') @ [x]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false","min":"\nlet rec compareLists l1 l2 =\n  match (l1, l2) with\n  | ([],[]) -> true\n  | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false;;\n","type":"","out":""},{"in":"let palindrome w = compareLists (explode w) (listReverse (explode w))","min":"\nlet rec compareLists l1 l2 =\n  match (l1, l2) with\n  | ([],[]) -> true\n  | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec compareLists l1 l2 =\n  match (l1, l2) with\n  | ([],[]) -> true\n  | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec compareLists l1 l2 =\n  match (l1, l2) with\n  | ([],[]) -> true\n  | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec compareLists l1 l2 =\n  match (l1, l2) with\n  | ([],[]) -> true\n  | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet rec compareLists l1 l2 =\n  match (l1, l2) with\n  | ([],[]) -> true\n  | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet rec compareLists l1 l2 =\n  match (l1, l2) with\n  | ([],[]) -> true\n  | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5973},"type":"eval"},"cursor":0,"time":1.396598554328383e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec compareLists l1 l2 = \n  match (l1, l2) with\n    | ([],[]) -> true;\n    | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false\n\nlet palindrome w = compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":2306,"stop":5978},"type":"eval"},"cursor":2763,"time":1.396598671570162e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif (n > 0)\nthen (digitsOfInt (n/10)) @ [(n mod 10)]\nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') @ [x]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5978},"type":"eval"},"cursor":0,"time":1.396653868670658e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":2594,"stop":6000},"type":"eval"},"cursor":2706,"time":1.396654115222059e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""}],"event":{"region":{"start":2596,"stop":2835},"type":"eval"},"cursor":2706,"time":1.396654119289587e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""}],"event":{"region":{"start":2594,"stop":2857},"type":"eval"},"cursor":2728,"time":1.396654139086393e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""}],"event":{"region":{"start":2594,"stop":2909},"type":"eval"},"cursor":2780,"time":1.396654182156881e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":2596,"stop":6074},"type":"eval"},"cursor":2780,"time":1.396654197375831e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif (n > 0)\nthen (digitsOfInt (n/10)) :: (n mod 10)\nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) :: (n mod 10) else [];;\n","type":"type","out":"Characters 41-61:\n  then (digitsOfInt (n/10)) :: (n mod 10)\n       ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') @ [x]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6073},"type":"eval"},"cursor":530,"time":1.397097872685685e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (digitsOfInt (n/10)) :: (n mod 10)\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') @ [x]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6073},"type":"eval"},"cursor":530,"time":1.397098017825534e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (n mod 10) :: (digitsOfInt (n/10))\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""}],"event":{"region":{"start":646,"stop":667},"type":"eval"},"cursor":667,"time":1.397098029592325e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (n mod 10) :: (digitsOfInt (n/10))\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""}],"event":{"region":{"start":540,"stop":564},"type":"eval"},"cursor":564,"time":1.397098032784847e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0)\n  then (n mod 10) :: (digitsOfInt (n/10))\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse explodeNum n","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse explodeNum n;;\n","type":"type","out":"Characters 100-111:\n  in listReverse explodeNum n;;\n     ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"region":{"start":257,"stop":579},"type":"eval"},"cursor":579,"time":1.397098106772601e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum =\n    if (n > 0)\n    then (n mod 10) :: (digitsOfInt (n/10))\n    else []\n  in listReverse explodeNum n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n = \nlet explodeNum =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum = if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n","type":"type","out":"Characters 113-123:\n  in listReverse (explodeNum n);;\n                  ^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}],"event":{"region":{"start":257,"stop":581},"type":"eval"},"cursor":581,"time":1.397098116202998e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum =\n    if (n > 0)\n    then (n mod 10) :: (digitsOfInt (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n","type":"","out":""}],"event":{"region":{"start":257,"stop":583},"type":"eval"},"cursor":493,"time":1.397098124159388e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (digitsOfInt (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""}],"event":{"region":{"start":583,"stop":712},"type":"eval"},"cursor":712,"time":1.397098129313761e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (digitsOfInt (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') :: [x]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> [listReverse l'; x];;\n","type":"type","out":"Characters 62-78:\n  | (x::l') -> (listReverse l') :: [x];;\n               ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}],"event":{"region":{"start":712,"stop":2276},"type":"eval"},"cursor":2272,"time":1.397098164062734e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (digitsOfInt (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') :: [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') :: x :: []","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> [listReverse l'; x];;\n","type":"type","out":"Characters 62-78:\n  | (x::l') -> (listReverse l') :: x :: [];;\n               ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}],"event":{"region":{"start":2188,"stop":2280},"type":"eval"},"cursor":2280,"time":1.397098233301479e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (digitsOfInt (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') :: x :: []\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> []\n| (x::l') -> x :: e :: r e l'\nin r [] l","min":"\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> x :: e :: (r e l') in\n  r [] l;;\n","type":"","out":""}],"event":{"region":{"start":2188,"stop":2291},"type":"eval"},"cursor":2240,"time":1.397098662861996e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (digitsOfInt (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec r e a =\n    match a with\n      | [] -> []\n      | (x::l') -> x :: e :: r e l'\n  in r [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> x :: e :: (r e l') in\n  r [] l;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"type","out":"Characters 21-22:\n  let _ = listReverse [1; 2; 3; 4];;\n                       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"region":{"start":2291,"stop":2325},"type":"eval"},"cursor":2325,"time":1.397098666122562e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (digitsOfInt (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec r e a =\n    match a with\n      | [] -> []\n      | (x::l') -> x :: e :: r e l'\n  in r [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> []\n| (x::l') -> (r e l') :: x :: e\nin r [] l","min":"\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n","type":"type","out":"Characters 74-82:\n  | (x::l') -> (r e l') :: x :: e\n               ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}],"event":{"region":{"start":2188,"stop":2293},"type":"eval"},"cursor":2277,"time":1.397098710382809e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (digitsOfInt (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec r e a =\n    match a with\n      | [] -> []\n      | (x::l') -> (r e l') :: x :: e\n  in r [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rec r e a =\nmatch a with\n| [] -> e\n| (x::l') -> (r e l') :: x :: e\nin r [] l","min":"\nlet listReverse l =\n  let rec r e a = match a with | [] -> e | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n","type":"type","out":"Characters 73-81:\n  | (x::l') -> (r e l') :: x :: e\n               ^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}],"event":{"region":{"start":2188,"stop":2292},"type":"eval"},"cursor":2250,"time":1.39709888447335e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (digitsOfInt (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec r e a =\n    match a with\n      | [] -> e\n      | (x::l') -> (r e l') :: x :: e\n  in r [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (digitsOfInt (n/10))\nelse []\nin listReverse (explodeNum n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> x :: e :: (r e l') in\n  r [] l;;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n","type":"type","out":"Characters 114-128:\n  in listReverse (explodeNum n);;\n                 ^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a list list\n       Type int is not compatible with type 'a list \n"},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') @ [x]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6118},"type":"eval"},"cursor":0,"time":1.397098954062702e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (digitsOfInt (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n","type":"scope","out":"Characters 71-81:\n  then (n mod 10) :: (explodeNum (n/10))\n                      ^^^^^^^^^^\nError: Unbound value explodeNum\n"}],"event":{"region":{"start":257,"stop":582},"type":"eval"},"cursor":536,"time":1.397098975678839e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (explodeNum (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n","type":"scope","out":"Characters 71-81:\n  then (n mod 10) :: (explodeNum (n/10))\n                      ^^^^^^^^^^\nError: Unbound value explodeNum\n"},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') @ [x]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":257,"stop":6117},"type":"eval"},"cursor":526,"time":1.397098985136502e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (explodeNum (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let digitsOfInt n = \nlet explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n","type":"scope","out":"Characters 71-81:\n  then (n mod 10) :: (explodeNum (n/10))\n                      ^^^^^^^^^^\nError: Unbound value explodeNum\n"},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [];;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let explodeNum n =\n    if n > 0 then (n mod 10) :: (digitsOfInt (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') @ [x]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6117},"type":"eval"},"cursor":526,"time":1.397098986722189e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (explodeNum (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n = \nlet rec explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n","type":"","out":""}],"event":{"region":{"start":257,"stop":586},"type":"eval"},"cursor":484,"time":1.397099001641e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let rec explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (explodeNum (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n = \nlet rec explodeNum n =\nif (n > 0)\nthen (n mod 10) :: (explodeNum (n/10))\nelse []\nin listReverse (explodeNum n)","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet digitsOfInt n =\n  let rec explodeNum n =\n    if n > 0 then (n mod 10) :: (explodeNum (n / 10)) else [] in\n  listReverse (explodeNum n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') @ [x]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":257,"stop":6121},"type":"eval"},"cursor":560,"time":1.397099021798218e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n = \n  let rec explodeNum n =\n    if (n > 0)\n    then (n mod 10) :: (explodeNum (n/10))\n    else []\n  in listReverse (explodeNum n)\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n =\nif (n > 0)\nthen (digitsOfInt (n/10)) @ [(n mod 10)]\nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| (x::l') -> (listReverse l') @ [x]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":257,"stop":6073},"type":"eval"},"cursor":507,"time":1.397099066245394e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n =\nif (n > 0)\nthen (digitsOfInt (n/10)) :: (n mod 10) :: []\nelse 0","min":"\nlet rec digitsOfInt n = if n > 0 then [digitsOfInt (n / 10); n mod 10] else 0;;\n","type":"type","out":"Characters 40-60:\n  then (digitsOfInt (n/10)) :: (n mod 10) :: []\n       ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}],"event":{"region":{"start":257,"stop":542},"type":"eval"},"cursor":542,"time":1.397099422683818e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) :: (n mod 10) :: []\n  else 0\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | (x::l') -> (listReverse l') @ [x]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n =\nif (n > 0)\nthen (digitsOfInt (n/10)) @ [(n mod 10)]\nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let listReverse l = \nlet rev [] o =\nmatch o with\n| [] -> []\n| (hd::tl) -> rev tl (hd::o)","min":"","type":"syntax","out":"Characters 88-90:\n  | (hd::tl) -> rev tl (hd::o);;\n                              ^^\nError: Syntax error\n"},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::l' -> (listReverse l') @ [x];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6077},"type":"eval"},"cursor":2234,"time":1.397099729501683e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rev [] o =\n    match o with\n      | [] -> []\n      | (hd::tl) -> rev tl (hd::o)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rev [] o =\nmatch o with\n| [] -> []\n| (hd::tl) -> rev tl (hd::o)","min":"","type":"syntax","out":"Characters 88-90:\n  | (hd::tl) -> rev tl (hd::o);;\n                              ^^\nError: Syntax error\n"}],"event":{"region":{"start":2143,"stop":2234},"type":"eval"},"cursor":2236,"time":1.397099740269074e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rev [] o =\n    match o with\n      | [] -> []\n      | (hd::tl) -> rev tl (hd::o);;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rev [] o =\nmatch o with\n| [] -> []\n| (hd::tl) -> rev tl (hd::o)","min":"","type":"syntax","out":"Characters 88-90:\n  | (hd::tl) -> rev tl (hd::o);;\n                              ^^\nError: Syntax error\n"}],"event":{"region":{"start":2143,"stop":2234},"type":"eval"},"cursor":2234,"time":1.397099742567997e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rev [] o =\n    match o with\n      | [] -> []\n      | (hd::tl) -> rev tl (hd::o)\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rev [] o =\nmatch o with\n| [] -> []\n| (hd::tl) -> rev tl (hd::o)\nin rev l []","min":"\nlet listReverse l =\n  let rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n","type":"scope","out":"Characters 74-77:\n  | (hd::tl) -> rev tl (hd::o)\n                ^^^\nError: Unbound value rev\n"}],"event":{"region":{"start":2143,"stop":2246},"type":"eval"},"cursor":2246,"time":1.397099754483161e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rev [] o =\n    match o with\n      | [] -> []\n      | (hd::tl) -> rev tl (hd::o)\n  in rev l []\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rec rev [] o =\nmatch o with\n| [] -> []\n| (hd::tl) -> rev tl (hd::o)\nin rev l []","min":"\nlet listReverse l =\n  let rec rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":2143,"stop":6093},"type":"eval"},"cursor":2175,"time":1.397099763399303e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev [] o =\n    match o with\n      | [] -> []\n      | (hd::tl) -> rev tl (hd::o)\n  in rev l []\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec rev [] o = match o with | [] -> [] | hd::tl -> rev tl (hd :: o) in\n  rev l [];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""}],"event":{"region":{"start":2250,"stop":2284},"type":"eval"},"cursor":2284,"time":1.397099812255425e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev [] o =\n    match o with\n      | [] -> []\n      | (hd::tl) -> rev tl (hd::o)\n  in rev l []\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rec rev [] o = o\n| (hd::tl) -> rev tl (hd::o)\nin rev l []","min":"","type":"syntax","out":"Characters 42-43:\n  | (hd::tl) -> rev tl (hd::o)\n  ^\nError: Syntax error\n"}],"event":{"region":{"start":2143,"stop":2228},"type":"eval"},"cursor":2187,"time":1.397099841782223e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev [] o = o\n                   | (hd::tl) -> rev tl (hd::o)\n  in rev l []\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rec rev o = \n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l","min":"","type":"syntax","out":"Characters 38-39:\n  | [] -> o\n  ^\nError: Syntax error\n"}],"event":{"region":{"start":2143,"stop":2228},"type":"eval"},"cursor":2228,"time":1.397099946875528e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o = \n    | [] -> o\n    | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rec rev o = function\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l","min":"\nlet listReverse l =\n  let rec rev o = function | [] -> o | h::t -> rev (h :: o) t in rev [] l;;\n","type":"","out":""}],"event":{"region":{"start":2143,"stop":2236},"type":"eval"},"cursor":2191,"time":1.397099951872036e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o = function\n    | [] -> o\n    | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec rev o = function | [] -> o | h::t -> rev (h :: o) t in rev [] l;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""}],"event":{"region":{"start":2236,"stop":2270},"type":"eval"},"cursor":2270,"time":1.39709995651671e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o = function\n    | [] -> o\n    | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rec rev o = function\n| [] -> []\n| h::t -> rev (h::o) t\nin rev [] l","min":"\nlet listReverse l =\n  let rec rev o = function | [] -> [] | h::t -> rev (h :: o) t in rev [] l;;\n","type":"","out":""}],"event":{"region":{"start":2143,"stop":2237},"type":"eval"},"cursor":2202,"time":1.397100021601196e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o = function\n    | [] -> []\n    | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec rev o = function | [] -> [] | h::t -> rev (h :: o) t in rev [] l;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""}],"event":{"region":{"start":2237,"stop":2271},"type":"eval"},"cursor":2266,"time":1.397100023900671e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o = function\n    | [] -> []\n    | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rec rev o = fun\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l","min":"","type":"syntax","out":"Characters 41-42:\n  | [] -> o\n  ^\nError: Syntax error\n"}],"event":{"region":{"start":2143,"stop":2231},"type":"eval"},"cursor":2186,"time":1.397100037731227e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o = fun\n    | [] -> o\n          | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rec rev o = function\n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l","min":"\nlet listReverse l =\n  let rec rev o = function | [] -> o | h::t -> rev (h :: o) t in rev [] l;;\n","type":"","out":""}],"event":{"region":{"start":2143,"stop":2236},"type":"eval"},"cursor":2191,"time":1.397100043816412e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o = function\n    | [] -> o\n    | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse l = \nlet rec rev o a = \nmatch a with \n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l","min":"\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n","type":"","out":""}],"event":{"region":{"start":2143,"stop":2244},"type":"eval"},"cursor":2186,"time":1.397100260245002e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o a = \n    match a with \n      | [] -> o\n      | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""}],"event":{"region":{"start":2244,"stop":2278},"type":"eval"},"cursor":2267,"time":1.397100263378458e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n =\n  if (n > 0)\n  then (digitsOfInt (n/10)) @ [(n mod 10)]\n  else []\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o a = \n    match a with \n      | [] -> o\n      | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen (digitsOfInt ((a mod 10)::o) (a/10))\nelse []\nin digits [] n;\n\nlet _ = digitsOfInt 3124","min":"","type":"syntax","out":"Characters 144-146:\n  let _ = digitsOfInt 3124;;\n                          ^^\nError: Syntax error\n"}],"event":{"region":{"start":257,"stop":599},"type":"eval"},"cursor":557,"time":1.397100432089709e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n =\n  let rec digits o a = \n    if (a > 0)\n    then (digitsOfInt ((a mod 10)::o) (a/10))\n    else []\n  in digits [] n;\n\n    let _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o a = \n    match a with \n      | [] -> o\n      | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digitsOfInt ((a mod 10)::o) (a/10)\nelse []\nin digits [] n","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digitsOfInt n =\n  let rec digits o a =\n    if a > 0 then digitsOfInt ((a mod 10) :: o) (a / 10) else [] in\n  digits [] n;;\n","type":"type","out":"Characters 58-69:\n  then digitsOfInt ((a mod 10)::o) (a/10)\n       ^^^^^^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""}],"event":{"region":{"start":257,"stop":596},"type":"eval"},"cursor":588,"time":1.397100464765535e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n =\n  let rec digits o a = \n    if (a > 0)\n    then digitsOfInt ((a mod 10)::o) (a/10)\n    else []\n  in digits [] n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o a = \n    match a with \n      | [] -> o\n      | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digits ((a mod 10)::o) (a/10)\nelse []\nin digits [] n","min":"\nlet digitsOfInt n =\n  let rec digits o a =\n    if a > 0 then digits ((a mod 10) :: o) (a / 10) else [] in\n  digits [] n;;\n","type":"","out":""}],"event":{"region":{"start":257,"stop":565},"type":"eval"},"cursor":519,"time":1.397100473652388e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n =\n  let rec digits o a = \n    if (a > 0)\n    then digits ((a mod 10)::o) (a/10)\n    else []\n  in digits [] n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o a = \n    match a with \n      | [] -> o\n      | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet digitsOfInt n =\n  let rec digits o a =\n    if a > 0 then digits ((a mod 10) :: o) (a / 10) else [] in\n  digits [] n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""}],"event":{"region":{"start":565,"stop":591},"type":"eval"},"cursor":588,"time":1.397100476004254e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n =\n  let rec digits o a = \n    if (a > 0)\n    then digits ((a mod 10)::o) (a/10)\n    else []\n  in digits [] n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o a = \n    match a with \n      | [] -> o\n      | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digits ((a mod 10)::o) (a/10)\nelse o\nin digits [] n","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n","type":"","out":""}],"event":{"region":{"start":257,"stop":564},"type":"eval"},"cursor":549,"time":1.39710048845401e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n =\n  let rec digits o a = \n    if (a > 0)\n    then digits ((a mod 10)::o) (a/10)\n    else o\n  in digits [] n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o a = \n    match a with \n      | [] -> o\n      | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""}],"event":{"region":{"start":564,"stop":590},"type":"eval"},"cursor":586,"time":1.397100491230448e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n =\n  let rec digits o a = \n    if (a > 0)\n    then digits ((a mod 10)::o) (a/10)\n    else o\n  in digits [] n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o a = \n    match a with \n      | [] -> o\n      | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digits ((a mod 10)::o) (a/10)\nelse o\nin digits [] n","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec rev o a = \nmatch a with \n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l","min":"\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6113},"type":"eval"},"cursor":0,"time":1.397100524873761e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n =\n  let rec digits o a = \n    if (a > 0)\n    then digits ((a mod 10)::o) (a/10)\n    else o\n  in digits [] n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o a = \n    match a with \n      | [] -> o\n      | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digits ((a mod 10)::o) (a/10)\nelse o\nin digits [] n","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec rev o a = \nmatch a with \n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l","min":"\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6113},"type":"eval"},"cursor":0,"time":1.397100530763309e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n =\n  let rec digits o a = \n    if (a > 0)\n    then digits ((a mod 10)::o) (a/10)\n    else o\n  in digits [] n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o a = \n    match a with \n      | [] -> o\n      | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| (x::xs') -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let digitsOfInt n =\nlet rec digits o a = \nif (a > 0)\nthen digits ((a mod 10)::o) (a/10)\nelse o\nin digits [] n","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-5)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt (-5);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (900000)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 900000;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 0","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet _ = digitsOfInt 0;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n =\nmatch digitsOfInt n with\n| [x] -> 0\n| _ -> 1 + (additivePersistence (sumList (digitsOfInt n)))","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 123","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 123;;\n","type":"","out":""},{"in":"let _ = additivePersistence 1","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 987654322","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n  | x::[] -> 0\n  | _ -> 1 + (additivePersistence (sumList (digitsOfInt n)));;\n\nlet _ = additivePersistence 987654322;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif(sumList (digitsOfInt n) > 9)\nthen digitalRoot (sumList (digitsOfInt n))\nelse sumList (digitsOfInt n)","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 1234","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1234;;\n","type":"","out":""},{"in":"let _ = digitalRoot 12345","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 12345;;\n","type":"","out":""},{"in":"let _ = digitalRoot 001","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 1;;\n","type":"","out":""},{"in":"let _ = digitalRoot 10000","min":"\nlet digitsOfInt n =\n  let rec digits o a = if a > 0 then digits ((a mod 10) :: o) (a / 10) else o in\n  digits [] n;;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (sumList (digitsOfInt n)) > 9\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n);;\n\nlet _ = digitalRoot 10000;;\n","type":"","out":""},{"in":"let listReverse l = \nlet rec rev o a = \nmatch a with \n| [] -> o\n| h::t -> rev (h::o) t\nin rev [] l","min":"\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = \nlet rec compareLists l1 l2 = \nmatch (l1, l2) with\n| ([],[]) -> true;\n| (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n| ([], _::_) -> false\n| (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \nin \ncompareLists (explode w) (listReverse (explode w))","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"dood\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"dood\";;\n","type":"","out":""},{"in":"let _ = palindrome \"james\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec rev o a = match a with | [] -> o | h::t -> rev (h :: o) t in\n  rev [] l;;\n\nlet palindrome w =\n  let rec compareLists l1 l2 =\n    match (l1, l2) with\n    | ([],[]) -> true\n    | (_::_,[]) -> false\n    | ([],_::_) -> false\n    | (h1::l1',h2::l2') -> if h1 = h2 then compareLists l1' l2' else false in\n  compareLists (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"james\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6113},"type":"eval"},"cursor":2206,"time":1.397100589531805e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | (x::xs') -> x + sumList xs'\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet digitsOfInt n =\n  let rec digits o a = \n    if (a > 0)\n    then digits ((a mod 10)::o) (a/10)\n    else o\n  in digits [] n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\nlet _ = digitsOfInt (-5)\nlet _ = digitsOfInt (900000)\nlet _ = digitsOfInt 0\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet rec additivePersistence n =\n  match digitsOfInt n with\n    | [x] -> 0\n    | _ -> 1 + (additivePersistence (sumList (digitsOfInt n))) \n\n\nlet _ = additivePersistence 9876\nlet _ = additivePersistence 123\nlet _ = additivePersistence 1\nlet _ = additivePersistence 987654322\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if(sumList (digitsOfInt n) > 9)\n  then digitalRoot (sumList (digitsOfInt n))\n  else sumList (digitsOfInt n)\n\nlet _ = digitalRoot 9876\nlet _ = digitalRoot 1234\nlet _ = digitalRoot 12345\nlet _ = digitalRoot 001\nlet _ = digitalRoot 10000\n\n\nlet listReverse l = \n  let rec rev o a = \n    match a with \n      | [] -> o\n      | h::t -> rev (h::o) t\n  in rev [] l\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = \n  let rec compareLists l1 l2 = \n    match (l1, l2) with\n      | ([],[]) -> true;\n      | (_::_, []) -> false (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      | ([], _::_) -> false\n      | (h1::l1',h2::l2') -> if h1 = h2 then (compareLists l1' l2') else false \n  in \n    compareLists (explode w) (listReverse (explode w))\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"dood\"\nlet _ = palindrome \"james\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
