{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x^a in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1243},"type":"eval"},"cursor":1091,"time":1.398980557537776e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x^a in\n      let base = sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1244},"type":"eval"},"cursor":1092,"time":1.398980819843077e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""}],"event":{"region":{"start":1247,"stop":1392},"type":"eval"},"cursor":1247,"time":1.398980823652661e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1241},"type":"eval"},"cursor":1092,"time":1.398980846269774e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^a^x in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (a ^ x) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1243},"type":"eval"},"cursor":1091,"time":1.398981027723142e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^a^x in\n      let base = sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (a ^ x) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1247,"stop":1289},"type":"eval"},"cursor":1247,"time":1.398981031380496e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^a^x in\n      let base = sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^a^(sepConcat sep t) in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (a ^ (sepConcat sep t)) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1259},"type":"eval"},"cursor":1092,"time":1.398981066073161e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^a^(sepConcat sep t) in\n      let base = sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (a ^ (sepConcat sep t)) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1263,"stop":1305},"type":"eval"},"cursor":1263,"time":1.398981068660269e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^a^(sepConcat sep t) in\n      let base = sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(sepConcat sep t) in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat sep t) in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1259},"type":"eval"},"cursor":1092,"time":1.398981089327354e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(sepConcat sep t) in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat sep t) in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1263,"stop":1305},"type":"eval"},"cursor":1263,"time":1.398981092002389e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(sepConcat sep t) in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1243},"type":"eval"},"cursor":1091,"time":1.398981113623927e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1247,"stop":1289},"type":"eval"},"cursor":1247,"time":1.398981116598598e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1243},"type":"eval"},"cursor":1092,"time":1.398981134442829e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1246,"stop":1289},"type":"eval"},"cursor":1246,"time":1.398981136984413e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x^(sepConcat sep t) in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ (sepConcat sep t)) in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1262},"type":"eval"},"cursor":1092,"time":1.398981203114113e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x^(sepConcat sep t) in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ (sepConcat sep t)) in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1264,"stop":1307},"type":"eval"},"cursor":1264,"time":1.398981209079081e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x^(sepConcat sep t) in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(sepConcat sep t) in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat sep t) in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1260},"type":"eval"},"cursor":1092,"time":1.398981229592444e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(sepConcat sep t) in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat sep t) in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1262,"stop":1305},"type":"eval"},"cursor":1262,"time":1.398981232611912e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(sepConcat sep t) in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(sepConcat sep t) in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat sep t) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1258},"type":"eval"},"cursor":1092,"time":1.398981257780518e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(sepConcat sep t) in\n      let base = sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat sep t) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1261,"stop":1303},"type":"eval"},"cursor":1261,"time":1.398981269776184e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(sepConcat sep t) in\n      let base = sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x^a in\nlet base = sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1243},"type":"eval"},"cursor":1092,"time":1.398981829961995e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x^a in\n      let base = sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""}],"event":{"region":{"start":1246,"stop":1392},"type":"eval"},"cursor":1246,"time":1.398981832716965e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x^a in\n      let base = sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = sl in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1278},"type":"eval"},"cursor":1092,"time":1.398981871121026e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = sl in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1278},"type":"eval"},"cursor":1092,"time":1.398981872335311e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = sep in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1235,"stop":1278},"type":"eval"},"cursor":1235,"time":1.398981876369444e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.rev x^a in\nlet base = sep in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (List.rev x) ^ a in\n      let base = sep in let l = sl in List.fold_left f base l;;\n","type":"type","out":"Characters 78-88:\n  let f a x = List.rev x^a in\n              ^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n"}],"event":{"region":{"start":1091,"stop":1242},"type":"eval"},"cursor":1091,"time":1.398981904930682e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = List.rev x^a in\n      let base = sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = List.rev t^a in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (List.rev t) ^ a in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n","type":"type","out":"Characters 78-88:\n  let f a x = List.rev t^a in\n              ^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type string\n"}],"event":{"region":{"start":1091,"stop":1243},"type":"eval"},"cursor":1091,"time":1.398981958434636e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = List.rev t^a in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1234},"type":"eval"},"cursor":1091,"time":1.398982028746084e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1237,"stop":1280},"type":"eval"},"cursor":1237,"time":1.398982031711502e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^a in\nlet base = h^sep in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1243},"type":"eval"},"cursor":1092,"time":1.398982066399683e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ a in\n      let base = h ^ sep in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1247,"stop":1289},"type":"eval"},"cursor":1247,"time":1.398982069768508e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^a in\n      let base = h^sep in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1242},"type":"eval"},"cursor":1092,"time":1.3989821515504e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1245,"stop":1288},"type":"eval"},"cursor":1245,"time":1.398982154470844e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x^(sepConcat sep t) in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ (sepConcat sep t)) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1261},"type":"eval"},"cursor":1092,"time":1.398982184913499e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x^(sepConcat sep t) in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ (sepConcat sep t)) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1263,"stop":1306},"type":"eval"},"cursor":1263,"time":1.398982187830877e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x^(sepConcat sep t) in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x^a in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1244},"type":"eval"},"cursor":1091,"time":1.398982202848345e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x^a in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1247,"stop":1290},"type":"eval"},"cursor":1247,"time":1.398982206470235e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x^a in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1243},"type":"eval"},"cursor":1092,"time":1.398982242421452e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1244,"stop":1288},"type":"eval"},"cursor":1244,"time":1.398982246250057e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^x in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (List.hd t) ^a in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (List.hd t) ^ a in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1254},"type":"eval"},"cursor":1092,"time":1.39898228191014e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (List.hd t) ^a in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (List.hd t) ^ a in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1257,"stop":1299},"type":"eval"},"cursor":1257,"time":1.398982284630579e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (List.hd t) ^a in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(a^x) in\nlet base = h in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (a ^ x) in\n      let base = h in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1242},"type":"eval"},"cursor":1091,"time":1.398982361169321e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(a^x) in\n      let base = h in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (a ^ x) in\n      let base = h in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1246,"stop":1288},"type":"eval"},"cursor":1246,"time":1.398982363954207e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(a^x) in\n      let base = h in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(a^x) in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (a ^ x) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1090,"stop":1246},"type":"eval"},"cursor":1090,"time":1.398982382523e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(a^x) in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (a ^ x) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1250,"stop":1292},"type":"eval"},"cursor":1250,"time":1.39898238510677e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(a^x) in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^(a^(sepConcat sep t)) in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (a ^ (sepConcat sep t)) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1262},"type":"eval"},"cursor":1091,"time":1.39898241862979e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(a^(sepConcat sep t)) in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a+x*x in\nlet base = 0\nin\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = List.map x a in\nlet base = [] in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"type","out":"Characters 8-12:\n  let _ = pipe [] 3;;\n          ^^^^\nError: This function has type ('a -> 'a) list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 8-12:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n          ^^^^\nError: This function has type ('a -> 'a) list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"type","out":"Characters 8-12:\n  let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3;;\n          ^^^^\nError: This function has type ('a -> 'a) list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"region":{"start":0,"stop":1087},"type":"eval"},"cursor":1089,"time":1.398982421582557e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(a^(sepConcat sep t)) in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (a ^ (sepConcat sep t)) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1265,"stop":1308},"type":"eval"},"cursor":1265,"time":1.398982425060547e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^(a^(sepConcat sep t)) in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^a)^x in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ a) ^ x in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1246},"type":"eval"},"cursor":1092,"time":1.39898249433788e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (x^a)^x in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ a) ^ x in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1250,"stop":1292},"type":"eval"},"cursor":1250,"time":1.398982496837763e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (x^a)^x in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a^x)^a in\nlet base = h in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (a ^ x) ^ a in\n      let base = h in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1242},"type":"eval"},"cursor":1092,"time":1.398982583627739e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (a^x)^a in\n      let base = h in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (a ^ x) ^ a in\n      let base = h in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1245,"stop":1288},"type":"eval"},"cursor":1245,"time":1.39898258628423e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (a^x)^a in\n      let base = h in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a^x)^a in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (a ^ x) ^ a in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1246},"type":"eval"},"cursor":1092,"time":1.398982612339768e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (a^x)^a in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (a ^ x) ^ a in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1249,"stop":1292},"type":"eval"},"cursor":1249,"time":1.398982615548511e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (a^x)^a in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^a)^x^a in\nlet base = sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ a) ^ (x ^ a) in\n      let base = sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1248},"type":"eval"},"cursor":1091,"time":1.398982699996355e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (h^a)^x^a in\n      let base = sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ a) ^ (x ^ a) in\n      let base = sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1249,"stop":1292},"type":"eval"},"cursor":1249,"time":1.39898270473188e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = (h^a)^x^a in\n      let base = sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^x^a in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (x ^ a) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1244},"type":"eval"},"cursor":1091,"time":1.39898287063237e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^x^a in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (x ^ a) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1248,"stop":1290},"type":"eval"},"cursor":1248,"time":1.398982888423104e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^x^a in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sepConcat a x)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sepConcat a x) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"type","out":"Characters 164-165:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string list\n       but an expression was expected of type string list list\n       Type string is not compatible with type string list \n"}],"event":{"region":{"start":1092,"stop":1258},"type":"eval"},"cursor":1092,"time":1.398982991394525e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ (sepConcat a x)in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^a)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1247},"type":"eval"},"cursor":1091,"time":1.398983015790934e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ (x^a)in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = h ^ sep in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1250,"stop":1293},"type":"eval"},"cursor":1250,"time":1.398983018437188e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ (x^a)in\n      let base = h^sep in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^a)in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1240},"type":"eval"},"cursor":1092,"time":1.398983127483554e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ (x^a)in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (x ^ a) in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1243,"stop":1285},"type":"eval"},"cursor":1243,"time":1.398983130207622e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a ^ (x^a)in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = h^ a ^ x in\nlet base = h^sep in\nlet l = sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (a ^ x) in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1239},"type":"eval"},"cursor":1091,"time":1.398983191127946e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = h ^ (a ^ x) in\n      let base = h ^ sep in let l = sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1243,"stop":1285},"type":"eval"},"cursor":1243,"time":1.398983193707012e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = List.hd(l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin ","min":"","type":"syntax","out":"Characters 154-156:\n  in ;;\n     ^^\nError: Syntax error\n"}],"event":{"region":{"start":2398,"stop":2552},"type":"eval"},"cursor":2398,"time":1.398983598165693e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = a+x in\n    let base = List.hd(l1) in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a*10+x*10 in\nlet base = List.hd l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a * 10) + (x * 10) in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 122-148:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}],"event":{"region":{"start":2398,"stop":2590},"type":"eval"},"cursor":2398,"time":1.398983723064082e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = a*10+x*10 in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 108-134:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}],"event":{"region":{"start":2397,"stop":2576},"type":"eval"},"cursor":2397,"time":1.398983793182549e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = a+x in\n    let base = l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = [a+x] in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 125-126:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int -> int list\n       but an expression was expected of type int -> int -> int\n       Type int list is not compatible with type int \n"}],"event":{"region":{"start":2397,"stop":2578},"type":"eval"},"cursor":2397,"time":1.398983845693353e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = [a+x] in\n    let base = l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = [a+x] in\nlet base = List.hd l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 133-134:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int -> int list\n       but an expression was expected of type int -> int -> int\n       Type int list is not compatible with type int \n"}],"event":{"region":{"start":2398,"stop":2586},"type":"eval"},"cursor":2398,"time":1.398983867310795e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = [a+x] in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = add(List.combine a x)in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = add (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"scope","out":"Characters 52-55:\n  let f a x = add(List.combine a x)in\n              ^^^\nError: Unbound value add\n"}],"event":{"region":{"start":2398,"stop":2594},"type":"eval"},"cursor":2398,"time":1.398984157164152e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = add(List.combine a x)in\n    let base = l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (+)(List.combine a x)in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (+) (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 55-73:\n  let f a x = (+)(List.combine a x)in\n                 ^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int\n"}],"event":{"region":{"start":2397,"stop":2593},"type":"eval"},"cursor":2397,"time":1.398984173746014e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = (+)(List.combine a x)in\n    let base = l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (+) List. hd (List.combine a x)in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.hd + (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 56-64:\n  let f a x = (+) List. hd (List.combine a x)in\n                  ^^^^^^^^\nError: This expression has type 'a list -> 'a\n       but an expression was expected of type int\n"}],"event":{"region":{"start":2398,"stop":2604},"type":"eval"},"cursor":2398,"time":1.398984198291307e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = (+) List. hd (List.combine a x)in\n    let base = l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0,0)::List rev (List.combine a x)in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"","type":"syntax","out":"Characters 68-69:\n  let f a x = (0,0)::List rev (List.combine a x)in\n                              ^\nError: Syntax error\n"}],"event":{"region":{"start":2398,"stop":2607},"type":"eval"},"cursor":2398,"time":1.39898430419338e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = (0,0)::List rev (List.combine a x)in\n    let base = l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a+x in\nlet base = List.hd l1 in\nlet args = List.hd l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.hd l1 in\n    let args = List.hd l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 124-150:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}],"event":{"region":{"start":2447,"stop":2641},"type":"eval"},"cursor":2447,"time":1.398985296296825e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = a+x in\n    let base = List.hd l1 in\n    let args = List.hd l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = List.map (+) a x in\nlet base = List.hd (L1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (+) a x in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 52-60:\n  let f a x = List.map (+) a x in\n              ^^^^^^^^\nError: This function has type ('a -> 'b) -> 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"region":{"start":2447,"stop":2648},"type":"eval"},"cursor":2447,"time":1.398985550481768e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (+) a x in\n    let base = List.hd (L1) in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = List.map (a+x) in\nlet base = List.hd (L1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (a + x) in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 61-66:\n  let f a x = List.map (a+x) in\n                       ^^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> 'b\n"}],"event":{"region":{"start":2447,"stop":2648},"type":"eval"},"cursor":2447,"time":1.398985625437293e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (a+x) in\n    let base = List.hd (L1) in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = List.map (sum)(a,x) in","min":"","type":"syntax","out":"Characters 74-76:\n  let f a x = List.map (sum)(a,x) in;;\n                                    ^^\nError: Syntax error\n"}],"event":{"region":{"start":2447,"stop":2521},"type":"eval"},"cursor":2447,"time":1.398985648623962e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (sum)(a,x) in\n    let base = List.hd (L1) in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = List.map (fun x->x+a)(x) in\nlet base = List.hd (L1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (fun x  -> x + a) x in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 100-102:\n  let base = List.hd (L1) in\n                      ^^\nError: This variant expression is expected to have type 'a list\n       The constructor L1 does not belong to type list\n"}],"event":{"region":{"start":2445,"stop":2657},"type":"eval"},"cursor":2445,"time":1.398985712686054e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd (L1) in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = List.map (fun x->x+a)(x) in\nlet base = List.hd l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (fun x  -> x + a) x in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 152-153:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int list -> int list\n       but an expression was expected of type int -> int list -> int\n       Type int list is not compatible with type int \n"}],"event":{"region":{"start":2446,"stop":2656},"type":"eval"},"cursor":2446,"time":1.39898572399228e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = h^ a ^ x in\n      let base = h^sep in\n      let l = sl in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^ sep ^ a in\nlet base = h in\nlet l = List.rev t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ (sep ^ a) in\n      let base = h in let l = List.rev t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1245},"type":"eval"},"cursor":1091,"time":1.398986436583678e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^ sep ^ a in\n      let base = h in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ (sep ^ a) in\n      let base = h in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ (sep ^ a) in\n      let base = h in let l = List.rev t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""}],"event":{"region":{"start":1249,"stop":1318},"type":"eval"},"cursor":1249,"time":1.398986440847367e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^ sep ^ a in\n      let base = h in\n      let l = List.rev t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = x^ sep ^ a in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ (sep ^ a) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""}],"event":{"region":{"start":1092,"stop":1236},"type":"eval"},"cursor":1092,"time":1.39898645520226e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^ sep ^ a in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = x ^ (sep ^ a) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""}],"event":{"region":{"start":1238,"stop":1282},"type":"eval"},"cursor":1238,"time":1.398986457726326e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = x^ sep ^ a in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""}],"event":{"region":{"start":1091,"stop":1384},"type":"eval"},"cursor":1091,"time":1.398986475138902e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""}],"event":{"region":{"start":1240,"stop":1384},"type":"eval"},"cursor":1384,"time":1.398986484292308e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a+x*x in\nlet base = 0\nin\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = List.map x a in\nlet base = [] in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"type","out":"Characters 8-12:\n  let _ = pipe [] 3;;\n          ^^^^\nError: This function has type ('a -> 'a) list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 8-12:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n          ^^^^\nError: This function has type ('a -> 'a) list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"type","out":"Characters 8-12:\n  let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3;;\n          ^^^^\nError: This function has type ('a -> 'a) list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":1309},"type":"eval"},"cursor":1289,"time":1.398986487656203e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""}],"event":{"region":{"start":1240,"stop":1309},"type":"eval"},"cursor":1240,"time":1.398986491054707e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""}],"event":{"region":{"start":1310,"stop":1352},"type":"eval"},"cursor":1310,"time":1.398986495255858e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""}],"event":{"region":{"start":1283,"stop":1309},"type":"eval"},"cursor":1283,"time":1.398986497952141e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""}],"event":{"region":{"start":1353,"stop":1384},"type":"eval"},"cursor":1353,"time":1.398986500726048e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = List.map (fun x->x+a)(x) in\n    let base = List.hd l1 in\n    let args = l2 in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"scope","out":"Characters 8-14:\n  let _ = bigAdd [9;9] [1;0;0;2];;\n          ^^^^^^\nError: Unbound value bigAdd\n"}],"event":{"region":{"start":2755,"stop":2789},"type":"eval"},"cursor":2755,"time":1.398987604357668e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = \n      let(w,res)=a in \n      let (y,z)=x in \n      let total = y+z+w in\n        (total/10, (total mod 10)::res) in\n    let base = (0,[]) in\n    let args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet(w,res)=a in \nlet (y,z)=x in \nlet total = y+z+w in\n(total/10, (total mod 10)::res) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"scope","out":"Characters 277-287:\n  removeZero (add (padZero l1 l2));;\n  ^^^^^^^^^^\nError: Unbound value removeZero\n"}],"event":{"region":{"start":2444,"stop":2753},"type":"eval"},"cursor":2753,"time":1.398987611926552e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = \n      let(w,res)=a in \n      let (y,z)=x in \n      let total = y+z+w in\n        (total/10, (total mod 10)::res) in\n    let base = (0,[]) in\n    let args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec removeZero l = match l  with\n| []-> []\n|  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)","min":"\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let _ = removeZero(add(padZero [1;1;1;1] [2;2]))","min":"\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet _ = removeZero (add (padZero [1; 1; 1; 1] [2; 2]));;\n","type":"scope","out":"Characters 19-22:\n  let _ = removeZero(add(padZero [1;1;1;1] [2;2]));;\n                     ^^^\nError: Unbound value add\n"}],"event":{"region":{"start":2190,"stop":2440},"type":"eval"},"cursor":2440,"time":1.398987627654693e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = \n      let(w,res)=a in \n      let (y,z)=x in \n      let total = y+z+w in\n        (total/10, (total mod 10)::res) in\n    let base = (0,[]) in\n    let args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let padZero l1 l2 = \nlet l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\nlet l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n(l1,l2)","min":"\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""}],"event":{"region":{"start":1949,"stop":2187},"type":"eval"},"cursor":2187,"time":1.398987633236795e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = \n      let(w,res)=a in \n      let (y,z)=x in \n      let total = y+z+w in\n        (total/10, (total mod 10)::res) in\n    let base = (0,[]) in\n    let args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let add (l1, l2) = \nlet f a x = \nlet(w,res)=a in \nlet (y,z)=x in \nlet total = y+z+w in\n(total/10, (total mod 10)::res) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet _ =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"scope","out":"Characters 282-284:\n  removeZero (add (padZero l1 l2));;\n                           ^^\nError: Unbound value l1\n"}],"event":{"region":{"start":2464,"stop":2753},"type":"eval"},"cursor":2753,"time":1.398987639588197e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = \n      let(w,res)=a in \n      let (y,z)=x in \n      let total = y+z+w in\n        (total/10, (total mod 10)::res) in\n    let base = (0,[]) in\n    let args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet(w,res)=a in \nlet (y,z)=x in \nlet total = y+z+w in\n(total/10, (total mod 10)::res) in\nlet base = (0,[]) in\nlet args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2444,"stop":2754},"type":"eval"},"cursor":2754,"time":1.398987646988319e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = \n      let(w,res)=a in \n      let (y,z)=x in \n      let total = y+z+w in\n        (total/10, (total mod 10)::res) in\n    let base = (0,[]) in\n    let args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2757,"stop":2825},"type":"eval"},"cursor":2825,"time":1.398987650015018e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = \n      let(w,res)=a in \n      let (y,z)=x in \n      let total = y+z+w in\n        (total/10, (total mod 10)::res) in\n    let base = (0,[]) in\n    let args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"region":{"start":2790,"stop":2825},"type":"eval"},"cursor":2790,"time":1.398987663409802e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = \n      let(w,res)=a in \n      let (y,z)=x in \n      let total = y+z+w in\n        (total/10, (total mod 10)::res) in\n    let base = (0,[]) in\n    let args = List.combine(List.rev(0::l1))(List.rev(0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = let add (l1, l2) = let f a x = let (w, res) = a in let (y, z) = x in let total = y + z + w in (total / 10, (total mod 10) :: res) in let base = (0, []) in let args = List.combine (List.rev(0 :: l1)) (List.rev(0 :: l2)) in let (_, res) = List.fold_left f base args in res in removeZero (add (padZero l1 l2))","min":"\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"region":{"start":2444,"stop":2770},"type":"eval"},"cursor":2444,"time":1.398987784760041e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = let add (l1, l2) = let f a x = let (w, res) = a in let (y, z) = x in let total = y + z + w in (total / 10, (total mod 10) :: res) in let base = (0, []) in let args = List.combine (List.rev(0 :: l1)) (List.rev(0 :: l2)) in let (_, res) = List.fold_left f base args in res in removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet padZero l1 l2 =\n  let l1 = if (List.length l1) < (List.length l2) then [0; 0] @ l1 else l1 in\n  let l2 = if (List.length l2) < (List.length l1) then [0; 0] @ l2 else l2 in\n  (l1, l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else [h] @ (removeZero t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (w,res) = a in\n      let (y,z) = x in\n      let total = (y + z) + w in ((total / 10), ((total mod 10) :: res)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""}],"event":{"region":{"start":2772,"stop":2804},"type":"eval"},"cursor":2772,"time":1.398987787737145e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a+x*x in\n  let base = 0\n  in\n    List.fold_left f base xs;;\n\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\n\nlet pipe fs = \n  let f a x = List.map x a in\n  let base = [] in\n    List.fold_left f base fs\n\n\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = a^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\n\n\nlet stringOfList f l =  \"List.map f l\"\n\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = \n  if n>0 then [x]@(clone x (n-1))\n  else [];;\n\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\n\nlet padZero l1 l2 = \n  let l1 = if (List.length l1)<(List.length l2) then [0;0]@l1 else l1 in\n  let l2 = if (List.length l2)<(List.length l1) then [0;0]@l2 else l2 in\n    (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\n\n\nlet rec removeZero l = match l  with\n  | []-> []\n  |  h::t -> if h=0 then (removeZero t) else [h]@(removeZero  t)\n\n\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\nlet _ = removeZero(add(padZero [1;1;1;1] [2;2]))\n\n\n\nlet bigAdd l1 l2 = let add (l1, l2) = let f a x = let (w, res) = a in let (y, z) = x in let total = y + z + w in (total / 10, (total mod 10) :: res) in let base = (0, []) in let args = List.combine (List.rev(0 :: l1)) (List.rev(0 :: l2)) in let (_, res) = List.fold_left f base args in res in removeZero (add (padZero l1 l2))\n\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n","file":"hw3.ml"}
