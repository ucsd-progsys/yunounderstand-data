{"ocaml":[],"event":{"region":{"start":402,"stop":608},"type":"eval"},"cursor":612,"time":1.397094695277922e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nsumList [];;\nsumList [1;2;3;4];;\nsumList [1;-2;3;5];;\nsumList [1; 3; 5; 7; 9; 11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\n\ndigitsOfInt 3124;;\ndigitsOfInt 352663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digital (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else 1 + additivePersistance (sumList(digitsOfInt xs))\n;;\n\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":402,"stop":498},"type":"eval"},"cursor":472,"time":1.397094705219974e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nsumList [];;\nsumList [1;2;3;4];;\nsumList [1;-2;3;5];;\nsumList [1; 3; 5; 7; 9; 11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\n\ndigitsOfInt 3124;;\ndigitsOfInt 352663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoots (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else 1 + additivePersistance (sumList(digitsOfInt xs))\n;;\n\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":402,"stop":497},"type":"eval"},"cursor":471,"time":1.397094709501466e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nsumList [];;\nsumList [1;2;3;4];;\nsumList [1;-2;3;5];;\nsumList [1; 3; 5; 7; 9; 11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\n\ndigitsOfInt 3124;;\ndigitsOfInt 352663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else 1 + additivePersistance (sumList(digitsOfInt xs))\n;;\n\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":497,"stop":612},"type":"eval"},"cursor":617,"time":1.397094718775119e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nsumList [];;\nsumList [1;2;3;4];;\nsumList [1;-2;3;5];;\nsumList [1; 3; 5; 7; 9; 11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\n\ndigitsOfInt 3124;;\ndigitsOfInt 352663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else 1 + additivePersistance (sumList(digitsOfInt xs))\n;;\n\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":612,"stop":661},"type":"eval"},"cursor":663,"time":1.39709474320509e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nsumList [];;\nsumList [1;2;3;4];;\nsumList [1;-2;3;5];;\nsumList [1; 3; 5; 7; 9; 11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\n\ndigitsOfInt 3124;;\ndigitsOfInt 352663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else 1 + additivePersistance (sumList(digitsOfInt xs))\n;;\n\nadditivePersistance 9876;;\nadditiveRoot 9876;;\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":641,"stop":660},"type":"eval"},"cursor":651,"time":1.397094759864657e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nsumList [];;\nsumList [1;2;3;4];;\nsumList [1;-2;3;5];;\nsumList [1; 3; 5; 7; 9; 11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\n\ndigitsOfInt 3124;;\ndigitsOfInt 352663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else 1 + additivePersistance (sumList(digitsOfInt xs))\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":644,"stop":660},"type":"eval"},"cursor":651,"time":1.397094764297409e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nsumList [];;\nsumList [1;2;3;4];;\nsumList [1;-2;3;5];;\nsumList [1; 3; 5; 7; 9; 11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\n\ndigitsOfInt 3124;;\ndigitsOfInt 352663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else 1 + additivePersistance (sumList(digitsOfInt xs))\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":497,"stop":660},"type":"eval"},"cursor":662,"time":1.397095021956948e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nsumList [];;\nsumList [1;2;3;4];;\nsumList [1;-2;3;5];;\nsumList [1; 3; 5; 7; 9; 11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\n\ndigitsOfInt 3124;;\ndigitsOfInt 352663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":660,"stop":710},"type":"eval"},"cursor":710,"time":1.397095197806275e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nsumList [];;\nsumList [1;2;3;4];;\nsumList [1;-2;3;5];;\nsumList [1; 3; 5; 7; 9; 11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\n\ndigitsOfInt 3124;;\ndigitsOfInt 352663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":75,"stop":165},"type":"eval"},"cursor":165,"time":1.397095387505846e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4]\nlet _ = sumList [1;-2;3;5]\nlet _ = sumList [1;3;4;5;7;9;11]\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\n\ndigitsOfInt 3124;;\ndigitsOfInt 352663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":165,"stop":416},"type":"eval"},"cursor":416,"time":1.397095451276585e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4]\nlet _ = sumList [1;-2;3;5]\nlet _ = sumList [1;3;4;5;7;9;11]\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 252663\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":105,"stop":732},"type":"eval"},"cursor":734,"time":1.397095542230652e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":813},"type":"eval"},"cursor":817,"time":1.397095886408912e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append xs' x\n;;\n\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":813,"stop":839},"type":"eval"},"cursor":839,"time":1.397095897214019e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append xs' x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":827},"type":"eval"},"cursor":825,"time":1.397095964157421e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":827,"stop":853},"type":"eval"},"cursor":853,"time":1.397095966579877e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":853},"type":"eval"},"cursor":854,"time":1.397096169852859e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | a      -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":825},"type":"eval"},"cursor":784,"time":1.397096189488257e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | a      -> a\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":825,"stop":851},"type":"eval"},"cursor":854,"time":1.397096193973831e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | a      -> a\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":830,"stop":851},"type":"eval"},"cursor":854,"time":1.397096195951835e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | a      -> a\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":854},"type":"eval"},"cursor":856,"time":1.39709626092746e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []       -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":827},"type":"eval"},"cursor":782,"time":1.397096291270808e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":827,"stop":853},"type":"eval"},"cursor":855,"time":1.397096297056781e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[{"in":"let listReverse xs = match xs with\n| [a]      -> [a]\n| x::xs'  -> append (listReverse xs') x","min":"\nlet listReverse xs =\n  match xs with | a::[] -> [a] | x::xs' -> append (listReverse xs') x;;\n","type":"scope","out":"Characters 66-72:\n  | x::xs'  -> append (listReverse xs') x;;\n               ^^^^^^\nError: Unbound value append\n"}],"event":{"region":{"start":732,"stop":829},"type":"eval"},"cursor":776,"time":1.397096309555832e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | [a]      -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":829,"stop":855},"type":"eval"},"cursor":856,"time":1.397096319924915e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | [a]      -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":844},"type":"eval"},"cursor":798,"time":1.397096336185614e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":844,"stop":870},"type":"eval"},"cursor":871,"time":1.397096338736082e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4]\n\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[{"in":"listReverse [1;2;3;4]","min":"\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"scope","out":"Characters 0-11:\n  listReverse [1;2;3;4];;\n  ^^^^^^^^^^^\nError: Unbound value listReverse\n"},{"in":"listReverse []","min":"\nlet _ = listReverse [];;\n","type":"scope","out":"Characters 0-11:\n  listReverse [];;\n  ^^^^^^^^^^^\nError: Unbound value listReverse\n"}],"event":{"region":{"start":844,"stop":887},"type":"eval"},"cursor":889,"time":1.397096392588243e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":887,"stop":905},"type":"eval"},"cursor":907,"time":1.39709640345811e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":905,"stop":925},"type":"eval"},"cursor":927,"time":1.397096413147182e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1 2];;\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":887,"stop":905},"type":"eval"},"cursor":904,"time":1.39709641942594e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1 2];;\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":905,"stop":925},"type":"eval"},"cursor":928,"time":1.397096420638262e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1 2];;\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":905,"stop":926},"type":"eval"},"cursor":923,"time":1.397096426168513e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\n\n\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":926,"stop":1031},"type":"eval"},"cursor":1036,"time":1.397096686491889e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\nlet aux_palindrome xs xs' =\n;;\n\nlet palindrome xs =\n  let xs' = listReverse xs in\n    aux_palindrome xs xs'\n;;\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":926,"stop":960},"type":"eval"},"cursor":960,"time":1.397096696860988e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\nlet aux_palindrome xs xs' =\n  xs\n;;\n\nlet palindrome xs =\n  let xs' = listReverse xs in\n    aux_palindrome xs xs'\n;;\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":930,"stop":960},"type":"eval"},"cursor":960,"time":1.397096698809107e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\nlet aux_palindrome xs xs' =\n  xs\n;;\n\nlet palindrome xs =\n  let xs' = listReverse xs in\n    aux_palindrome xs xs'\n;;\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":926,"stop":1092},"type":"eval"},"cursor":1095,"time":1.397097229175623e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\nlet aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_aplindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  let xs' = listReverse xs in\n    aux_palindrome xs xs'\n;;\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":926,"stop":1092},"type":"eval"},"cursor":1077,"time":1.397097240152992e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\nlet aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  let xs' = listReverse xs in\n    aux_palindrome xs xs'\n;;\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":926,"stop":1096},"type":"eval"},"cursor":938,"time":1.397097303719859e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  let xs' = listReverse xs in\n    aux_palindrome xs xs'\n;;\n\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1096,"stop":1198},"type":"eval"},"cursor":1200,"time":1.397097361491126e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  let xs' = listReverse xs in\n    aux_palindrome xs xs'\n;;\n\n\npalindrome racecar;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1174,"stop":1200},"type":"eval"},"cursor":1192,"time":1.397097369513331e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  let xs' = listReverse xs in\n    aux_palindrome xs xs'\n;;\n\n\npalindrome \"racecar\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1206,"stop":1225},"type":"eval"},"cursor":1206,"time":1.397097558605792e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  let xs' = listReverse xs in\n    aux_palindrome xs xs'\n;;\n\n\npalindrome \"racecar\";;\n\n\n\nexplode \"racecar\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":926,"stop":1026},"type":"eval"},"cursor":1029,"time":1.397097688142501e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  let xs' = listReverse xs in\n    aux_palindrome xs xs'\n;;\n\n\npalindrome \"racecar\";;\n\n\n\nexplode \"racecar\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1026,"stop":1299},"type":"eval"},"cursor":1301,"time":1.397097703837442e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  let xs' = listReverse xs in\n    aux_palindrome xs xs'\n;;\n\n\n\nexplode \"racecar\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1204,"stop":1285},"type":"eval"},"cursor":1288,"time":1.397097732472239e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  let xs' = listReverse (explode xs) in\n    aux_palindrome xs xs'\n;;\n\n\n\nexplode \"racecar\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1204,"stop":1280},"type":"eval"},"cursor":1225,"time":1.397097793656218e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\n\n\nexplode \"racecar\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1280,"stop":1306},"type":"eval"},"cursor":1308,"time":1.397097806891144e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\n\npalindrome \"racecar\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1026,"stop":1048},"type":"eval"},"cursor":1050,"time":1.397097852879373e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\n\npalindrome \"racecar\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1048,"stop":1336},"type":"eval"},"cursor":1338,"time":1.397097949563299e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_plaindrome [1;2;3] [1;2;3];;\npalindrome \"racecar\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1301,"stop":1336},"type":"eval"},"cursor":1306,"time":1.397097965297817e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\n\npalindrome \"racecar\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1336,"stop":1391},"type":"eval"},"cursor":1393,"time":1.397098007160282e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":908,"stop":926},"type":"eval"},"cursor":928,"time":1.397098043651777e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":926,"stop":976},"type":"eval"},"cursor":978,"time":1.397098075187788e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e'; 'c'; 'a'; 'r'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":926,"stop":961},"type":"eval"},"cursor":960,"time":1.397098089943424e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":926,"stop":965},"type":"eval"},"cursor":967,"time":1.397098137340404e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e','c'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":926,"stop":965},"type":"eval"},"cursor":961,"time":1.397098143602886e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":926,"stop":969},"type":"eval"},"cursor":968,"time":1.397098155772435e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":844},"type":"eval"},"cursor":792,"time":1.397098175789837e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [_]     -> [_]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":846},"type":"eval"},"cursor":805,"time":1.397098185061931e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | ['a]     -> ['a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":827},"type":"eval"},"cursor":788,"time":1.397098380680514e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":827,"stop":952},"type":"eval"},"cursor":914,"time":1.397098387991033e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":952,"stop":1417},"type":"eval"},"cursor":1420,"time":1.397098399008093e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":909,"stop":956},"type":"eval"},"cursor":955,"time":1.397098428684605e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":912,"stop":956},"type":"eval"},"cursor":958,"time":1.397098430988334e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":960,"stop":974},"type":"eval"},"cursor":960,"time":1.397098630618779e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nx::y = ['r'];;\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":960,"stop":978},"type":"eval"},"cursor":978,"time":1.39709863894253e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet x::y = ['r'];;\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":832,"stop":853},"type":"eval"},"cursor":832,"time":1.397098930115248e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet x::y = ['r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":853,"stop":870},"type":"eval"},"cursor":856,"time":1.397098931778914e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet x::y = ['r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":870,"stop":888},"type":"eval"},"cursor":873,"time":1.397098933119611e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet x::y = ['r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":888,"stop":909},"type":"eval"},"cursor":891,"time":1.397098934746353e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet x::y = ['r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":909,"stop":956},"type":"eval"},"cursor":912,"time":1.397098937161663e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet x::y = ['r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":827,"stop":859},"type":"eval"},"cursor":858,"time":1.397098958227429e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet x::y = ['r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":967,"stop":984},"type":"eval"},"cursor":967,"time":1.397099113404455e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet x::y = ['r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":966,"stop":984},"type":"eval"},"cursor":966,"time":1.397099115516649e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet x::y = ['r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":966,"stop":992},"type":"eval"},"cursor":966,"time":1.39709917445575e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet x::y = ['r';'a';'c'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\naux_palindrome [1;2;3] [1;2;3];;\n\nexplode \"racecar\";;\nlistReverse (explode \"racecar\");;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":832,"stop":862},"type":"eval"},"cursor":862,"time":1.397099247847513e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":831,"stop":863},"type":"eval"},"cursor":831,"time":1.397099265150294e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":827,"stop":861},"type":"eval"},"cursor":863,"time":1.397099277613099e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":736,"stop":830},"type":"eval"},"cursor":736,"time":1.39709928320168e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":832,"stop":861},"type":"eval"},"cursor":863,"time":1.397099288340889e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":844},"type":"eval"},"cursor":804,"time":1.397099332699856e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":844,"stop":878},"type":"eval"},"cursor":867,"time":1.397099335887205e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":844,"stop":876},"type":"eval"},"cursor":875,"time":1.397099343046232e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [a]     -> [a]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":844},"type":"eval"},"cursor":803,"time":1.397099353799832e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [_]     -> [_]\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":843},"type":"eval"},"cursor":802,"time":1.397099376345601e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [_]     -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":843,"stop":875},"type":"eval"},"cursor":864,"time":1.397099379358652e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [_]     -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":843,"stop":877},"type":"eval"},"cursor":876,"time":1.39709939140869e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [_]     -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":861},"type":"eval"},"cursor":863,"time":1.397099404544049e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | [_]     -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":861,"stop":964},"type":"eval"},"cursor":954,"time":1.397099414475044e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | [_]     -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":861,"stop":964},"type":"eval"},"cursor":954,"time":1.397099418989159e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | [_]     -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":842},"type":"eval"},"cursor":786,"time":1.397099428333278e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []     -> []\n  | [_]     -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":842,"stop":979},"type":"eval"},"cursor":951,"time":1.397099431695563e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []     -> []\n  | [_]     -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":843},"type":"eval"},"cursor":814,"time":1.397099458413584e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [_]     -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":843,"stop":980},"type":"eval"},"cursor":948,"time":1.397099461759118e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | [_]     -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":847},"type":"eval"},"cursor":807,"time":1.397099499021679e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  (*XXXXXXXXXXXXXXX*)\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":847,"stop":881},"type":"eval"},"cursor":883,"time":1.397099501712057e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  (*XXXXXXXXXXXXXXX*)\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7;8];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":847,"stop":879},"type":"eval"},"cursor":878,"time":1.397099508119276e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  (*XXXXXXXXXXXXXXX*)\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":879,"stop":982},"type":"eval"},"cursor":964,"time":1.397099514610561e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  (*XXXXXXXXXXXXXXX*)\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":732,"stop":859},"type":"eval"},"cursor":849,"time":1.39709952553244e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":859,"stop":876},"type":"eval"},"cursor":878,"time":1.397099528355691e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":876,"stop":894},"type":"eval"},"cursor":896,"time":1.397099529415798e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":894,"stop":915},"type":"eval"},"cursor":914,"time":1.397099530708179e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":915,"stop":962},"type":"eval"},"cursor":935,"time":1.39709953169902e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":962,"stop":1361},"type":"eval"},"cursor":1363,"time":1.397099549058052e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\npalindrome \"racecar\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":1361,"stop":1413},"type":"eval"},"cursor":1416,"time":1.397099597741893e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\npalindrome \"racecar\";;\npalindrome \"malayalam\";;\npalindrome \"myxomatosis\";;\n","file":"hw1.ml"}
{"ocaml":[],"event":{"region":{"start":0,"stop":389},"type":"eval"},"cursor":391,"time":1.397101467531833e9,"body":"let rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\nlet _ = sumList [1;2;3;4];;\nlet _ = sumList [1;-2;3;5];;\nlet _ = sumList [1;3;4;5;7;9;11];;\n\n\n\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt xs = \n  if xs <= 0\n  then []\n  else append (digitsOfInt (xs / 10)) (xs mod 10)\n;;\n\ndigitsOfInt (-124);;\nlet _ = digitsOfInt 3124;;\nlet _ = digitsOfInt 252663;;\n\n\nlet rec digitalRoot xs =\n  if xs / 10 = 0\n  then xs\n  else digitalRoot (sumList(digitsOfInt xs))\n;;\n\nlet rec additivePersistance xs = \n  if xs / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt xs)) + 1\n;;\n\nadditivePersistance 9876;;\ndigitalRoot 9876;;\n\nadditivePersistance 555555;;\ndigitalRoot 55555;;\n\n\nlet listReverse xs = match xs with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlistReverse [1;2;3;4;5;6;7];;\nlistReverse [];;\nlistReverse [1];;\nlistReverse [1; 2];;\nlistReverse ['r'; 'a'; 'c'; 'e';'c';'a';'r'];;\n\nlet explode s =\n  let rec go i =\n    if i >= String.length s\n    then []\n    else (s.[i]::(go (i+1)))\n  in\n    go 0\n;;\n\nexplode \"racecar\";;\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\n\n;;\n\nlet palindrome xs =\n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\npalindrome \"racecar\";;\npalindrome \"malayalam\";;\npalindrome \"myxomatosis\";;\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []    -> 0\n| x::xs' -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":259},"type":"eval"},"cursor":261,"time":1.397101939491412e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec append head tail = match head with\n| []      -> [tail]\n| h::t    -> h::(append t tail)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif n <= 0\nthen []\nelse append (digitsOfInt (n / 10)) (n mod 10)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-100)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt (-100);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"region":{"start":259,"stop":727},"type":"eval"},"cursor":728,"time":1.39710198202293e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nif n / 10 = 0\nthen 0\nelse additivePersistance (sumList(digitsOfInt n)) + 1","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistance (sumList (digitsOfInt n))) + 1;;\n","type":"scope","out":"Characters 59-78:\n  else additivePersistance (sumList(digitsOfInt n)) + 1;;\n       ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistance\n"},{"in":"let _ = additivePersistence 9876","min":"\nlet _ = additivePersistence 9876;;\n","type":"scope","out":"Characters 8-27:\n  let _ = additivePersistence 9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n"}],"event":{"region":{"start":727,"stop":1755},"type":"eval"},"cursor":1755,"time":1.397102002049961e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistance (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nif n / 10 = 0\nthen 0\nelse additivePersistence (sumList(digitsOfInt n)) + 1","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"region":{"start":953,"stop":1755},"type":"eval"},"cursor":1723,"time":1.397102016684823e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitalRoot n = \nif n / 10 = 0\nthen n\nelse digitalRoot (sumList(digitsOfInt n))","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":1755,"stop":1947},"type":"eval"},"cursor":1947,"time":1.397102025146676e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec listReverse l = match l with\n| []      -> []\n| x::xs'  -> append (listReverse xs') x","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""}],"event":{"region":{"start":1947,"stop":2120},"type":"eval"},"cursor":2120,"time":1.397102033023805e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let rec aux_palindrome xs xs' = match xs, xs' with\n| [],[]     -> true\n| [],_      -> false\n| _, []     -> false\n| h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2","min":"\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n","type":"","out":""},{"in":"let palindrome w = \naux_palindrome (explode xs) (listReverse (explode xs))","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode xs) (listReverse (explode xs));;\n","type":"scope","out":"Characters 44-46:\n  aux_palindrome (explode xs) (listReverse (explode xs));;\n                          ^^\nError: Unbound value xs\n"},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet _ = palindrome \"malayalam\";;\n","type":"scope","out":"Characters 8-18:\n  let _ = palindrome \"malayalam\";;\n          ^^^^^^^^^^\nError: Unbound value palindrome\n"},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet _ = palindrome \"myxomatosis\";;\n","type":"scope","out":"Characters 8-18:\n  let _ = palindrome \"myxomatosis\";;\n          ^^^^^^^^^^\nError: Unbound value palindrome\n"}],"event":{"region":{"start":2120,"stop":2728},"type":"eval"},"cursor":2728,"time":1.397102041951226e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode xs) (listReverse (explode xs))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w = \naux_palindrome (explode w) (listReverse (explode w))","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""}],"event":{"region":{"start":2576,"stop":2726},"type":"eval"},"cursor":2727,"time":1.397102058677899e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"\";;\n","type":"","out":""}],"event":{"region":{"start":2693,"stop":2748},"type":"eval"},"cursor":2749,"time":1.397102086247811e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":2694,"stop":5765},"type":"eval"},"cursor":2726,"time":1.397102193324129e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []    -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]     -> true\n  | [],_      -> false\n  | _, []     -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec append head tail = match head with\n| []      -> [tail]\n| h::t    -> h::(append t tail)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif n <= 0\nthen []\nelse append (digitsOfInt (n / 10)) (n mod 10)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-100)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt (-100);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nif n / 10 = 0\nthen 0\nelse additivePersistence (sumList(digitsOfInt n)) + 1","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif n / 10 = 0\nthen n\nelse digitalRoot (sumList(digitsOfInt n))","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = match l with\n| []      -> []\n| x::xs'  -> append (listReverse xs') x","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let rec aux_palindrome xs xs' = match xs, xs' with\n| [],[]            -> true\n| [],_             -> false\n| _, []            -> false\n| h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2","min":"\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n","type":"","out":""},{"in":"let palindrome w = \naux_palindrome (explode w) (listReverse (explode w))","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":5787},"type":"eval"},"cursor":2785,"time":1.397102319696645e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [-1;-1]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [(-1); (-1)];;\n","type":"","out":""},{"in":"let _ = sumList []","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [];;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":303},"type":"eval"},"cursor":304,"time":1.397185415847476e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 3; 5; 7; 9];;\n","type":"","out":""}],"event":{"region":{"start":237,"stop":298},"type":"eval"},"cursor":298,"time":1.397185437872219e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [-1; -2; -3; -4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4; 5];;\n","type":"","out":""}],"event":{"region":{"start":208,"stop":302},"type":"eval"},"cursor":303,"time":1.397185466987718e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [-1;-1]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [(-1); (-1)];;\n","type":"","out":""},{"in":"let _ = sumList []","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [];;\n","type":"","out":""},{"in":"let _ = sumList [-1; -2; -3; -4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4; 5];;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":302},"type":"eval"},"cursor":302,"time":1.397185474920659e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec append head tail = match head with\n| []      -> [tail]\n| h::t    -> h::(append t tail)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif n <= 0\nthen []\nelse append (digitsOfInt (n / 10)) (n mod 10)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-100)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt (-100);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 35266","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt 35266;;\n","type":"","out":""}],"event":{"region":{"start":302,"stop":770},"type":"eval"},"cursor":770,"time":1.397185497950068e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec append head tail = match head with\n| []      -> [tail]\n| h::t    -> h::(append t tail)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif n <= 0\nthen []\nelse append (digitsOfInt (n / 10)) (n mod 10)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-100)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt (-100);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 35266","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt 35266;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nif n / 10 = 0\nthen 0\nelse additivePersistence (sumList(digitsOfInt n)) + 1","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif n / 10 = 0\nthen n\nelse digitalRoot (sumList(digitsOfInt n))","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"region":{"start":302,"stop":1989},"type":"eval"},"cursor":1990,"time":1.397185537484688e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\nlet _ = additivePersistence 9876\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitalRoot n = \nif n / 10 = 0\nthen n\nelse digitalRoot (sumList(digitsOfInt n))","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ additivePersistence 0","min":"","type":"syntax","out":"Characters 6-25:\n  let _ additivePersistence 0;;\n        ^^^^^^^^^^^^^^^^^^^\nError: Syntax error\n"},{"in":"let _ digitalRoot 0","min":"","type":"syntax","out":"Characters 6-17:\n  let _ digitalRoot 0;;\n        ^^^^^^^^^^^\nError: Syntax error\n"}],"event":{"region":{"start":1760,"stop":2039},"type":"eval"},"cursor":2039,"time":1.397185592546186e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ additivePersistence 0\nlet _ digitalRoot 0\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ additivePersistence 0","min":"","type":"syntax","out":"Characters 6-25:\n  let _ additivePersistence 0;;\n        ^^^^^^^^^^^^^^^^^^^\nError: Syntax error\n"}],"event":{"region":{"start":1990,"stop":2019},"type":"eval"},"cursor":2017,"time":1.397185604155246e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ additivePersistence 0\nlet _ digitalRoot 0\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ additivePersistence 10","min":"","type":"syntax","out":"Characters 6-25:\n  let _ additivePersistence 10;;\n        ^^^^^^^^^^^^^^^^^^^\nError: Syntax error\n"}],"event":{"region":{"start":1990,"stop":2020},"type":"eval"},"cursor":2019,"time":1.397185612762574e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ additivePersistence 10\nlet _ digitalRoot 0\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 0","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""}],"event":{"region":{"start":1990,"stop":2021},"type":"eval"},"cursor":2020,"time":1.397185624496211e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 0","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""}],"event":{"region":{"start":2021,"stop":2043},"type":"eval"},"cursor":2043,"time":1.397185627278275e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 0","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9999999999999","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n\nlet _ = additivePersistence 9999999999999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9999999999999","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 9999999999999;;\n","type":"","out":""}],"event":{"region":{"start":1990,"stop":2120},"type":"eval"},"cursor":2120,"time":1.397185845043936e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 9999999999999\nlet _ = digitalRoot 9999999999999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 99999","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n\nlet _ = additivePersistence 99999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 99999","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 99999;;\n","type":"","out":""}],"event":{"region":{"start":2043,"stop":2104},"type":"eval"},"cursor":2104,"time":1.397185862160582e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec listReverse l = match l with\n| []      -> []\n| x::xs'  -> append (listReverse xs') x","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n","type":"","out":""},{"in":"let _ = listReverse []","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4; 5]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""}],"event":{"region":{"start":2104,"stop":2384},"type":"eval"},"cursor":2384,"time":1.397185989908808e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse []\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [1; 2; 3; 4; 5]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [(a,b); (c,d)];\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"","type":"syntax","out":"Characters 142-144:\n  go 0;;\n      ^^\nError: Syntax error\n"}],"event":{"region":{"start":2384,"stop":2709},"type":"eval"},"cursor":2421,"time":1.397186025032092e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse []\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [1; 2; 3; 4; 5]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]\nlet _ = listReverse [(a,b); (c,d)];\n\n\n\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX*)\n  let explode s = \n    let rec go i = \n      if i >= String.length s \n      then [] \n      else (s.[i]) :: (go (i+1)) \n    in\n      go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [(a,b); (c,d)]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [(a, b); (c, d)];;\n","type":"scope","out":"Characters 22-23:\n  let _ = listReverse [(a,b); (c,d)];;\n                        ^\nError: Unbound value a\n"}],"event":{"region":{"start":2384,"stop":2419},"type":"eval"},"cursor":2420,"time":1.397186033459874e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse []\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [1; 2; 3; 4; 5]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]\nlet _ = listReverse [(a,b); (c,d)]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [(1,2); (3,4)]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [(1, 2); (3, 4)];;\n","type":"","out":""}],"event":{"region":{"start":2384,"stop":2419},"type":"eval"},"cursor":2417,"time":1.397186043431229e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse []\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [1; 2; 3; 4; 5]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]\nlet _ = listReverse [(1,2); (3,4)]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let rec aux_palindrome xs xs' = match xs, xs' with\n| [],[]            -> true\n| [],_             -> false\n| _, []            -> false\n| h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2","min":"\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n","type":"","out":""},{"in":"let palindrome w = \naux_palindrome (explode w) (listReverse (explode w))","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"\";;\n","type":"","out":""}],"event":{"region":{"start":2419,"stop":3069},"type":"eval"},"cursor":3071,"time":1.397186053174104e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse []\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [1; 2; 3; 4; 5]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]\nlet _ = listReverse [(1,2); (3,4)]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"12321\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"12321\";;\n","type":"","out":""},{"in":"let _ = palindrome \"12344321\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"12344321\";;\n","type":"","out":""}],"event":{"region":{"start":3069,"stop":3155},"type":"eval"},"cursor":3155,"time":1.39718608880453e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse []\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [1; 2; 3; 4; 5]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]\nlet _ = listReverse [(1,2); (3,4)]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"12321\"\nlet _ = palindrome \"12344321\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = palindrome \"cat\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"cat\";;\n","type":"","out":""}],"event":{"region":{"start":3155,"stop":3180},"type":"eval"},"cursor":3180,"time":1.397186126499935e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse []\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [1; 2; 3; 4; 5]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]\nlet _ = listReverse [(1,2); (3,4)]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"12321\"\nlet _ = palindrome \"12344321\"\nlet _ = palindrome \"cat\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = palindrome \"cat\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"cat\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":3156,"stop":6197},"type":"eval"},"cursor":3180,"time":1.39718613155165e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse []\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [1; 2; 3; 4; 5]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]\nlet _ = listReverse [(1,2); (3,4)]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"12321\"\nlet _ = palindrome \"12344321\"\nlet _ = palindrome \"cat\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = palindrome \"cat\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"cat\";;\n","type":"","out":""}],"event":{"region":{"start":3156,"stop":3180},"type":"eval"},"cursor":3180,"time":1.39718613654913e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse []\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [1; 2; 3; 4; 5]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]\nlet _ = listReverse [(1,2); (3,4)]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"12321\"\nlet _ = palindrome \"12344321\"\nlet _ = palindrome \"cat\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = palindrome \"cat\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"cat\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":3156,"stop":6197},"type":"eval"},"cursor":3180,"time":1.397186138395232e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse []\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [1; 2; 3; 4; 5]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]\nlet _ = listReverse [(1,2); (3,4)]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"12321\"\nlet _ = palindrome \"12344321\"\nlet _ = palindrome \"cat\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n","type":"","out":""},{"in":"let _ = sumList [-1;-1]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [(-1); (-1)];;\n","type":"","out":""},{"in":"let _ = sumList []","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [];;\n","type":"","out":""},{"in":"let _ = sumList [-1; -2; -3; -4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ = sumList [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let rec append head tail = match head with\n| []      -> [tail]\n| h::t    -> h::(append t tail)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif n <= 0\nthen []\nelse append (digitsOfInt (n / 10)) (n mod 10)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n","type":"","out":""},{"in":"let _ = digitsOfInt (-100)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt (-100);;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 35266","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet _ = digitsOfInt 35266;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nif n / 10 = 0\nthen 0\nelse additivePersistence (sumList(digitsOfInt n)) + 1","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nif n / 10 = 0\nthen n\nelse digitalRoot (sumList(digitsOfInt n))","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let _ = additivePersistence 0","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n\nlet _ = additivePersistence 0;;\n","type":"","out":""},{"in":"let _ = digitalRoot 0","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 0;;\n","type":"","out":""},{"in":"let _ = additivePersistence 99999","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0\n  then 0\n  else (additivePersistence (sumList (digitsOfInt n))) + 1;;\n\nlet _ = additivePersistence 99999;;\n","type":"","out":""},{"in":"let _ = digitalRoot 99999","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) (n mod 10);;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  if (n / 10) = 0 then n else digitalRoot (sumList (digitsOfInt n));;\n\nlet _ = digitalRoot 99999;;\n","type":"","out":""},{"in":"let rec listReverse l = match l with\n| []      -> []\n| x::xs'  -> append (listReverse xs') x","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n","type":"","out":""},{"in":"let _ = listReverse []","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4; 5]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = listReverse [(1,2); (3,4)]","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet _ = listReverse [(1, 2); (3, 4)];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let rec aux_palindrome xs xs' = match xs, xs' with\n| [],[]            -> true\n| [],_             -> false\n| _, []            -> false\n| h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2","min":"\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n","type":"","out":""},{"in":"let palindrome w = \naux_palindrome (explode w) (listReverse (explode w))","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"let _ = palindrome \"\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"\";;\n","type":"","out":""},{"in":"let _ = palindrome \"racecar\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"racecar\";;\n","type":"","out":""},{"in":"let _ = palindrome \"12321\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"12321\";;\n","type":"","out":""},{"in":"let _ = palindrome \"12344321\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"12344321\";;\n","type":"","out":""},{"in":"let _ = palindrome \"cat\"","min":"\nlet rec append head tail =\n  match head with | [] -> [tail] | h::t -> h :: (append t tail);;\n\nlet rec aux_palindrome xs xs' =\n  match (xs, xs') with\n  | ([],[]) -> true\n  | ([],_) -> false\n  | (_,[]) -> false\n  | (h1::t1,h2::t2) -> (h1 = h2) && (aux_palindrome t1 t2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | x::xs' -> append (listReverse xs') x;;\n\nlet palindrome w = aux_palindrome (explode w) (listReverse (explode w));;\n\nlet _ = palindrome \"cat\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"region":{"start":0,"stop":6197},"type":"eval"},"cursor":0,"time":1.397494673488008e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = match xs with\n  | []     -> 0\n  | x::xs' -> x + sumList xs'\n;;\n\n\nlet _ = sumList [-1;-1]\nlet _ = sumList []\nlet _ = sumList [-1; -2; -3; -4]\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; 2; 3; 4; 5]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec append head tail = match head with\n  | []      -> [tail]\n  | h::t    -> h::(append t tail)\n;;\n\nlet rec digitsOfInt n = \n  if n <= 0\n  then []\n  else append (digitsOfInt (n / 10)) (n mod 10)\n;;\n\n\nlet _ = digitsOfInt (-100)\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 35266\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = \n  if n / 10 = 0\n  then 0\n  else additivePersistence (sumList(digitsOfInt n)) + 1\n;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  if n / 10 = 0\n  then n\n  else digitalRoot (sumList(digitsOfInt n))\n;;\n\n\nlet _ = additivePersistence 9876\nlet _ = digitalRoot 9876\n\nlet _ = additivePersistence 0\nlet _ = digitalRoot 0\n\nlet _ = additivePersistence 99999\nlet _ = digitalRoot 99999\n\n\n\n\nlet rec listReverse l = match l with\n  | []      -> []\n  | x::xs'  -> append (listReverse xs') x\n;;\n\nlet _ = listReverse []\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [1; 2; 3; 4; 5]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"]\nlet _ = listReverse [(1,2); (3,4)]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec aux_palindrome xs xs' = match xs, xs' with\n  | [],[]            -> true\n  | [],_             -> false\n  | _, []            -> false\n  | h1::t1, h2::t2   -> h1 = h2 && aux_palindrome t1 t2\n;;\t \n\t \nlet palindrome w = \n  aux_palindrome (explode w) (listReverse (explode w))\n;;\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\nlet _ = palindrome \"\"\nlet _ = palindrome \"racecar\"\nlet _ = palindrome \"12321\"\nlet _ = palindrome \"12344321\"\nlet _ = palindrome \"cat\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
