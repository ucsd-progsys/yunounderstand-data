{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a * a + x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""}],"event":{"phrases":["let sqsum xs = \nlet f a x = a * a + x in\nlet base = 0 in\nList.fold_left f base xs","let _ = sqsum []","let _ = sqsum [1;2;3;4]","let _ = sqsum [(-1); (-2); (-3); (-4)]"],"region":{"start":0,"stop":877},"type":"eval"},"cursor":877,"time":1.445631640732883e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a * a + x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""}],"event":{"phrases":["let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs","let _ = sqsum []","let _ = sqsum [1;2;3;4]","let _ = sqsum [(-1); (-2); (-3); (-4)]"],"region":{"start":0,"stop":877},"type":"eval"},"cursor":877,"time":1.445631733139802e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n","type":"","out":""},{"in":"let stringOfList f l = failwith \"to be implemented\"","min":"\nlet stringOfList f l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec clone x n = failwith \"to be implemented\"","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let padZero l1 l2 = failwith \"to be implemented\"","min":"\nlet padZero l1 l2 = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec removeZero l = failwith \"to be implemented\"","min":"\nlet rec removeZero l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let rec mulByDigit i l = failwith \"to be implemented\"","min":"\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["let _ = sqsum [(-1); (-2); (-3); (-4)]","let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs","let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l","let stringOfList f l = failwith \"to be implemented\"","let rec clone x n = failwith \"to be implemented\"","let padZero l1 l2 = failwith \"to be implemented\"","let rec removeZero l = failwith \"to be implemented\"","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let rec mulByDigit i l = failwith \"to be implemented\"","let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \n\tmatch runWTimeout(f,arg,out,timeout) with \n\t    Pass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n\t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":839,"stop":7452},"type":"eval"},"cursor":877,"time":1.44563200296541e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n    List.fold_left f base fs\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n","type":"type","out":"Characters 65-66:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n","type":"","out":""},{"in":"let stringOfList f l = failwith \"to be implemented\"","min":"\nlet stringOfList f l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec clone x n = failwith \"to be implemented\"","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let padZero l1 l2 = failwith \"to be implemented\"","min":"\nlet padZero l1 l2 = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec removeZero l = failwith \"to be implemented\"","min":"\nlet rec removeZero l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let rec mulByDigit i l = failwith \"to be implemented\"","min":"\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs","let _ = pipe [] 3","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l","let stringOfList f l = failwith \"to be implemented\"","let rec clone x n = failwith \"to be implemented\"","let padZero l1 l2 = failwith \"to be implemented\"","let rec removeZero l = failwith \"to be implemented\"","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let rec mulByDigit i l = failwith \"to be implemented\"","let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \n\tmatch runWTimeout(f,arg,out,timeout) with \n\t    Pass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n\t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":877,"stop":7352},"type":"eval"},"cursor":1075,"time":1.44563270827973e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = f in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = a in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base = a in List.fold_left f base fs;;\n","type":"scope","out":"Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n","type":"","out":""},{"in":"let stringOfList f l = failwith \"to be implemented\"","min":"\nlet stringOfList f l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec clone x n = failwith \"to be implemented\"","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let padZero l1 l2 = failwith \"to be implemented\"","min":"\nlet padZero l1 l2 = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec removeZero l = failwith \"to be implemented\"","min":"\nlet rec removeZero l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let rec mulByDigit i l = failwith \"to be implemented\"","min":"\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = a in\nList.fold_left f base fs","let _ = pipe [] 3","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l","let stringOfList f l = failwith \"to be implemented\"","let rec clone x n = failwith \"to be implemented\"","let padZero l1 l2 = failwith \"to be implemented\"","let rec removeZero l = failwith \"to be implemented\"","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let rec mulByDigit i l = failwith \"to be implemented\"","let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \n\tmatch runWTimeout(f,arg,out,timeout) with \n\t    Pass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n\t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":877,"stop":7352},"type":"eval"},"cursor":973,"time":1.445632885498618e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = a in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = a in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base = a in List.fold_left f base fs;;\n","type":"scope","out":"Characters 45-46:\n  let base = a in\n             ^\nError: Unbound value a\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = a in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":973},"type":"eval"},"cursor":973,"time":1.445632888374446e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = a in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n","type":"type","out":"Characters 65-66:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = f in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":973},"type":"eval"},"cursor":973,"time":1.445632900174197e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = f in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n","type":"type","out":"Characters 65-66:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = 0 in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":973},"type":"eval"},"cursor":973,"time":1.445632911193853e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = 0 in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = let b x = x in\nList.fold_left f base fs","min":"","type":"syntax","out":"Characters 84-86:\n  List.fold_left f base fs;;\n                          ^^\nError: Syntax error\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = let b x = x in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":983},"type":"eval"},"cursor":983,"time":1.445632951999799e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = let b x = x in\n      List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = b x = x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = a x in let base = (b x) = x in List.fold_left f base fs;;\n","type":"scope","out":"Characters 45-46:\n  let base = b x = x in\n             ^\nError: Unbound value b\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = b x = x in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":979},"type":"eval"},"cursor":979,"time":1.445632973866949e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = b x = x in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = fun b x = x in\nList.fold_left f base fs","min":"","type":"syntax","out":"Characters 53-54:\n  let base = fun b x = x in\n                     ^\nError: Syntax error\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = fun b x = x in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":983},"type":"eval"},"cursor":983,"time":1.445632988710683e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = fun b x = x in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = fun b = x in\nList.fold_left f base fs","min":"","type":"syntax","out":"Characters 51-52:\n  let base = fun b = x in\n                   ^\nError: Syntax error\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = fun b = x in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":981},"type":"eval"},"cursor":981,"time":1.445633006272082e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = fun b = x in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = fun b -> x = x in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x = a x in let base b = x = x in List.fold_left f base fs;;\n","type":"scope","out":"Characters 54-55:\n  let base = fun b -> x = x in\n                      ^\nError: Unbound value x\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = fun b -> x = x in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":986},"type":"eval"},"cursor":986,"time":1.445633020158982e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = fun b -> x = x in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = fun b -> x in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = a x in let base b = x in List.fold_left f base fs;;\n","type":"scope","out":"Characters 54-55:\n  let base = fun b -> x in\n                      ^\nError: Unbound value x\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = fun b -> x in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":982},"type":"eval"},"cursor":982,"time":1.445633034589704e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = fun b -> x in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = a x in\nlet base = let b x = x in in\nList.fold_left f base fs","min":"","type":"syntax","out":"Characters 60-62:\n  let base = let b x = x in in\n                            ^^\nError: Syntax error\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = a x in\nlet base = let b x = x in in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":986},"type":"eval"},"cursor":986,"time":1.445633244255951e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = a x in\n  let base = let b x = x in in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":973},"type":"eval"},"cursor":973,"time":1.445633346239404e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = f in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base = fun i -> i in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = x a in\nlet base = fun i -> i in\nList.fold_left f base fs","let _ = pipe [] 3"],"region":{"start":877,"stop":982},"type":"eval"},"cursor":982,"time":1.445634814543052e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}],"event":{"phrases":["","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"],"region":{"start":982,"stop":1084},"type":"eval"},"cursor":1084,"time":1.445634850253613e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}],"event":{"phrases":["","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"],"region":{"start":982,"stop":1033},"type":"eval"},"cursor":1033,"time":1.445634857403432e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = (x a) in\nlet base = fun i -> i in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}],"event":{"phrases":["","let pipe fs = \nlet f a x = (x a) in\nlet base = fun i -> i in\nList.fold_left f base fs","let _ = pipe [] 3","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"],"region":{"start":877,"stop":1035},"type":"eval"},"cursor":1035,"time":1.445646396277105e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = (x a) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = (x a) in\nlet base = (fun i -> i) in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}],"event":{"phrases":["","let pipe fs = \nlet f a x = (x a) in\nlet base = (fun i -> i) in\nList.fold_left f base fs","let _ = pipe [] 3","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"],"region":{"start":877,"stop":1037},"type":"eval"},"cursor":1013,"time":1.445646550349227e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = (x a) in\n  let base = (fun i -> i) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = fun b -> fun x -> fun a -> x a b in\nlet base = (fun i -> i) in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x b x a = x a b in let base i = i in List.fold_left f base fs;;\n","type":"type","out":"Characters 107-111:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type\n         'a -> ('b -> 'a -> 'c) -> 'b -> 'c\n       The type variable 'a occurs inside ('b -> 'a -> 'c) -> 'b -> 'c\n"},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"type","out":"Characters 24-25:\n  let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3;;\n                          ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}],"event":{"phrases":["","let pipe fs = \nlet f a x = fun b -> fun x -> fun a -> x a b in\nlet base = (fun i -> i) in\nList.fold_left f base fs","let _ = pipe [] 3","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3"],"region":{"start":877,"stop":1064},"type":"eval"},"cursor":1034,"time":1.445646832806807e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> fun x -> fun a -> x a b in\n  let base = (fun i -> i) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = x a in\nlet base = (fun i -> i) in\nList.fold_left f base fs","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = x a in\nlet base = (fun i -> i) in\nList.fold_left f base fs"],"region":{"start":877,"stop":965},"type":"eval"},"cursor":965,"time":1.445646948456725e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = (fun i -> i) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [] 3","min":"\nlet pipe fs = let f a x = x a in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""}],"event":{"phrases":["","let _ = pipe [] 3"],"region":{"start":965,"stop":984},"type":"eval"},"cursor":984,"time":1.445646964468017e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = x a in\n  let base = (fun i -> i) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = fun b -> x (a b) in\nlet base = (fun i -> i) in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = fun b -> x (a b) in\nlet base = (fun i -> i) in\nList.fold_left f base fs"],"region":{"start":877,"stop":978},"type":"eval"},"cursor":978,"time":1.445647420418355e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = (fun i -> i) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""}],"event":{"phrases":["","let _ = pipe [] 3","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3"],"region":{"start":978,"stop":1099},"type":"eval"},"cursor":1099,"time":1.445647434497383e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = (fun i -> i) in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let pipe fs = \nlet f a x = fun b -> x (a b) in\nlet base = fun i -> i in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n","type":"","out":""},{"in":"let stringOfList f l = failwith \"to be implemented\"","min":"\nlet stringOfList f l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec clone x n = failwith \"to be implemented\"","min":"\nlet rec clone x n = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let padZero l1 l2 = failwith \"to be implemented\"","min":"\nlet padZero l1 l2 = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec removeZero l = failwith \"to be implemented\"","min":"\nlet rec removeZero l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let rec mulByDigit i l = failwith \"to be implemented\"","min":"\nlet rec mulByDigit i l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["","let pipe fs = \nlet f a x = fun b -> x (a b) in\nlet base = fun i -> i in\nList.fold_left f base fs","let _ = pipe [] 3","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l","let stringOfList f l = failwith \"to be implemented\"","let rec clone x n = failwith \"to be implemented\"","let padZero l1 l2 = failwith \"to be implemented\"","let rec removeZero l = failwith \"to be implemented\"","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let rec mulByDigit i l = failwith \"to be implemented\"","let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \n\tmatch runWTimeout(f,arg,out,timeout) with \n\t    Pass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n\t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":877,"stop":7374},"type":"eval"},"cursor":938,"time":1.445647711834965e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = failwith \"to be implemented\" \n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""}],"event":{"phrases":["","let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","let _ = clone 3 5","let _ = clone \"foo\" 2","let _ = clone clone (-3)"],"region":{"start":1564,"stop":2122},"type":"eval"},"cursor":2125,"time":1.445648131769284e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","let _ = padZero [9;9] [1;0;0;2]","let _ = padZero [1;0;0;2] [9;9]"],"region":{"start":2122,"stop":2365},"type":"eval"},"cursor":2367,"time":1.445648454913587e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec removeZero l = let h::l' = l in\nmatch h with\n| 0 -> removeZero l'\n| _ -> l","min":"\nlet rec removeZero l =\n  let h::l' = l in match h with | 0 -> removeZero l' | _ -> l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  let h::l' = l in match h with | 0 -> removeZero l' | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  let h::l' = l in match h with | 0 -> removeZero l' | _ -> l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  let h::l' = l in match h with | 0 -> removeZero l' | _ -> l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""}],"event":{"phrases":["","let rec removeZero l = let h::l' = l in\nmatch h with\n| 0 -> removeZero l'\n| _ -> l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]"],"region":{"start":2365,"stop":2540},"type":"eval"},"cursor":2540,"time":1.445648601378995e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = let h::l' = l in\n    match h with\n      | 0 -> removeZero l'\n      | _ -> l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""}],"event":{"phrases":["","let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]"],"region":{"start":2365,"stop":2550},"type":"eval"},"cursor":2550,"time":1.44564866289183e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  if sum > 9 then [1,sum-1] else [sum]\n| c::x' -> if sum + c > 9 then 1::(sum+c-10)::x' else (sum+c)::x'\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [(1, (sum - 1))] else [sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 148-151:\n  | [] ->  if sum > 9 then [1,sum-1] else [sum]\n                                           ^^^\nError: This expression has type int but an expression was expected of type\n         int * int\n"}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  if sum > 9 then [1,sum-1] else [sum]\n| c::x' -> if sum + c > 9 then 1::(sum+c-10)::x' else (sum+c)::x'\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"],"region":{"start":2550,"stop":2932},"type":"eval"},"cursor":2932,"time":1.445650173262883e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let sum = n1 + n2 in\n        match a with \n          | [] ->  if sum > 9 then [1,sum-1] else [sum]\n          | c::x' -> if sum + c > 9 then 1::(sum+c-10)::x' else (sum+c)::x'\n    in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  if sum > 9 then [1;sum-1] else [0;sum]\n| c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' else (sum+c)::x'\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [1; sum - 1] else [0; sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 313-339:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  if sum > 9 then [1;sum-1] else [0;sum]\n| c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' else (sum+c)::x'\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"],"region":{"start":2550,"stop":2936},"type":"eval"},"cursor":2740,"time":1.445650321839748e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let sum = n1 + n2 in\n        match a with \n          | [] ->  if sum > 9 then [1;sum-1] else [0;sum]\n          | c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' else (sum+c)::x'\n    in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  if sum > 9 then [1;sum-1] else [0;sum]\n| c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' else 0::(sum+c)::x'\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [1; sum - 1] else [0; sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else 0 :: (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 316-342:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  if sum > 9 then [1;sum-1] else [0;sum]\n| c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' else 0::(sum+c)::x'\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"],"region":{"start":2550,"stop":2939},"type":"eval"},"cursor":2939,"time":1.445650358551729e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let sum = n1 + n2 in\n        match a with \n          | [] ->  if sum > 9 then [1;sum-1] else [0;sum]\n          | c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' else 0::(sum+c)::x'\n    in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  [sum]\n| c::x' -> if c > 9 then sum+1::(c-10)::x' else sum::a\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> [sum]\n      | c::x' -> if c > 9 then (sum + 1) :: (c - 10) :: x' else sum :: a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 267-293:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  [sum]\n| c::x' -> if c > 9 then sum+1::(c-10)::x' else sum::a\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"],"region":{"start":2550,"stop":2890},"type":"eval"},"cursor":2718,"time":1.445650617791458e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let sum = n1 + n2 in\n        match a with \n          | [] ->  [sum]\n          | c::x' -> if c > 9 then sum+1::(c-10)::x' else sum::a\n    in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  [sum]\n| c::x' -> if c > 9 then sum+1::(c-10)::x' else sum::a\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> [sum]\n      | c::x' -> if c > 9 then (sum + 1) :: (c - 10) :: x' else sum :: a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  [sum]\n| c::x' -> if c > 9 then sum+1::(c-10)::x' else sum::a\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"],"region":{"start":2550,"stop":2887},"type":"eval"},"cursor":2810,"time":1.445650748663652e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let sum = n1 + n2 in\n        match a with \n          | [] ->  [sum]\n          | c::x' -> if c > 9 then sum+1::(c-10)::x' else sum::a\n    in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  [sum]\n| c::x' -> if c > 9 then sum+1::(c-10)::x' else sum::a\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> [sum]\n      | c::x' -> if c > 9 then (sum + 1) :: (c - 10) :: x' else sum :: a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> [sum]\n      | c::x' -> if c > 9 then (sum + 1) :: (c - 10) :: x' else sum :: a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> [sum]\n      | c::x' -> if c > 9 then (sum + 1) :: (c - 10) :: x' else sum :: a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  [sum]\n| c::x' -> if c > 9 then sum+1::(c-10)::x' else sum::a\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]"],"region":{"start":2550,"stop":2954},"type":"eval"},"cursor":2957,"time":1.445650765978322e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let sum = n1 + n2 in\n        match a with \n          | [] ->  [sum]\n          | c::x' -> if c > 9 then sum+1::(c-10)::x' else sum::a\n    in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  if sum > 9 then [1;sum-1] else [0;sum]\n| c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' \nelse 0::(sum+c)::x'\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [1; sum - 1] else [0; sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else 0 :: (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [1; sum - 1] else [0; sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else 0 :: (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [1; sum - 1] else [0; sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else 0 :: (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  if sum > 9 then [1;sum-1] else [0;sum]\n| c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' \nelse 0::(sum+c)::x'\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]"],"region":{"start":2550,"stop":3004},"type":"eval"},"cursor":2982,"time":1.445650882434136e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let sum = n1 + n2 in\n        match a with \n          | [] ->  if sum > 9 then [1;sum-1] else [0;sum]\n          | c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' \n              else 0::(sum+c)::x'\n    in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  if sum > 9 then [1;sum-10] else [0;sum]\n| c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' \nelse 0::(sum+c)::x'\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [1; sum - 10] else [0; sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else 0 :: (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [1; sum - 10] else [0; sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else 0 :: (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let sum = n1 + n2 in\n      match a with\n      | [] -> if sum > 9 then [1; sum - 10] else [0; sum]\n      | c::x' ->\n          if (sum + c) > 9\n          then 1 :: ((sum + c) - 10) :: x'\n          else 0 :: (sum + c) :: x' in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet sum = n1 + n2 in\nmatch a with \n| [] ->  if sum > 9 then [1;sum-10] else [0;sum]\n| c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' \nelse 0::(sum+c)::x'\nin\nlet base = [] in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]"],"region":{"start":2550,"stop":3005},"type":"eval"},"cursor":3008,"time":1.445650916305947e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let sum = n1 + n2 in\n        match a with \n          | [] ->  if sum > 9 then [1;sum-10] else [0;sum]\n          | c::x' -> if (sum + c) > 9 then 1::(sum+c-10)::x' \n              else 0::(sum+c)::x'\n    in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]"],"region":{"start":2550,"stop":2949},"type":"eval"},"cursor":2952,"time":1.445651808132126e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = (0,0)::List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = (0, 0) :: (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = (0, 0) :: (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = (0, 0) :: (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = (0,0)::List.combine (List.rev l1) (List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]"],"region":{"start":2550,"stop":2956},"type":"eval"},"cursor":2959,"time":1.445651994480796e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = (0,0)::List.combine (List.rev l1) (List.rev l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev 0::l1) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"type","out":"Characters 223-224:\n  let args = List.combine (List.rev 0::l1) (List.rev 0::l2) in\n                                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = (0, 0) :: (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = (0, 0) :: (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev 0::l1) (List.rev 0::l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]"],"region":{"start":2550,"stop":2955},"type":"eval"},"cursor":2958,"time":1.445652026012903e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev 0::l1) (List.rev 0::l2) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]"],"region":{"start":2550,"stop":2959},"type":"eval"},"cursor":2962,"time":1.44565205743725e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    \tmatch runWTimeout(f,arg,out,timeout) with \n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = fun b -> x (a b) in\nlet base = fun i -> i in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in List.fold_left f base l;;\n","type":"","out":""},{"in":"let stringOfList f l = failwith \"to be implemented\"","min":"\nlet stringOfList f l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> match (mulByDigit i l') with\n| [] -> [h * i]\n| h'::t -> (h*i+h'/10)::(h' mod 10)::t","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      (match mulByDigit i l' with\n       | [] -> [h * i]\n       | h'::t -> ((h * i) + (h' / 10)) :: (h' mod 10) :: t);;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs","let _ = sqsum []","let _ = sqsum [1;2;3;4]","let _ = sqsum [(-1); (-2); (-3); (-4)]","let pipe fs = \nlet f a x = fun b -> x (a b) in\nlet base = fun i -> i in\nList.fold_left f base fs","let _ = pipe [] 3","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet l = failwith \"to be implemented\" in\nList.fold_left f base l","let stringOfList f l = failwith \"to be implemented\"","let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","let _ = clone 3 5","let _ = clone \"foo\" 2","let _ = clone clone (-3)","let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","let _ = padZero [9;9] [1;0;0;2]","let _ = padZero [1;0;0;2] [9;9]","let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> match (mulByDigit i l') with\n| [] -> [h * i]\n| h'::t -> (h*i+h'/10)::(h' mod 10)::t","let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":0,"stop":7530},"type":"eval"},"cursor":0,"time":1.445653320555617e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> match (mulByDigit i l') with\n    | [] -> [h * i]\n    | h'::t -> (h*i+h'/10)::(h' mod 10)::t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> match (mulByDigit i l') with\n| [] -> [h * i]\n| h'::t -> (h*i+h'/10)::(h' mod 10)::t","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      (match mulByDigit i l' with\n       | [] -> [h * i]\n       | h'::t -> ((h * i) + (h' / 10)) :: (h' mod 10) :: t);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      (match mulByDigit i l' with\n       | [] -> [h * i]\n       | h'::t -> ((h * i) + (h' / 10)) :: (h' mod 10) :: t);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> match (mulByDigit i l') with\n| [] -> [h * i]\n| h'::t -> (h*i+h'/10)::(h' mod 10)::t","let _ = mulByDigit 9 [9;9;9;9]"],"region":{"start":2959,"stop":3140},"type":"eval"},"cursor":3110,"time":1.44565336381613e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> match (mulByDigit i l') with\n    | [] -> [h * i]\n    | h'::t -> (h*i+h'/10)::(h' mod 10)::t\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = match 0::l with\n| [] -> []\n| h::l' -> match (mulByDigit i l') with\n| [] -> [h * i]\n| h'::t -> (h*i+h'/10)::(h' mod 10)::t","min":"\nlet rec mulByDigit i l =\n  match 0 :: l with\n  | [] -> []\n  | h::l' ->\n      (match mulByDigit i l' with\n       | [] -> [h * i]\n       | h'::t -> ((h * i) + (h' / 10)) :: (h' mod 10) :: t);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match 0 :: l with\n  | [] -> []\n  | h::l' ->\n      (match mulByDigit i l' with\n       | [] -> [h * i]\n       | h'::t -> ((h * i) + (h' / 10)) :: (h' mod 10) :: t);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec mulByDigit i l = match 0::l with\n| [] -> []\n| h::l' -> match (mulByDigit i l') with\n| [] -> [h * i]\n| h'::t -> (h*i+h'/10)::(h' mod 10)::t","let _ = mulByDigit 9 [9;9;9;9]"],"region":{"start":2959,"stop":3143},"type":"eval"},"cursor":3143,"time":1.44565347665819e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match 0::l with\n  | [] -> []\n  | h::l' -> match (mulByDigit i l') with\n    | [] -> [h * i]\n    | h'::t -> (h*i+h'/10)::(h' mod 10)::t\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> match (mulByDigit i l') with\n| [] -> [h * i]\n| h'::t -> (h*i+h'/10)::(h' mod 10)::t","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      (match mulByDigit i l' with\n       | [] -> [h * i]\n       | h'::t -> ((h * i) + (h' / 10)) :: (h' mod 10) :: t);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      (match mulByDigit i l' with\n       | [] -> [h * i]\n       | h'::t -> ((h * i) + (h' / 10)) :: (h' mod 10) :: t);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> match (mulByDigit i l') with\n| [] -> [h * i]\n| h'::t -> (h*i+h'/10)::(h' mod 10)::t","let _ = mulByDigit 9 [9;9;9;9]"],"region":{"start":2959,"stop":3140},"type":"eval"},"cursor":3140,"time":1.445653795344192e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> match (mulByDigit i l') with\n    | [] -> [h * i]\n    | h'::t -> (h*i+h'/10)::(h' mod 10)::t\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.len res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.len res = l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.len res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.len res) = l'\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"scope","out":"Characters 93-101:\n  if List.len res = 0 then\n     ^^^^^^^^\nError: Unbound value List.len\n"},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      (match mulByDigit i l' with\n       | [] -> [h * i]\n       | h'::t -> ((h * i) + (h' / 10)) :: (h' mod 10) :: t);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.len res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.len res = l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","let _ = mulByDigit 9 [9;9;9;9]"],"region":{"start":2959,"stop":3386},"type":"eval"},"cursor":3386,"time":1.445732607353386e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.len res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.len res = l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = l'\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"type","out":"Characters 199-201:\n  else if List.length res = l' then\n                            ^^\nError: This expression has type int list\n       but an expression was expected of type int\n"},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      (match mulByDigit i l' with\n       | [] -> [h * i]\n       | h'::t -> ((h * i) + (h' / 10)) :: (h' mod 10) :: t);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","let _ = mulByDigit 9 [9;9;9;9]"],"region":{"start":2959,"stop":3392},"type":"eval"},"cursor":3392,"time":1.445732617613454e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"","out":""}],"event":{"phrases":["","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res"],"region":{"start":2959,"stop":3372},"type":"eval"},"cursor":3176,"time":1.445732629249424e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let _ = mulByDigit 9 [9;9;9;9]"],"region":{"start":3372,"stop":3404},"type":"eval"},"cursor":3404,"time":1.445732634052852e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 0 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 0 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let _ = mulByDigit 0 [9;9;9;9]"],"region":{"start":3372,"stop":3404},"type":"eval"},"cursor":3394,"time":1.445732654351947e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 0 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 11 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 11 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let _ = mulByDigit 11 [9;9;9;9]"],"region":{"start":3372,"stop":3405},"type":"eval"},"cursor":3395,"time":1.445732690923812e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 11 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let _ = mulByDigit 9 [9;9;9;9]"],"region":{"start":3372,"stop":3404},"type":"eval"},"cursor":3394,"time":1.445732717717526e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["let _ = mulByDigit 9 [9;9;9;9]","let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":3374,"stop":7748},"type":"eval"},"cursor":3404,"time":1.445732748825923e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = failwith \"to be implemented\" in\n      let base = failwith \"to be implemented\" in\n      let l = failwith \"to be implemented\" in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = match a with\n| \"\" -> x \n| _ -> x ^ sep ^ a\nin\nlet base = \"\" in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""}],"event":{"phrases":["","let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = match a with\n| \"\" -> x \n| _ -> x ^ sep ^ a\nin\nlet base = \"\" in\nlet l = List.rev sl in\nList.fold_left f base l","let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","let _ = sepConcat \"---\" []","let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","let _ = sepConcat \"X\" [\"hello\"]"],"region":{"start":1097,"stop":1434},"type":"eval"},"cursor":1434,"time":1.44573492836576e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = failwith \"to be implemented\"","min":"\nlet stringOfList f l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["let _ = sepConcat \"X\" [\"hello\"]","let stringOfList f l = failwith \"to be implemented\"","let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","let _ = clone 3 5","let _ = clone \"foo\" 2","let _ = clone clone (-3)","let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","let _ = padZero [9;9] [1;0;0;2]","let _ = padZero [1;0;0;2] [9;9]","let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","let _ = mulByDigit 9 [9;9;9;9]","let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":1403,"stop":7672},"type":"eval"},"cursor":1434,"time":1.445734938256101e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = failwith \"to be implemented\"","min":"\nlet stringOfList f l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd res acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with | [] -> ((p + 1), res) | _ -> ((p + 1), (bigAdd res acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"phrases":["","let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","let _ = sepConcat \"---\" []","let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","let _ = sepConcat \"X\" [\"hello\"]","let stringOfList f l = failwith \"to be implemented\"","let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","let _ = clone 3 5","let _ = clone \"foo\" 2","let _ = clone clone (-3)","let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","let _ = padZero [9;9] [1;0;0;2]","let _ = padZero [1;0;0;2] [9;9]","let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","let _ = mulByDigit 9 [9;9;9;9]","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd res acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres"],"region":{"start":1287,"stop":3620},"type":"eval"},"cursor":3620,"time":1.445744143585856e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd res acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""}],"event":{"phrases":["let _ = clone clone (-3)"],"region":{"start":2020,"stop":2044},"type":"eval"},"cursor":2046,"time":1.445744335135175e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigAdd (1::clone n) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""}],"event":{"phrases":["let _ = clone \"foo\" 2"],"region":{"start":1995,"stop":2016},"type":"eval"},"cursor":2019,"time":1.445744343050888e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigAdd (1::clone n) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""}],"event":{"phrases":["let _ = clone 3 5"],"region":{"start":1975,"stop":1992},"type":"eval"},"cursor":1994,"time":1.445744348830759e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigAdd (1::clone n) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let _ = clone \"foo\" 2","let _ = clone clone (-3)","let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","let _ = padZero [9;9] [1;0;0;2]","let _ = padZero [1;0;0;2] [9;9]","let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","let _ = mulByDigit 9 [9;9;9;9]","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [9;9;9;9] [9;9;9;9]","let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"],"region":{"start":1992,"stop":3723},"type":"eval"},"cursor":3724,"time":1.445744408154038e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9] [9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9] [9];;\n","type":"","out":""}],"event":{"phrases":["","let _ = bigMul [9] [9]"],"region":{"start":3648,"stop":3672},"type":"eval"},"cursor":3666,"time":1.445744441749936e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9] [9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9] [9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9] [9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let _ = bigMul [9;9] [9;9]"],"region":{"start":3648,"stop":3676},"type":"eval"},"cursor":3666,"time":1.445744454548007e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9] [9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [1;1] [1;1]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 1] [1; 1];;\n","type":"","out":""}],"event":{"phrases":["","let _ = bigMul [1;1] [1;1]"],"region":{"start":3648,"stop":3676},"type":"eval"},"cursor":3672,"time":1.445744531023534e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 p)) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [1;1] [1;1]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 p)) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 1] [1; 1];;\n","type":"","out":""}],"event":{"phrases":["","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [1;1] [1;1]"],"region":{"start":3326,"stop":3674},"type":"eval"},"cursor":3674,"time":1.445744551226012e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p)) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| (_, []) -> (p+1, res)\n| _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type 'a * 'b list\n       but an expression was expected of type int list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 190-193:\n  | _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\n                                                      ^^^\nError: This expression has type 'a * 'b list\n       but an expression was expected of type int list\n"},{"in":"let _ = bigMul [1;1] [1;1]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 p)) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 1] [1; 1];;\n","type":"","out":""}],"event":{"phrases":["","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| (_, []) -> (p+1, res)\n| _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [1;1] [1;1]"],"region":{"start":3326,"stop":3681},"type":"eval"},"cursor":3681,"time":1.445744593245167e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | (_, []) -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| (_, []) -> (p+1, res)\n| (_, acc') -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc')\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"","type":"scope","out":"Error: This expression has type\n         int * ('a * int list) -> int * int list -> int * int list\n       but an expression was expected of type\n         int * ('a * int list) -> int * int list -> int * ('a * int list)\n       Type int list is not compatible with type 'a * int list \nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 315-316:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int * ('a * int list) -> int * int list -> int * int list\n       but an expression was expected of type\n         int * ('a * int list) -> int * int list -> int * ('a * int list)\n       Type int list is not compatible with type 'a * int list \n"},{"in":"let _ = bigMul [1;1] [1;1]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 p)) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 1] [1; 1];;\n","type":"","out":""}],"event":{"phrases":["","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| (_, []) -> (p+1, res)\n| (_, acc') -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc')\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [1;1] [1;1]"],"region":{"start":3326,"stop":3690},"type":"eval"},"cursor":3690,"time":1.445744630251257e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | (_, []) -> (p+1, res)\n        | (_, acc') -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc')\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [1;1] [1;1]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 1] [1; 1];;\n","type":"","out":""}],"event":{"phrases":["","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [1;1] [1;1]"],"region":{"start":3326,"stop":3676},"type":"eval"},"cursor":3675,"time":1.445744688811837e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (res@(1::clone 0 (p-1))) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (1 :: (clone 0 (p - 1)))) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [1;1] [1;1]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (1 :: (clone 0 (p - 1)))) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 1] [1; 1];;\n","type":"","out":""}],"event":{"phrases":["","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (res@(1::clone 0 (p-1))) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [1;1] [1;1]"],"region":{"start":3326,"stop":3669},"type":"eval"},"cursor":3669,"time":1.445745483088158e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (res@(1::clone 0 (p-1))) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (res@(clone 0 (p-1))) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 (p - 1))) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""}],"event":{"phrases":["","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (res@(clone 0 (p-1))) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres"],"region":{"start":3326,"stop":3638},"type":"eval"},"cursor":3488,"time":1.445745511868683e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (res@(clone 0 (p-1))) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [1;1] [1;1]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 (p - 1))) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 1] [1; 1];;\n","type":"","out":""}],"event":{"phrases":["","let _ = bigMul [1;1] [1;1]"],"region":{"start":3638,"stop":3666},"type":"eval"},"cursor":3666,"time":1.445745514409953e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (res@(clone 0 (p-1))) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 (p - 1))) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["","let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":3666,"stop":7725},"type":"eval"},"cursor":3706,"time":1.44574551817517e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (res@(clone 0 (p-1))) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 (p - 1))) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"],"region":{"start":3667,"stop":3705},"type":"eval"},"cursor":3706,"time":1.4457455234693e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (res@(clone 0 (p-1))) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (bigMul (1::clone 0 (p-1)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 (p - 1))) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigMul (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [1;1] [1;1]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 (p - 1))) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigMul (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 1] [1; 1];;\n","type":"","out":""}],"event":{"phrases":["","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (bigMul (1::clone 0 (p-1)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [1;1] [1;1]"],"region":{"start":3326,"stop":3676},"type":"eval"},"cursor":3676,"time":1.44574569991799e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigMul (1::clone 0 (p-1)) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [1;1] [1;1]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 (p - 1))) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigMul (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 1] [1; 1];;\n","type":"","out":""}],"event":{"phrases":["let _ = bigMul [1;1] [1;1]"],"region":{"start":3650,"stop":3676},"type":"eval"},"cursor":3676,"time":1.445745705827481e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigMul (1::clone 0 (p-1)) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 (p - 1))) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigMul (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"],"region":{"start":3676,"stop":3715},"type":"eval"},"cursor":3716,"time":1.445745709247576e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigMul (1::clone 0 (p-1)) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1] [1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [1;1;1;1] [1;1;1;1]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (bigAdd (1 :: (clone 0 (p - 1))) res) acc)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [1; 1; 1; 1] [1; 1; 1; 1];;\n","type":"","out":""}],"event":{"phrases":["","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\nin\nlet base = (1, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [1;1;1;1] [1;1;1;1]"],"region":{"start":3326,"stop":3684},"type":"eval"},"cursor":3670,"time":1.445745721991987e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (bigAdd (1::clone 0 (p-1)) res) acc)\n  in\n  let base = (1, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [1;1;1;1] [1;1;1;1]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = fun b -> x (a b) in\nlet base = fun i -> i in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = match a with\n| \"\" -> x \n| _ -> x ^ sep ^ a\nin\nlet base = \"\" in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = failwith \"to be implemented\"","min":"\nlet stringOfList f l = failwith \"to be implemented\";;\n","type":"","out":""},{"in":"let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (res@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs","let _ = sqsum []","let _ = sqsum [1;2;3;4]","let _ = sqsum [(-1); (-2); (-3); (-4)]","let pipe fs = \nlet f a x = fun b -> x (a b) in\nlet base = fun i -> i in\nList.fold_left f base fs","let _ = pipe [] 3","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = match a with\n| \"\" -> x \n| _ -> x ^ sep ^ a\nin\nlet base = \"\" in\nlet l = List.rev sl in\nList.fold_left f base l","let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","let _ = sepConcat \"---\" []","let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","let _ = sepConcat \"X\" [\"hello\"]","let stringOfList f l = failwith \"to be implemented\"","let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","let _ = clone 3 5","let _ = clone \"foo\" 2","let _ = clone clone (-3)","let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","let _ = padZero [9;9] [1;0;0;2]","let _ = padZero [1;0;0;2] [9;9]","let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","let _ = mulByDigit 9 [9;9;9;9]","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet res = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, res)\n| _ -> (p+1, bigAdd (res@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [9;9;9;9] [9;9;9;9]","let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":0,"stop":7729},"type":"eval"},"cursor":3487,"time":1.445745954919118e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (res@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]"],"region":{"start":3671,"stop":3709},"type":"eval"},"cursor":3710,"time":1.445745962130557e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (res@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["let _ = bigMul [9;9;9;9] [9;9;9;9]"],"region":{"start":3636,"stop":3670},"type":"eval"},"cursor":3670,"time":1.44574596693884e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (res@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = bigMul [9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let res = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), res)\n    | _ -> ((p + 1), (bigAdd (res @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""}],"event":{"phrases":["","let _ = bigMul [9;9;9] [9;9;9;9]"],"region":{"start":3634,"stop":3668},"type":"eval"},"cursor":3657,"time":1.445745986103495e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = failwith \"to be implemented\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let res = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, res)\n        | _ -> (p+1, bigAdd (res@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = let res = List.map\n\"[\" ^ \"]\"","min":"","type":"syntax","out":"Characters 51-53:\n  \"[\" ^ \"]\";;\n           ^^\nError: Syntax error\n"},{"in":"let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet m = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, m)\n| _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["","let stringOfList f l = let res = List.map\n\"[\" ^ \"]\"","let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","let _ = clone 3 5","let _ = clone \"foo\" 2","let _ = clone clone (-3)","let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","let _ = padZero [9;9] [1;0;0;2]","let _ = padZero [1;0;0;2] [9;9]","let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","let _ = mulByDigit 9 [9;9;9;9]","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet m = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, m)\n| _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [9;9;9;9] [9;9;9;9]","let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":1433,"stop":7723},"type":"eval"},"cursor":3480,"time":1.445746691467921e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let res = List.map\n                                   \"[\" ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> []\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h ^ makeString t\nin makeString l'","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> []\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (makeString t) in\n      makeString l';;\n","type":"type","out":"Characters 161-174:\n  in makeString l';;\n     ^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n"},{"in":"let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet m = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, m)\n| _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["","let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> []\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h ^ makeString t\nin makeString l'","let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","let _ = clone 3 5","let _ = clone \"foo\" 2","let _ = clone clone (-3)","let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","let _ = padZero [9;9] [1;0;0;2]","let _ = padZero [1;0;0;2] [9;9]","let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","let _ = mulByDigit 9 [9;9;9;9]","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet m = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, m)\n| _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [9;9;9;9] [9;9;9;9]","let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":1433,"stop":7846},"type":"eval"},"cursor":1610,"time":1.445747012662624e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> []\n      | _ -> let rec makeString res = match res with\n               | [] -> \"\"\n               | h::t -> h ^ makeString t\n          in makeString l'\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"\"\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h ^ makeString t\nin makeString l'","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (makeString t) in\n      makeString l';;\n","type":"","out":""}],"event":{"phrases":["","let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"\"\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h ^ makeString t\nin makeString l'"],"region":{"start":1433,"stop":1609},"type":"eval"},"cursor":1507,"time":1.445747220356812e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"\"\n      | _ -> let rec makeString res = match res with\n               | [] -> \"\"\n               | h::t -> h ^ makeString t\n          in makeString l'\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"\"\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h ^ makeString t\nin makeString l'","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (makeString t) in\n      makeString l';;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (makeString t) in\n      makeString l';;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (makeString t) in\n      makeString l';;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (makeString t) in\n      makeString l';;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"phrases":["","let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"\"\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h ^ makeString t\nin makeString l'","let _ = stringOfList string_of_int [1;2;3;4;5;6]","let _ = stringOfList (fun x -> x) [\"foo\"]","let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"],"region":{"start":1433,"stop":1778},"type":"eval"},"cursor":1781,"time":1.445747228839304e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"\"\n      | _ -> let rec makeString res = match res with\n               | [] -> \"\"\n               | h::t -> h ^ makeString t\n          in makeString l'\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"\"\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h \"; \" ^ makeString t\nin \"[\" ^ makeString l' ^ \"]\"","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> (h \"; \") ^ (makeString t) in\n      \"[\" ^ ((makeString l') ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> (h \"; \") ^ (makeString t) in\n      \"[\" ^ ((makeString l') ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"type","out":"Characters 21-34:\n  let _ = stringOfList string_of_int [1;2;3;4;5;6];;\n                       ^^^^^^^^^^^^^\nError: This expression has type int -> string\n       but an expression was expected of type int -> string -> string\n       Type string is not compatible with type string -> string \n"}],"event":{"phrases":["","let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"\"\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h \"; \" ^ makeString t\nin \"[\" ^ makeString l' ^ \"]\"","let _ = stringOfList string_of_int [1;2;3;4;5;6]"],"region":{"start":1433,"stop":1676},"type":"eval"},"cursor":1678,"time":1.445747322575888e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"\"\n      | _ -> let rec makeString res = match res with\n               | [] -> \"\"\n               | h::t -> h \"; \" ^ makeString t\n          in \"[\" ^ makeString l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"\"\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h ^ \"; \" ^ makeString t\nin \"[\" ^ makeString l' ^ \"]\"","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (\"; \" ^ (makeString t)) in\n      \"[\" ^ ((makeString l') ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (\"; \" ^ (makeString t)) in\n      \"[\" ^ ((makeString l') ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""}],"event":{"phrases":["","let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"\"\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h ^ \"; \" ^ makeString t\nin \"[\" ^ makeString l' ^ \"]\"","let _ = stringOfList string_of_int [1;2;3;4;5;6]"],"region":{"start":1433,"stop":1678},"type":"eval"},"cursor":1680,"time":1.445747356649419e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"\"\n      | _ -> let rec makeString res = match res with\n               | [] -> \"\"\n               | h::t -> h ^ \"; \" ^ makeString t\n          in \"[\" ^ makeString l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (\"; \" ^ (makeString t)) in\n      \"[\" ^ ((makeString l') ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (\"; \" ^ (makeString t)) in\n      \"[\" ^ ((makeString l') ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"phrases":["","let _ = stringOfList (fun x -> x) [\"foo\"]","let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"],"region":{"start":1678,"stop":1797},"type":"eval"},"cursor":1762,"time":1.445747432173917e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"\"\n      | _ -> let rec makeString res = match res with\n               | [] -> \"\"\n               | h::t -> h ^ \"; \" ^ makeString t\n          in \"[\" ^ makeString l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"[]\"\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h ^ \"; \" ^ makeString t\nin \"[\" ^ makeString l' ^ \"]\"","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"[]\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (\"; \" ^ (makeString t)) in\n      \"[\" ^ ((makeString l') ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"[]\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (\"; \" ^ (makeString t)) in\n      \"[\" ^ ((makeString l') ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"[]\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (\"; \" ^ (makeString t)) in\n      \"[\" ^ ((makeString l') ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with\n  | [] -> \"[]\"\n  | _ ->\n      let rec makeString res =\n        match res with | [] -> \"\" | h::t -> h ^ (\"; \" ^ (makeString t)) in\n      \"[\" ^ ((makeString l') ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"phrases":["","let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"[]\"\n| _ -> let rec makeString res = match res with\n| [] -> \"\"\n| h::t -> h ^ \"; \" ^ makeString t\nin \"[\" ^ makeString l' ^ \"]\"","let _ = stringOfList string_of_int [1;2;3;4;5;6]","let _ = stringOfList (fun x -> x) [\"foo\"]","let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"],"region":{"start":1433,"stop":1799},"type":"eval"},"cursor":1773,"time":1.445747464816697e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"[]\"\n      | _ -> let rec makeString res = match res with\n               | [] -> \"\"\n               | h::t -> h ^ \"; \" ^ makeString t\n          in \"[\" ^ makeString l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""}],"event":{"phrases":["let _ = sepConcat \"X\" [\"hello\"]"],"region":{"start":1402,"stop":1433},"type":"eval"},"cursor":1433,"time":1.445747653930594e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"[]\"\n      | _ -> let rec makeString res = match res with\n               | [] -> \"\"\n               | h::t -> h ^ \"; \" ^ makeString t\n          in \"[\" ^ makeString l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""}],"event":{"phrases":["let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]"],"region":{"start":1359,"stop":1401},"type":"eval"},"cursor":1401,"time":1.445747658981862e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"[]\"\n      | _ -> let rec makeString res = match res with\n               | [] -> \"\"\n               | h::t -> h ^ \"; \" ^ makeString t\n          in \"[\" ^ makeString l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"[]\"\n| _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""}],"event":{"phrases":["","let _ = sepConcat \"X\" [\"hello\"]","let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"[]\"\n| _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"","let _ = stringOfList string_of_int [1;2;3;4;5;6]"],"region":{"start":1401,"stop":1597},"type":"eval"},"cursor":1599,"time":1.44574769846831e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"[]\"\n      | _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet m = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, m)\n| _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["","let _ = stringOfList (fun x -> x) [\"foo\"]","let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","let _ = clone 3 5","let _ = clone \"foo\" 2","let _ = clone clone (-3)","let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","let _ = padZero [9;9] [1;0;0;2]","let _ = padZero [1;0;0;2] [9;9]","let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","let _ = mulByDigit 9 [9;9;9;9]","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet m = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, m)\n| _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [9;9;9;9] [9;9;9;9]","let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":1597,"stop":7738},"type":"eval"},"cursor":1718,"time":1.445747702385558e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"[]\"\n      | _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"phrases":["let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"],"region":{"start":1644,"stop":1716},"type":"eval"},"cursor":1720,"time":1.445747710646425e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"[]\"\n      | _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"phrases":["let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"],"region":{"start":1644,"stop":1716},"type":"eval"},"cursor":1719,"time":1.445747716704751e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"[]\"\n      | _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"[]\"\n| _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n","type":"","out":""}],"event":{"phrases":["let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"[]\"\n| _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\""],"region":{"start":1435,"stop":1547},"type":"eval"},"cursor":1548,"time":1.445747719697483e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"[]\"\n      | _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""}],"event":{"phrases":["","let _ = stringOfList string_of_int [1;2;3;4;5;6]","let _ = stringOfList (fun x -> x) [\"foo\"]","let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]"],"region":{"start":1547,"stop":1716},"type":"eval"},"cursor":1719,"time":1.445747722302574e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"[]\"\n      | _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet m = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, m)\n| _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","let _ = clone 3 5","let _ = clone \"foo\" 2","let _ = clone clone (-3)","let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","let _ = padZero [9;9] [1;0;0;2]","let _ = padZero [1;0;0;2] [9;9]","let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","let _ = mulByDigit 9 [9;9;9;9]","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet m = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, m)\n| _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [9;9;9;9] [9;9;9;9]","let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":1644,"stop":7738},"type":"eval"},"cursor":1719,"time":1.445747729810922e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"[]\"\n      | _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let _ = sqsum []","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [];;\n","type":"","out":""},{"in":"let _ = sqsum [1;2;3;4]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sqsum [(-1); (-2); (-3); (-4)]","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n\nlet _ = sqsum [(-1); (-2); (-3); (-4)];;\n","type":"","out":""},{"in":"let pipe fs = \nlet f a x = fun b -> x (a b) in\nlet base = fun i -> i in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let _ = pipe [] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n","type":"","out":""},{"in":"let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","min":"\nlet pipe fs =\n  let f a x b = x (a b) in let base i = i in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = match a with\n| \"\" -> x \n| _ -> x ^ sep ^ a\nin\nlet base = \"\" in\nlet l = List.rev sl in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n","type":"","out":""},{"in":"let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \", \" [\"foo\"; \"bar\"; \"baz\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"---\" []","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"---\" [];;\n","type":"","out":""},{"in":"let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"\" [\"a\"; \"b\"; \"c\"; \"d\"; \"e\"];;\n","type":"","out":""},{"in":"let _ = sepConcat \"X\" [\"hello\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet _ = sepConcat \"X\" [\"hello\"];;\n","type":"","out":""},{"in":"let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"[]\"\n| _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n","type":"","out":""},{"in":"let _ = stringOfList string_of_int [1;2;3;4;5;6]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ = stringOfList string_of_int [1; 2; 3; 4; 5; 6];;\n","type":"","out":""},{"in":"let _ = stringOfList (fun x -> x) [\"foo\"]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ = stringOfList (fun x  -> x) [\"foo\"];;\n","type":"","out":""},{"in":"let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> x ^ (sep ^ a) in\n      let base = \"\" in let l = List.rev sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let l' = List.map f l in\n  match l' with | [] -> \"[]\" | _ -> \"[\" ^ ((sepConcat \"; \" l') ^ \"]\");;\n\nlet _ =\n  stringOfList (stringOfList string_of_int) [[1; 2; 3]; [4; 5]; [6]; []];;\n","type":"","out":""},{"in":"let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n","type":"","out":""},{"in":"let _ = clone 3 5","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone 3 5;;\n","type":"","out":""},{"in":"let _ = clone \"foo\" 2","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone \"foo\" 2;;\n","type":"","out":""},{"in":"let _ = clone clone (-3)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet _ = clone clone (-3);;\n","type":"","out":""},{"in":"let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n","type":"","out":""},{"in":"let _ = padZero [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = padZero [1;0;0;2] [9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;1;0;0;2]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = removeZero [9;9]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [9; 9];;\n","type":"","out":""},{"in":"let _ = removeZero [0;0;0;0]","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet _ = removeZero [0; 0; 0; 0];;\n","type":"","out":""},{"in":"let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9] [1;0;0;2]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9] [1; 0; 0; 2];;\n","type":"","out":""},{"in":"let _ = bigAdd [9;9;9;9] [9;9;9]","min":"\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n","type":"","out":""},{"in":"let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n","type":"","out":""},{"in":"let _ = mulByDigit 9 [9;9;9;9]","min":"\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet _ = mulByDigit 9 [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet m = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, m)\n| _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9] [9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n","type":"","out":""},{"in":"let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","min":"\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff > 0\n  then (l1, ((clone 0 diff) @ l2))\n  else if diff < 0 then (((clone 0 (diff * (-1))) @ l1), l2) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::l' -> if h = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,n) = a in\n      let sum = (n1 + n2) + c in\n      if sum > 9 then (1, ((sum - 10) :: n)) else (0, (sum :: n)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::l' ->\n      let res = mulByDigit i l' in\n      if (List.length res) = 0\n      then (if (h * i) > 9 then [(h * i) / 10; (h * i) mod 10] else [h * i])\n      else\n        if (List.length res) = (List.length l')\n        then\n          (if (h * i) > 9\n           then ((h * i) / 10) :: ((h * i) mod 10) :: res\n           else (h * i) :: res)\n        else\n          (match res with\n           | h'::res' ->\n               if ((h * i) + h') > 9\n               then (((h * i) + h') / 10) :: (((h * i) + h') mod 10) :: res'\n               else ((h * i) + h') :: res);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (p,acc) = a in\n    let (d,l) = x in\n    let m = mulByDigit d l in\n    match acc with\n    | [] -> ((p + 1), m)\n    | _ -> ((p + 1), (bigAdd (m @ (clone 0 p)) acc)) in\n  let base = (0, []) in\n  let args = List.map (fun x  -> (x, l2)) (List.rev l1) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs","let _ = sqsum []","let _ = sqsum [1;2;3;4]","let _ = sqsum [(-1); (-2); (-3); (-4)]","let pipe fs = \nlet f a x = fun b -> x (a b) in\nlet base = fun i -> i in\nList.fold_left f base fs","let _ = pipe [] 3","let _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3","let _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3","let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = match a with\n| \"\" -> x \n| _ -> x ^ sep ^ a\nin\nlet base = \"\" in\nlet l = List.rev sl in\nList.fold_left f base l","let _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]","let _ = sepConcat \"---\" []","let _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]","let _ = sepConcat \"X\" [\"hello\"]","let stringOfList f l = let l' = List.map f l in\nmatch l' with\n| [] -> \"[]\"\n| _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"","let _ = stringOfList string_of_int [1;2;3;4;5;6]","let _ = stringOfList (fun x -> x) [\"foo\"]","let _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]]","let rec clone x n = if n < 1 then []\nelse x::clone x (n - 1)","let _ = clone 3 5","let _ = clone \"foo\" 2","let _ = clone clone (-3)","let padZero l1 l2 = let diff = List.length l1 - List.length l2 in\nif diff > 0 then\n(l1, clone 0 diff @ l2)\nelse if diff < 0 then\n(clone 0 (diff * -1) @ l1, l2)\nelse (l1,l2)","let _ = padZero [9;9] [1;0;0;2]","let _ = padZero [1;0;0;2] [9;9]","let rec removeZero l = match l with\n| [] -> []\n| h::l' -> if h = 0 then removeZero l' else l","let _ = removeZero [0;0;0;1;0;0;2]","let _ = removeZero [9;9]","let _ = removeZero [0;0;0;0]","let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let (n1,n2) = x in \nlet (c,n) = a in\nlet sum = n1 + n2 + c in\nif sum > 9 then (1, sum - 10::n) else (0, sum::n)\nin\nlet base = (0, []) in\nlet args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))","let _ = bigAdd [9;9] [1;0;0;2]","let _ = bigAdd [9;9;9;9] [9;9;9]","let rec mulByDigit i l = match l with\n| [] -> []\n| h::l' -> let res = mulByDigit i l' in \nif List.length res = 0 then\nif (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\nelse if List.length res = List.length l' then\nif (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\nelse match res with\n| h'::res' -> \nif (h * i + h') > 9 then \n((h*i+h') / 10)::((h*i+h') mod 10)::res'\nelse (h*i+h')::res","let _ = mulByDigit 9 [9;9;9;9]","let bigMul l1 l2 = \nlet f a x = let (p, acc) = a in\nlet (d, l) = x in \nlet m = mulByDigit d l in\nmatch acc with\n| [] -> (p+1, m)\n| _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\nin\nlet base = (0, []) in\nlet args = List.map (fun x -> (x, l2)) (List.rev l1) in\nlet (_, res) = List.fold_left f base args in\nres","let _ = bigMul [9;9;9;9] [9;9;9;9]","let _ = bigMul [9;9;9;9;9] [9;9;9;9;9]","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s = \nlet rec _exp i = \nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs = \nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s = \nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) = \n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report = \n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":0,"stop":7738},"type":"eval"},"cursor":0,"time":1.445923317557305e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sqsum xs = \n  let f a x = a + x * x in\n  let base = 0 in\n    List.fold_left f base xs\n\nlet _ = sqsum []\nlet _ = sqsum [1;2;3;4]\nlet _ = sqsum [(-1); (-2); (-3); (-4)]\n\n\nlet pipe fs = \n  let f a x = fun b -> x (a b) in\n  let base = fun i -> i in\n    List.fold_left f base fs\n\nlet _ = pipe [] 3\n\nlet _ = pipe [(fun x -> x+x); (fun x -> x + 3)] 3\n\nlet _ = pipe [(fun x -> x + 3);(fun x-> x + x)] 3\n\n\nlet rec sepConcat sep sl = match sl with \n  | [] -> \"\"\n  | h :: t -> \n      let f a x = match a with\n        | \"\" -> x \n        | _ -> x ^ sep ^ a\n      in\n      let base = \"\" in\n      let l = List.rev sl in\n        List.fold_left f base l\n\nlet _ = sepConcat \", \" [\"foo\";\"bar\";\"baz\"]\nlet _ = sepConcat \"---\" []\nlet _ = sepConcat \"\" [\"a\";\"b\";\"c\";\"d\";\"e\"]\nlet _ = sepConcat \"X\" [\"hello\"]\n\nlet stringOfList f l = let l' = List.map f l in\n    match l' with\n      | [] -> \"[]\"\n      | _ ->  \"[\" ^ sepConcat \"; \" l' ^ \"]\"\n\nlet _ = stringOfList string_of_int [1;2;3;4;5;6];;\nlet _ = stringOfList (fun x -> x) [\"foo\"];;\nlet _ = stringOfList (stringOfList string_of_int) [[1;2;3];[4;5];[6];[]];;\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec clone x n = if n < 1 then []\n  else x::clone x (n - 1)\n\nlet _ = clone 3 5;;\nlet _ = clone \"foo\" 2;; \nlet _ = clone clone (-3);;\n\n\nlet padZero l1 l2 = let diff = List.length l1 - List.length l2 in\n    if diff > 0 then\n      (l1, clone 0 diff @ l2)\n    else if diff < 0 then\n      (clone 0 (diff * -1) @ l1, l2)\n    else (l1,l2)\n\n\nlet _ = padZero [9;9] [1;0;0;2]\nlet _ = padZero [1;0;0;2] [9;9] \n\nlet rec removeZero l = match l with\n  | [] -> []\n  | h::l' -> if h = 0 then removeZero l' else l\n\nlet _ = removeZero [0;0;0;1;0;0;2]\nlet _ = removeZero [9;9]\nlet _ = removeZero [0;0;0;0]\n\n\nlet bigAdd l1 l2 = \n  let add (l1, l2) = \n    let f a x = let (n1,n2) = x in \n      let (c,n) = a in\n      let sum = n1 + n2 + c in\n        if sum > 9 then (1, sum - 10::n) else (0, sum::n)\n    in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0::l1)) (List.rev (0::l2)) in\n    let (_, res) = List.fold_left f base args in\n      res\n  in \n    removeZero (add (padZero l1 l2))\n\nlet _ = bigAdd [9;9] [1;0;0;2];;\nlet _ = bigAdd [9;9;9;9] [9;9;9];; \n\n\nlet rec mulByDigit i l = match l with\n  | [] -> []\n  | h::l' -> let res = mulByDigit i l' in \n        if List.length res = 0 then\n          if (h * i) > 9 then [h*i / 10;(h*i) mod 10] else [h*i]\n        else if List.length res = List.length l' then\n          if (h * i) > 9 then (h*i / 10)::((h*i) mod 10)::res else (h*i)::res\n        else match res with\n          | h'::res' -> \n              if (h * i + h') > 9 then \n                ((h*i+h') / 10)::((h*i+h') mod 10)::res'\n              else (h*i+h')::res\n\nlet _ = mulByDigit 9 [9;9;9;9]\n\n\nlet bigMul l1 l2 = \n  let f a x = let (p, acc) = a in\n    let (d, l) = x in \n    let m = mulByDigit d l in\n      match acc with\n        | [] -> (p+1, m)\n        | _ -> (p+1, bigAdd (m@(clone 0 p)) acc)\n  in\n  let base = (0, []) in\n  let args = List.map (fun x -> (x, l2)) (List.rev l1) in\n  let (_, res) = List.fold_left f base args in\n    res\n\nlet _ = bigMul [9;9;9;9] [9;9;9;9]\nlet _ = bigMul [9;9;9;9;9] [9;9;9;9;9] \n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\") \n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s = \n  let rec _exp i = \n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs = \n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s = \n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) = \n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report = \n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n\n\n","file":"hw3.ml"}
