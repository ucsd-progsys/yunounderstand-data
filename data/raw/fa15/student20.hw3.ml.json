{"ocaml":[],"event":{"phrases":[],"region":{"start":0,"stop":0},"type":"eval"},"cursor":0,"time":1.445709890776096e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet sqsum xs =\n  let f a x = a + x*x in\n  let base =  0 in\n    List.fold_left f base xs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet pipe fs =\n  let f a x = fun k -> x (a k) in\n  let base = fun z -> z in\n    List.fold_left f base fs\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with\n  | [] -> \"\"\n  | h :: t ->\n      let f a x = if a = x then a else a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec clone x n =\n  let rec helper base count =\n    if count < n\n    then helper (x::base) (count+1)\n    else base\n  in helper [] 0\n\n(*XXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n    if l1_len < l2_len\n    then ((clone 0 (l2_len - l1_len)) @ l1,  l2)\n    else (l1,  (clone 0 (l1_len - l2_len)) @ l2)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = match l with\n    [] -> []\n  | h::t -> if h < 1 then removeZero t else h::t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 =\n  let add (l1, l2) =\n\n    let f a x =\n      (\n        (*XXXXXXX*)\n        let (carryIn, sumList) = a           in\n        let (ai, bi) = x                     in\n\n        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n        let sumList = match sumList with\n          | [] -> []\n          | h::t -> t                        in\n\n        (*XXXXXXXXXXXX*)\n        let sum      = ai+bi+carryIn in\n        let carryOut = sum / 10      in\n        let digit    = sum mod 10    in\n\n          (*XXXXXXXX*)\n          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          (carryOut, carryOut::digit::sumList)\n      ) in\n\n    let base  = (0, []) in\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    let args =\n      (\n        let rec helper combinedList tuple = match tuple with\n            (l1h::l1t, l2h::l2t)  -> helper ((l1h,l2h)::combinedList)  (l1t, l2t)\n          | (_, _) -> combinedList\n        in helper [] (l1, l2)\n      ) in\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    let (_, res) = List.fold_left f base args in\n      res\n  in\n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX*)\nlet rec mulByDigit i l =\n  let rec helper count sum =\n    if count < i\n    then helper (count+1) (bigAdd sum l)\n    else sum\n  in helper 1 l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXX*)\n   let (carryIn, sumList) = a   in\n\n   (*XXXXXXXXXXXXXXXXXXXXXXX*)\n   let product  =  i * x  + carryIn     in\n   let carryOut = product / 10          in\n   let digit    = product mod 10        in\n\n   (*XXXXXXXX*)\n   (carryOut, digit::sumList)\n   ) in\n   let base = (0, []) in\n   let args = List.rev l in\n   let (carry, res) = List.fold_left f base args in\n   carry::res\n   in\n   removeZero (mul i l)\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 =\n  let f a x =\n    (\n      (*XXXXXXX*)\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let (nth, res) = a in\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n      let product_i = mulByDigit nth (mulByDigit x l1) in\n\n        (*XXXXX*)\n        (*XXXXXXXXXXXXXXXXXXXXXXXX*)\n        (nth*10, bigAdd res product_i)\n    ) in\n  let base = (1, []) in\n\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let args =\n    (\n      let rec helper res lst = match lst with\n          []   -> res\n        | h::t -> helper (h::res) t\n      in helper [] l2\n    ) in\n\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) =\n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")\n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in\n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&\n    runWTimeout(testBad,0,1,5) = Fail &&\n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" &&\n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs =\n    \tmatch runWTimeout(f,arg,out,timeout) with\n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s =\n  let rec _exp i =\n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs =\n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s =\n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) =\n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report =\n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n","file":"hw3.ml"}
{"ocaml":[{"in":"let sqsum xs =\nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs","min":"\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n","type":"","out":""},{"in":"let pipe fs =\nlet f a x = fun k -> x (a k) in\nlet base = fun z -> z in\nList.fold_left f base fs","min":"\nlet pipe fs =\n  let f a x k = x (a k) in let base z = z in List.fold_left f base fs;;\n","type":"","out":""},{"in":"let rec sepConcat sep sl = match sl with\n| [] -> \"\"\n| h :: t ->\nlet f a x = if a = x then a else a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a = x then a else a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n","type":"","out":""},{"in":"let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","min":"\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = if a = x then a else a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n","type":"","out":""},{"in":"let rec clone x n =\nlet rec helper base count =\nif count < n\nthen helper (x::base) (count+1)\nelse base\nin helper [] 0","min":"\nlet rec clone x n =\n  let rec helper base count =\n    if count < n then helper (x :: base) (count + 1) else base in\n  helper [] 0;;\n","type":"","out":""},{"in":"let padZero l1 l2 =\nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nif l1_len < l2_len\nthen ((clone 0 (l2_len - l1_len)) @ l1,  l2)\nelse (l1,  (clone 0 (l1_len - l2_len)) @ l2)","min":"\nlet rec clone x n =\n  let rec helper base count =\n    if count < n then helper (x :: base) (count + 1) else base in\n  helper [] 0;;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  if l1_len < l2_len\n  then (((clone 0 (l2_len - l1_len)) @ l1), l2)\n  else (l1, ((clone 0 (l1_len - l2_len)) @ l2));;\n","type":"","out":""},{"in":"let rec removeZero l = match l with\n[] -> []\n| h::t -> if h < 1 then removeZero t else h::t","min":"\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h < 1 then removeZero t else h :: t;;\n","type":"","out":""},{"in":"let bigAdd l1 l2 =\nlet add (l1, l2) =\n\nlet f a x =\n(\n(* Input *)\nlet (carryIn, sumList) = a           in\nlet (ai, bi) = x                     in\n\n(* Removing carry from sumList\nRefer to note below for more detail *)\nlet sumList = match sumList with\n| [] -> []\n| h::t -> t                        in\n\n(* Handle Add *)\nlet sum      = ai+bi+carryIn in\nlet carryOut = sum / 10      in\nlet digit    = sum mod 10    in\n\n(* Output *)\n(* NOTE that carryOut is apeended to sumList because\nprovided code, \"let(_, res) = List.fold_left f base args in res\",\ndoes not return extra carry at the end.\nDuring the carry out propagation, 0 or 1 is added to sumList\nthus this 0 or 1 needs to be removed.\nFor example, 18+19             IN        OUT\n1st base(variable a) =  (0, [] )  (1, [1;7])\n2nd base             =  (1, [7])  (1, [3;7])\nreturn => [3;7]\nWhen adding 8+9, carry 1 is added to sumList, [1;7]. This 1 needs\nto be remove from the list before computing next single digit sum. *)\n(carryOut, carryOut::digit::sumList)\n) in\n\nlet base  = (0, []) in\n\n(* List of tuples combined with other list element.\nFor example, Let I = [i1;i2;i3] and J = [j;j2;j3],\nthen the result will be [(i3,j3);(i2,j2);(i1,j1)].\nNote that the order is important the least significant digit\nin I and J first tuple in the result list .\nThis can be easily achieved using List.combine, and List.rev *)\nlet args =\n(\nlet rec helper combinedList tuple = match tuple with\n(l1h::l1t, l2h::l2t)  -> helper ((l1h,l2h)::combinedList)  (l1t, l2t)\n| (_, _) -> combinedList\nin helper [] (l1, l2)\n) in\n\n(* Does not return extra carry so hanled in f.\nEasier if code was\nlet (carry, res) = List.fold_left f base args in carry::res *)\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))","min":"\nlet rec clone x n =\n  let rec helper base count =\n    if count < n then helper (x :: base) (count + 1) else base in\n  helper [] 0;;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  if l1_len < l2_len\n  then (((clone 0 (l2_len - l1_len)) @ l1), l2)\n  else (l1, ((clone 0 (l1_len - l2_len)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h < 1 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carryIn,sumList) = a in\n      let (ai,bi) = x in\n      let sumList = match sumList with | [] -> [] | h::t -> t in\n      let sum = (ai + bi) + carryIn in\n      let carryOut = sum / 10 in\n      let digit = sum mod 10 in (carryOut, (carryOut :: digit :: sumList)) in\n    let base = (0, []) in\n    let args =\n      let rec helper combinedList tuple =\n        match tuple with\n        | (l1h::l1t,l2h::l2t) ->\n            helper ((l1h, l2h) :: combinedList) (l1t, l2t)\n        | (_,_) -> combinedList in\n      helper [] (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n","type":"","out":""},{"in":"let rec mulByDigit i l =\nlet rec helper count sum =\nif count < i\nthen helper (count+1) (bigAdd sum l)\nelse sum\nin helper 1 l","min":"\nlet rec clone x n =\n  let rec helper base count =\n    if count < n then helper (x :: base) (count + 1) else base in\n  helper [] 0;;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  if l1_len < l2_len\n  then (((clone 0 (l2_len - l1_len)) @ l1), l2)\n  else (l1, ((clone 0 (l1_len - l2_len)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h < 1 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carryIn,sumList) = a in\n      let (ai,bi) = x in\n      let sumList = match sumList with | [] -> [] | h::t -> t in\n      let sum = (ai + bi) + carryIn in\n      let carryOut = sum / 10 in\n      let digit = sum mod 10 in (carryOut, (carryOut :: digit :: sumList)) in\n    let base = (0, []) in\n    let args =\n      let rec helper combinedList tuple =\n        match tuple with\n        | (l1h::l1t,l2h::l2t) ->\n            helper ((l1h, l2h) :: combinedList) (l1t, l2t)\n        | (_,_) -> combinedList in\n      helper [] (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper count sum =\n    if count < i then helper (count + 1) (bigAdd sum l) else sum in\n  helper 1 l;;\n","type":"","out":""},{"in":"let bigMul l1 l2 =\nlet f a x =\n(\n(* Input *)\n(* nth represent every nth digit\nFor example, in number 325, nth of 5 is 1\nnth of 2 is 10, and nth of 3 is 100 *)\nlet (nth, res) = a in\n(*\nl1:    35        [  3;5] <- No need leading zeros\nl2: x 315   => x [3;1;5]\n---------     ----------\nFirst step here is 35 * 5 which can be done by\nusing mulByDigit 5 [3;5] => [1;7;5]\n\nSecond step is 35 * 2, so mulByDigit 1 [3;5] => [3;5].\nSince 1 is 2nd digit, [3;5] must be multiply by 10, thus\nmulByDigit 10 [3;0] => [3;5;0]\n\nThird step is 35 * 3 => so mulByDigit 3 [3;5] => [1;0;5]\nBecause 3 is 3rd digit [1;0;5] must be multiply by 100, thus\nmulByDigit 100 [1;0;5] => [1;0;5;0;0]\n\nIn general, mulByDigit nth (mulByDigit x   l1)\nex,            10              3 [3;5]\n\nAdding each result will give [1;1;0;2;5]\nwich match with 35*315 = 11025.\n*)\nlet product_i = mulByDigit nth (mulByDigit x l1) in\n\n(* Out *)\n(* Compute next nth digit *)\n(nth*10, bigAdd res product_i)\n) in\nlet base = (1, []) in\n\n(* Reversing l2 without using List.rev *)\nlet args =\n(\nlet rec helper res lst = match lst with\n[]   -> res\n| h::t -> helper (h::res) t\nin helper [] l2\n) in\n\nlet (_, res) = List.fold_left f base args in\nres","min":"\nlet rec clone x n =\n  let rec helper base count =\n    if count < n then helper (x :: base) (count + 1) else base in\n  helper [] 0;;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  if l1_len < l2_len\n  then (((clone 0 (l2_len - l1_len)) @ l1), l2)\n  else (l1, ((clone 0 (l1_len - l2_len)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h < 1 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carryIn,sumList) = a in\n      let (ai,bi) = x in\n      let sumList = match sumList with | [] -> [] | h::t -> t in\n      let sum = (ai + bi) + carryIn in\n      let carryOut = sum / 10 in\n      let digit = sum mod 10 in (carryOut, (carryOut :: digit :: sumList)) in\n    let base = (0, []) in\n    let args =\n      let rec helper combinedList tuple =\n        match tuple with\n        | (l1h::l1t,l2h::l2t) ->\n            helper ((l1h, l2h) :: combinedList) (l1t, l2t)\n        | (_,_) -> combinedList in\n      helper [] (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper count sum =\n    if count < i then helper (count + 1) (bigAdd sum l) else sum in\n  helper 1 l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (nth,res) = a in\n    let product_i = mulByDigit nth (mulByDigit x l1) in\n    ((nth * 10), (bigAdd res product_i)) in\n  let base = (1, []) in\n  let args =\n    let rec helper res lst =\n      match lst with | [] -> res | h::t -> helper (h :: res) t in\n    helper [] l2 in\n  let (_,res) = List.fold_left f base args in res;;\n","type":"","out":""},{"in":"let key = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130 = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) =\ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ ((Printexc.to_string e) ^ \"\\n\"));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let explode s =\nlet rec _exp i =\nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n","type":"","out":""},{"in":"let implode cs =\nString.concat \"\" (List.map (String.make 1) cs)","min":"\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n","type":"","out":""},{"in":"let drop_paren s =\nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","min":"\nlet explode s =\n  let rec _exp i =\n    if i >= (String.length s) then [] else (s.[i]) :: (_exp (i + 1)) in\n  _exp 0;;\n\nlet implode cs = String.concat \"\" (List.map (String.make 1) cs);;\n\nlet drop_paren s =\n  implode\n    (List.filter (fun c  -> not (List.mem c ['('; ' '; ')'])) (explode s));;\n","type":"","out":""},{"in":"let eq_real p (r1,r2) =\n(r1 -. r2) < p || (r2 -. r1) < p","min":"\nlet eq_real p (r1,r2) = ((r1 -. r2) < p) || ((r2 -. r1) < p);;\n","type":"","out":""},{"in":"let wrap_curried_2 f (a,b) = f a b","min":"\nlet wrap_curried_2 f (a,b) = f a b;;\n","type":"","out":""},{"in":"let _ = print130 (\"Compiled\"^key^\"\\n\")","min":"\nlet prefix130 = \"130\";;\n\nlet key = \"\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet _ = print130 (\"Compiled\" ^ (key ^ \"\\n\"));;\n","type":"","out":""}],"event":{"phrases":["let sqsum xs =\nlet f a x = a + x*x in\nlet base =  0 in\nList.fold_left f base xs","let pipe fs =\nlet f a x = fun k -> x (a k) in\nlet base = fun z -> z in\nList.fold_left f base fs","let rec sepConcat sep sl = match sl with\n| [] -> \"\"\n| h :: t ->\nlet f a x = if a = x then a else a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l","let stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"","let rec clone x n =\nlet rec helper base count =\nif count < n\nthen helper (x::base) (count+1)\nelse base\nin helper [] 0","let padZero l1 l2 =\nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nif l1_len < l2_len\nthen ((clone 0 (l2_len - l1_len)) @ l1,  l2)\nelse (l1,  (clone 0 (l1_len - l2_len)) @ l2)","let rec removeZero l = match l with\n[] -> []\n| h::t -> if h < 1 then removeZero t else h::t","let bigAdd l1 l2 =\nlet add (l1, l2) =\n\nlet f a x =\n(\n(* Input *)\nlet (carryIn, sumList) = a           in\nlet (ai, bi) = x                     in\n\n(* Removing carry from sumList\nRefer to note below for more detail *)\nlet sumList = match sumList with\n| [] -> []\n| h::t -> t                        in\n\n(* Handle Add *)\nlet sum      = ai+bi+carryIn in\nlet carryOut = sum / 10      in\nlet digit    = sum mod 10    in\n\n(* Output *)\n(* NOTE that carryOut is apeended to sumList because\nprovided code, \"let(_, res) = List.fold_left f base args in res\",\ndoes not return extra carry at the end.\nDuring the carry out propagation, 0 or 1 is added to sumList\nthus this 0 or 1 needs to be removed.\nFor example, 18+19             IN        OUT\n1st base(variable a) =  (0, [] )  (1, [1;7])\n2nd base             =  (1, [7])  (1, [3;7])\nreturn => [3;7]\nWhen adding 8+9, carry 1 is added to sumList, [1;7]. This 1 needs\nto be remove from the list before computing next single digit sum. *)\n(carryOut, carryOut::digit::sumList)\n) in\n\nlet base  = (0, []) in\n\n(* List of tuples combined with other list element.\nFor example, Let I = [i1;i2;i3] and J = [j;j2;j3],\nthen the result will be [(i3,j3);(i2,j2);(i1,j1)].\nNote that the order is important the least significant digit\nin I and J first tuple in the result list .\nThis can be easily achieved using List.combine, and List.rev *)\nlet args =\n(\nlet rec helper combinedList tuple = match tuple with\n(l1h::l1t, l2h::l2t)  -> helper ((l1h,l2h)::combinedList)  (l1t, l2t)\n| (_, _) -> combinedList\nin helper [] (l1, l2)\n) in\n\n(* Does not return extra carry so hanled in f.\nEasier if code was\nlet (carry, res) = List.fold_left f base args in carry::res *)\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))","let rec mulByDigit i l =\nlet rec helper count sum =\nif count < i\nthen helper (count+1) (bigAdd sum l)\nelse sum\nin helper 1 l","let bigMul l1 l2 =\nlet f a x =\n(\n(* Input *)\n(* nth represent every nth digit\nFor example, in number 325, nth of 5 is 1\nnth of 2 is 10, and nth of 3 is 100 *)\nlet (nth, res) = a in\n(*\nl1:    35        [  3;5] <- No need leading zeros\nl2: x 315   => x [3;1;5]\n---------     ----------\nFirst step here is 35 * 5 which can be done by\nusing mulByDigit 5 [3;5] => [1;7;5]\n\nSecond step is 35 * 2, so mulByDigit 1 [3;5] => [3;5].\nSince 1 is 2nd digit, [3;5] must be multiply by 10, thus\nmulByDigit 10 [3;0] => [3;5;0]\n\nThird step is 35 * 3 => so mulByDigit 3 [3;5] => [1;0;5]\nBecause 3 is 3rd digit [1;0;5] must be multiply by 100, thus\nmulByDigit 100 [1;0;5] => [1;0;5;0;0]\n\nIn general, mulByDigit nth (mulByDigit x   l1)\nex,            10              3 [3;5]\n\nAdding each result will give [1;1;0;2;5]\nwich match with 35*315 = 11025.\n*)\nlet product_i = mulByDigit nth (mulByDigit x l1) in\n\n(* Out *)\n(* Compute next nth digit *)\n(nth*10, bigAdd res product_i)\n) in\nlet base = (1, []) in\n\n(* Reversing l2 without using List.rev *)\nlet args =\n(\nlet rec helper res lst = match lst with\n[]   -> res\n| h::t -> helper (h::res) t\nin helper [] l2\n) in\n\nlet (_, res) = List.fold_left f base args in\nres","let key = \"\"","let prefix130 = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) =\ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")","exception TestException","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in\nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&\nrunWTimeout(testBad,0,1,5) = Fail &&\nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" &&\nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest (f,arg,out,points,name) =\nlet _ = max := !max + points in\nlet outs =\n\tmatch runWTimeout(f,arg,out,timeout) with\n\t    Pass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n\t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let explode s =\nlet rec _exp i =\nif i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n_exp 0","let implode cs =\nString.concat \"\" (List.map (String.make 1) cs)","let drop_paren s =\nimplode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))","let eq_real p (r1,r2) =\n(r1 -. r2) < p || (r2 -. r1) < p","let wrap_curried_2 f (a,b) = f a b","let runAllTests () =\nlet _ = (score := 0; max := 0) in\nlet report =\n[runTest (sqsum, [], 0, 1, \"sqsum 1\");\nrunTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\nrunTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\nrunTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\nrunTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\nrunTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\nrunTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\nrunTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\nrunTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\nrunTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\nrunTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\nrunTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\nrunTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\nrunTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\nrunTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\nrunTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\nrunTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\nrunTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\nrunTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\nrunTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\nrunTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\nrunTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\nrunTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\nrunTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n] in\nlet s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\nlet _ = List.iter print130 (report@([s])) in\n(!score,!max)","let _ = runAllTests ()","let _ = print130 (\"Compiled\"^key^\"\\n\")"],"region":{"start":0,"stop":11516},"type":"eval"},"cursor":0,"time":1.445709892304916e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXX\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*\nXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXX\nXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet sqsum xs =\n  let f a x = a + x*x in\n  let base =  0 in\n    List.fold_left f base xs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet pipe fs =\n  let f a x = fun k -> x (a k) in\n  let base = fun z -> z in\n    List.fold_left f base fs\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec sepConcat sep sl = match sl with\n  | [] -> \"\"\n  | h :: t ->\n      let f a x = if a = x then a else a ^ sep ^ x in\n      let base = h in\n      let l = t in\n        List.fold_left f base l\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet stringOfList f l = \"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec clone x n =\n  let rec helper base count =\n    if count < n\n    then helper (x::base) (count+1)\n    else base\n  in helper [] 0\n\n(*XXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n    if l1_len < l2_len\n    then ((clone 0 (l2_len - l1_len)) @ l1,  l2)\n    else (l1,  (clone 0 (l1_len - l2_len)) @ l2)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet rec removeZero l = match l with\n    [] -> []\n  | h::t -> if h < 1 then removeZero t else h::t\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigAdd l1 l2 =\n  let add (l1, l2) =\n\n    let f a x =\n      (\n        (*XXXXXXX*)\n        let (carryIn, sumList) = a           in\n        let (ai, bi) = x                     in\n\n        (*XXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n        let sumList = match sumList with\n          | [] -> []\n          | h::t -> t                        in\n\n        (*XXXXXXXXXXXX*)\n        let sum      = ai+bi+carryIn in\n        let carryOut = sum / 10      in\n        let digit    = sum mod 10    in\n\n          (*XXXXXXXX*)\n          (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          (carryOut, carryOut::digit::sumList)\n      ) in\n\n    let base  = (0, []) in\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    let args =\n      (\n        let rec helper combinedList tuple = match tuple with\n            (l1h::l1t, l2h::l2t)  -> helper ((l1h,l2h)::combinedList)  (l1t, l2t)\n          | (_, _) -> combinedList\n        in helper [] (l1, l2)\n      ) in\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    let (_, res) = List.fold_left f base args in\n      res\n  in\n    removeZero (add (padZero l1 l2))\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX*)\nlet rec mulByDigit i l =\n  let rec helper count sum =\n    if count < i\n    then helper (count+1) (bigAdd sum l)\n    else sum\n  in helper 1 l\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXX\nXXXX\nXXXXXXXXXXXX*)\n   let (carryIn, sumList) = a   in\n\n   (*XXXXXXXXXXXXXXXXXXXXXXX*)\n   let product  =  i * x  + carryIn     in\n   let carryOut = product / 10          in\n   let digit    = product mod 10        in\n\n   (*XXXXXXXX*)\n   (carryOut, digit::sumList)\n   ) in\n   let base = (0, []) in\n   let args = List.rev l in\n   let (carry, res) = List.fold_left f base args in\n   carry::res\n   in\n   removeZero (mul i l)\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\nlet bigMul l1 l2 =\n  let f a x =\n    (\n      (*XXXXXXX*)\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let (nth, res) = a in\n(*\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n      let product_i = mulByDigit nth (mulByDigit x l1) in\n\n        (*XXXXX*)\n        (*XXXXXXXXXXXXXXXXXXXXXXXX*)\n        (nth*10, bigAdd res product_i)\n    ) in\n  let base = (1, []) in\n\n  (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n  let args =\n    (\n      let rec helper res lst = match lst with\n          []   -> res\n        | h::t -> helper (h::res) t\n      in helper [] l2\n    ) in\n\n  let (_, res) = List.fold_left f base args in\n    res\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet key = \"\" (*XXXXXXXX*)\nlet prefix130 = \"130\" (*XXXXXXXX*)\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) =\n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)^\"\\n\"); ErrorCode \"exception\")\n\nexception TestException\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in\n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&\n    runWTimeout(testBad,0,1,5) = Fail &&\n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" &&\n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\n\nlet runTest (f,arg,out,points,name) =\n  let _ = max := !max + points in\n  let outs =\n    \tmatch runWTimeout(f,arg,out,timeout) with\n        \t    Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      \t  | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet explode s =\n  let rec _exp i =\n    if i >= String.length s then [] else (s.[i])::(_exp (i+1)) in\n    _exp 0\n\nlet implode cs =\n  String.concat \"\" (List.map (String.make 1) cs)\n\nlet drop_paren s =\n  implode (List.filter (fun c -> not (List.mem c ['(';' ';')'])) (explode s))\n\nlet eq_real p (r1,r2) =\n  (r1 -. r2) < p || (r2 -. r1) < p\n\nlet wrap_curried_2 f (a,b) = f a b\n\nlet runAllTests () =\n  let _ = (score := 0; max := 0) in\n  let report =\n    [runTest (sqsum, [], 0, 1, \"sqsum 1\");\n     runTest (sqsum, [1;2;3;4], 30, 1, \"sqsum 2\");\n     runTest (sqsum, [-1;-2;-3;-4], 30, 1, \"sqsum 3\");\n\n     runTest (wrap_curried_2 pipe, ([], 3), 3, 1, \"pipe 1\");\n     runTest (wrap_curried_2 pipe, ([(fun x-> 2*x);(fun x -> x + 3)], 3), 9, 1, \"pipe 2\");\n     runTest (wrap_curried_2 pipe, ([(fun x -> x + 3); (fun x-> 2*x)], 3), 12, 1, \"pipe 3\");\n\n     runTest(wrap_curried_2 sepConcat, (\", \",[\"foo\";\"bar\";\"baz\"]), \"foo, bar, baz\", 1, \"sepConcat 1\");\n     runTest(wrap_curried_2 sepConcat, (\"---\",[]), \"\", 1, \"sepConcat 2\");\n     runTest(wrap_curried_2 sepConcat, (\"\",[\"a\";\"b\";\"c\";\"d\";\"e\"]), \"abcde\", 1, \"sepConcat 3\");\n     runTest(wrap_curried_2 sepConcat, (\"X\",[\"hello\"]), \"hello\", 1, \"sepConcat 4\");\n\n     runTest(wrap_curried_2 stringOfList, (string_of_int,[1;2;3;4;5;6]), \"[1; 2; 3; 4; 5; 6]\",1,\"stringOfList 1\");\n     runTest(wrap_curried_2 stringOfList, ((fun x -> x),[\"foo\"]), \"[foo]\",1,\"stringOfList 2\");\n     runTest(wrap_curried_2 stringOfList, ((stringOfList string_of_int),[[1;2;3];[4;5];[6];[]]), \"[[1; 2; 3]; [4; 5]; [6]; []]\",1,\"stringOfList 3\");\n\n     runTest(wrap_curried_2 clone, (3,5), [3;3;3;3;3],1,\"clone 1\");\n     runTest(wrap_curried_2 clone, (\"foo\",2), [\"foo\";\"foo\"],1,\"clone 2\");\n     runTest(wrap_curried_2 clone, (clone,-3), [],1,\"clone 3\");\n\n     runTest(wrap_curried_2 padZero, ([9;9],[1;0;0;2]), ([0;0;9;9],[1;0;0;2]),1,\"padzero 1\");\n     runTest(wrap_curried_2 padZero, ([1;0;0;2],[9;9]), ([1;0;0;2],[0;0;9;9]),1,\"padzero 2\");\n\n     runTest(removeZero, [0;0;0;1;0;0;2], [1;0;0;2],1,\"removeZero 1\");\n     runTest(removeZero, [9;9], [9;9],1,\"removeZero 2\");\n\n     runTest(wrap_curried_2 bigAdd,  ([9;9],[1;0;0;2]), [1;1;0;1],1, \"bigAdd 1\");\n     runTest(wrap_curried_2 bigAdd,  ([9;9;9;9],[9;9;9]), [1;0;9;9;8],1, \"bigAdd 2\");\n\n     runTest(wrap_curried_2 mulByDigit,  (9,[9;9;9;9]), [8;9;9;9;1],1, \"mulByDigit 1\");\n\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9],[9;9;9;9]), [9;9;9;8;0;0;0;1],1, \"bigMul 1\");\n     runTest(wrap_curried_2 bigMul,  ([9;9;9;9;9],[9;9;9;9;9]), [9;9;9;9;8;0;0;0;0;1],1,\"bigMul 2\");\n    ] in\n  let s = Format.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max in\n  let _ = List.iter print130 (report@([s])) in\n    (!score,!max)\n\nlet _ = runAllTests ()\n\nlet _ = print130 (\"Compiled\"^key^\"\\n\")\n","file":"hw3.ml"}
