{"ocaml":[{"in":"let rec sumList xs = failwith \"TBD:sumList\"","min":"\nlet rec sumList xs = failwith \"TBD:sumList\";;\n","type":"","out":""},{"in":"let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = failwith \"TBD:sumList\"","let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","let digits n = digitsOfInt (abs n)","let rec additivePersistence n = failwith \"TBD\"","let rec digitalRoot n = failwith \"TBD\"","let rec listReverse l = failwith \"TBD\"","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w = failwith \"TBD\"","type test = unit -> string","let key        = \"\"","let prefix130  = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let doTest f = \ntry f () with ex -> \nPrintf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let sampleTests =\n[\n(fun () -> mkTest\nsumList\n[1;2;3;4]\n10\n\"sample: sumList 1\"\n);\n(fun () -> mkTest \nsumList \n[1;-2;3;5] \n7 \n\"sample: sumList 2\"\n); \n(fun () -> mkTest \nsumList \n[1;3;5;7;9;11]\n36 \n\"sample: sumList 3\"\n); \n(fun () -> mkTest \ndigitsOfInt \n3124 \n[3;1;2;4] \n\"sample: digitsOfInt 1\"\n); \n(fun () -> mkTest \ndigitsOfInt \n352663 \n[3;5;2;6;6;3] \n\"sample: digitsOfInt 2\"\n); \n(fun () -> mkTest \ndigits\n31243\n[3;1;2;4;3] \n\"sample: digits 1\"\n); \n(fun () -> mkTest \ndigits\n(-23422)\n[2;3;4;2;2]\n\"sample: digits 2\"\n); \n(fun () -> mkTest \nadditivePersistence \n9876 \n2 \n\"sample: additivePersistence1\"\n); \n(fun () -> mkTest \ndigitalRoot \n9876 \n3 \n\"sample: digitalRoot\"\n); \n(fun () -> mkTest \nlistReverse\n[1;2;3;4] \n[4;3;2;1]\n\"sample: reverse 1\"\n); \n(fun () -> mkTest \nlistReverse \n[\"a\";\"b\";\"c\";\"d\"]\n[\"d\";\"c\";\"b\";\"a\"] \n\"sample: rev 2\"\n); \n(fun () -> mkTest \npalindrome \n\"malayalam\" \ntrue\n\"sample: palindrome 1\"\n); \n(fun () -> mkTest \npalindrome \n\"myxomatosis\" \nfalse\n\"sample: palindrome 2\"\n)]","let _ =\nlet report = List.map doTest (sampleTests) in\nlet _ = List.iter print130 (report@([scoreMsg()])) in\nlet _ = print130 (\"Compiled\\n\") in\n(!score, !max)"],"region":{"start":0,"stop":5547},"type":"eval"},"cursor":127,"time":1.443828772248625e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = failwith \"TBD:sumList\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh + sumList t","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n","type":"type","out":"Characters 61-70:\n  h + sumList t;;\n      ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"},{"in":"let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh + sumList t","let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","let digits n = digitsOfInt (abs n)","let rec additivePersistence n = failwith \"TBD\"","let rec digitalRoot n = failwith \"TBD\"","let rec listReverse l = failwith \"TBD\"","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w = failwith \"TBD\"","type test = unit -> string","let key        = \"\"","let prefix130  = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let doTest f = \ntry f () with ex -> \nPrintf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let sampleTests =\n[\n(fun () -> mkTest\nsumList\n[1;2;3;4]\n10\n\"sample: sumList 1\"\n);\n(fun () -> mkTest \nsumList \n[1;-2;3;5] \n7 \n\"sample: sumList 2\"\n); \n(fun () -> mkTest \nsumList \n[1;3;5;7;9;11]\n36 \n\"sample: sumList 3\"\n); \n(fun () -> mkTest \ndigitsOfInt \n3124 \n[3;1;2;4] \n\"sample: digitsOfInt 1\"\n); \n(fun () -> mkTest \ndigitsOfInt \n352663 \n[3;5;2;6;6;3] \n\"sample: digitsOfInt 2\"\n); \n(fun () -> mkTest \ndigits\n31243\n[3;1;2;4;3] \n\"sample: digits 1\"\n); \n(fun () -> mkTest \ndigits\n(-23422)\n[2;3;4;2;2]\n\"sample: digits 2\"\n); \n(fun () -> mkTest \nadditivePersistence \n9876 \n2 \n\"sample: additivePersistence1\"\n); \n(fun () -> mkTest \ndigitalRoot \n9876 \n3 \n\"sample: digitalRoot\"\n); \n(fun () -> mkTest \nlistReverse\n[1;2;3;4] \n[4;3;2;1]\n\"sample: reverse 1\"\n); \n(fun () -> mkTest \nlistReverse \n[\"a\";\"b\";\"c\";\"d\"]\n[\"d\";\"c\";\"b\";\"a\"] \n\"sample: rev 2\"\n); \n(fun () -> mkTest \npalindrome \n\"malayalam\" \ntrue\n\"sample: palindrome 1\"\n); \n(fun () -> mkTest \npalindrome \n\"myxomatosis\" \nfalse\n\"sample: palindrome 2\"\n)]","let _ =\nlet report = List.map doTest (sampleTests) in\nlet _ = List.iter print130 (report@([scoreMsg()])) in\nlet _ = print130 (\"Compiled\\n\") in\n(!score, !max)"],"region":{"start":0,"stop":5576},"type":"eval"},"cursor":156,"time":1.443829258587585e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        h + sumList t;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh + sumList t","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n","type":"type","out":"Characters 61-70:\n  h + sumList t;;\n      ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh + sumList t"],"region":{"start":0,"stop":154},"type":"eval"},"cursor":140,"time":1.444069943178804e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        h + sumList t;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nhd xs","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> hd xs;;\n","type":"scope","out":"Characters 57-59:\n  hd xs;;\n  ^^\nError: Unbound value hd\n"}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nhd xs"],"region":{"start":0,"stop":146},"type":"eval"},"cursor":146,"time":1.444069999821657e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        hd xs\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nhd [xs]","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> hd [xs];;\n","type":"scope","out":"Characters 57-59:\n  hd [xs];;\n  ^^\nError: Unbound value hd\n"}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nhd [xs]"],"region":{"start":0,"stop":148},"type":"eval"},"cursor":148,"time":1.444070018727081e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        hd [xs]\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\n(hd [xs])","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> hd [xs];;\n","type":"scope","out":"Characters 58-60:\n  (hd [xs]);;\n   ^^\nError: Unbound value hd\n"}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\n(hd [xs])"],"region":{"start":0,"stop":150},"type":"eval"},"cursor":142,"time":1.444070029586758e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        (hd [xs])\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\n(hd [xs])","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> hd [xs];;\n","type":"scope","out":"Characters 58-60:\n  (hd [xs]);;\n   ^^\nError: Unbound value hd\n"}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\n(hd [xs])"],"region":{"start":0,"stop":150},"type":"eval"},"cursor":142,"time":1.444070030579046e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        (hd [xs])\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h;;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh"],"region":{"start":0,"stop":142},"type":"eval"},"cursor":144,"time":1.444070118264638e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        h;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\n2+2","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> 2 + 2;;\n","type":"type","out":"Characters 57-60:\n  2+2;;\n  ^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\n2+2"],"region":{"start":0,"stop":144},"type":"eval"},"cursor":146,"time":1.444070143316429e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        2+2;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h;;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh"],"region":{"start":0,"stop":142},"type":"eval"},"cursor":144,"time":1.44407015333634e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        h;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h;;\n","type":"","out":""},{"in":"let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh","let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","let digits n = digitsOfInt (abs n)","let rec additivePersistence n = failwith \"TBD\"","let rec digitalRoot n = failwith \"TBD\"","let rec listReverse l = failwith \"TBD\"","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w = failwith \"TBD\"","type test = unit -> string","let key        = \"\"","let prefix130  = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let doTest f = \ntry f () with ex -> \nPrintf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let sampleTests =\n[\n(fun () -> mkTest\nsumList\n[1;2;3;4]\n10\n\"sample: sumList 1\"\n);\n(fun () -> mkTest \nsumList \n[1;-2;3;5] \n7 \n\"sample: sumList 2\"\n); \n(fun () -> mkTest \nsumList \n[1;3;5;7;9;11]\n36 \n\"sample: sumList 3\"\n); \n(fun () -> mkTest \ndigitsOfInt \n3124 \n[3;1;2;4] \n\"sample: digitsOfInt 1\"\n); \n(fun () -> mkTest \ndigitsOfInt \n352663 \n[3;5;2;6;6;3] \n\"sample: digitsOfInt 2\"\n); \n(fun () -> mkTest \ndigits\n31243\n[3;1;2;4;3] \n\"sample: digits 1\"\n); \n(fun () -> mkTest \ndigits\n(-23422)\n[2;3;4;2;2]\n\"sample: digits 2\"\n); \n(fun () -> mkTest \nadditivePersistence \n9876 \n2 \n\"sample: additivePersistence1\"\n); \n(fun () -> mkTest \ndigitalRoot \n9876 \n3 \n\"sample: digitalRoot\"\n); \n(fun () -> mkTest \nlistReverse\n[1;2;3;4] \n[4;3;2;1]\n\"sample: reverse 1\"\n); \n(fun () -> mkTest \nlistReverse \n[\"a\";\"b\";\"c\";\"d\"]\n[\"d\";\"c\";\"b\";\"a\"] \n\"sample: rev 2\"\n); \n(fun () -> mkTest \npalindrome \n\"malayalam\" \ntrue\n\"sample: palindrome 1\"\n); \n(fun () -> mkTest \npalindrome \n\"myxomatosis\" \nfalse\n\"sample: palindrome 2\"\n)]","let _ =\nlet report = List.map doTest (sampleTests) in\nlet _ = List.iter print130 (report@([scoreMsg()])) in\nlet _ = print130 (\"Compiled\\n\") in\n(!score, !max)"],"region":{"start":84,"stop":5564},"type":"eval"},"cursor":301,"time":1.444070163939339e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        h;;\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"( \n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n)","min":"","type":"syntax","out":"Characters 33-36:\n  let _ = sumList [1; -2; 3; 5]\n  ^^^\nError: Syntax error: operator expected.\n"}],"event":{"phrases":["","( \n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n)"],"region":{"start":142,"stop":247},"type":"eval"},"cursor":148,"time":1.444070200038579e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        h;;\n\n( \n\n  let _ = sumList [1; 2; 3; 4]\n  let _ = sumList [1; -2; 3; 5]\n  let _ = sumList [1; 3; 5; 7; 9; 11]\n\n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"( \n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n)","min":"","type":"syntax","out":"Characters 33-36:\n  let _ = sumList [1; -2; 3; 5]\n  ^^^\nError: Syntax error: operator expected.\n"}],"event":{"phrases":["","( \n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n)"],"region":{"start":142,"stop":247},"type":"eval"},"cursor":148,"time":1.444070201429421e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        h;;\n\n( \n\n  let _ = sumList [1; 2; 3; 4]\n  let _ = sumList [1; -2; 3; 5]\n  let _ = sumList [1; 3; 5; 7; 9; 11]\n\n)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h;;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh"],"region":{"start":84,"stop":142},"type":"eval"},"cursor":105,"time":1.444070210738883e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        h;;\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h;;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh"],"region":{"start":84,"stop":142},"type":"eval"},"cursor":105,"time":1.444070212238224e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        h;;\n\n\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh + sumList","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + sumList;;\n","type":"type","out":"Characters 61-68:\n  h + sumList;;\n      ^^^^^^^\nError: This expression has type int list -> 'a list\n       but an expression was expected of type int\n"}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh + sumList"],"region":{"start":0,"stop":152},"type":"eval"},"cursor":152,"time":1.444070231912863e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        h + sumList\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh + sumList(xs)","min":"\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList xs);;\n","type":"type","out":"Characters 61-72:\n  h + sumList(xs);;\n      ^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> []\n| h::t ->\nh + sumList(xs)"],"region":{"start":0,"stop":156},"type":"eval"},"cursor":156,"time":1.444070239660926e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> []\n    | h::t ->\n        h + sumList(xs)\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList xs","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList xs"],"region":{"start":0,"stop":154},"type":"eval"},"cursor":154,"time":1.444070264354817e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList xs\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList xs","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList xs"],"region":{"start":84,"stop":154},"type":"eval"},"cursor":154,"time":1.444070266310395e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList xs\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let _ = sumList [1; 2; 3; 4]","let _ = sumList [1; -2; 3; 5]","let _ = sumList [1; 3; 5; 7; 9; 11]","let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","let digits n = digitsOfInt (abs n)","let rec additivePersistence n = failwith \"TBD\"","let rec digitalRoot n = failwith \"TBD\"","let rec listReverse l = failwith \"TBD\"","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w = failwith \"TBD\"","type test = unit -> string","let key        = \"\"","let prefix130  = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let doTest f = \ntry f () with ex -> \nPrintf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let sampleTests =\n[\n(fun () -> mkTest\nsumList\n[1;2;3;4]\n10\n\"sample: sumList 1\"\n);\n(fun () -> mkTest \nsumList \n[1;-2;3;5] \n7 \n\"sample: sumList 2\"\n); \n(fun () -> mkTest \nsumList \n[1;3;5;7;9;11]\n36 \n\"sample: sumList 3\"\n); \n(fun () -> mkTest \ndigitsOfInt \n3124 \n[3;1;2;4] \n\"sample: digitsOfInt 1\"\n); \n(fun () -> mkTest \ndigitsOfInt \n352663 \n[3;5;2;6;6;3] \n\"sample: digitsOfInt 2\"\n); \n(fun () -> mkTest \ndigits\n31243\n[3;1;2;4;3] \n\"sample: digits 1\"\n); \n(fun () -> mkTest \ndigits\n(-23422)\n[2;3;4;2;2]\n\"sample: digits 2\"\n); \n(fun () -> mkTest \nadditivePersistence \n9876 \n2 \n\"sample: additivePersistence1\"\n); \n(fun () -> mkTest \ndigitalRoot \n9876 \n3 \n\"sample: digitalRoot\"\n); \n(fun () -> mkTest \nlistReverse\n[1;2;3;4] \n[4;3;2;1]\n\"sample: reverse 1\"\n); \n(fun () -> mkTest \nlistReverse \n[\"a\";\"b\";\"c\";\"d\"]\n[\"d\";\"c\";\"b\";\"a\"] \n\"sample: rev 2\"\n); \n(fun () -> mkTest \npalindrome \n\"malayalam\" \ntrue\n\"sample: palindrome 1\"\n); \n(fun () -> mkTest \npalindrome \n\"myxomatosis\" \nfalse\n\"sample: palindrome 2\"\n)]","let _ =\nlet report = List.map doTest (sampleTests) in\nlet _ = List.iter print130 (report@([scoreMsg()])) in\nlet _ = print130 (\"Compiled\\n\") in\n(!score, !max)"],"region":{"start":154,"stop":5514},"type":"eval"},"cursor":246,"time":1.444070269859056e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList xs\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList xs","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList xs"],"region":{"start":84,"stop":154},"type":"eval"},"cursor":154,"time":1.444070308291408e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList xs\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList xs","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList xs"],"region":{"start":84,"stop":154},"type":"eval"},"cursor":154,"time":1.444070310021768e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList xs\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList xs);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"phrases":["","let _ = sumList [1; 2; 3; 4]","let _ = sumList [1; -2; 3; 5]","let _ = sumList [1; 3; 5; 7; 9; 11]"],"region":{"start":154,"stop":250},"type":"eval"},"cursor":252,"time":1.444070317702314e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList xs\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList h:xs","min":"","type":"syntax","out":"Characters 69-70:\n  h + sumList h:xs;;\n               ^\nError: Syntax error\n"}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList h:xs"],"region":{"start":0,"stop":156},"type":"eval"},"cursor":154,"time":1.444070439205935e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList h:xs\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList hd h:xs","min":"","type":"syntax","out":"Characters 72-73:\n  h + sumList hd h:xs;;\n                  ^\nError: Syntax error\n"}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList hd h:xs"],"region":{"start":0,"stop":159},"type":"eval"},"cursor":157,"time":1.444070448628694e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList hd h:xs\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList t","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList t","let _ = sumList [1; 2; 3; 4]","let _ = sumList [1; -2; 3; 5]","let _ = sumList [1; 3; 5; 7; 9; 11]"],"region":{"start":0,"stop":249},"type":"eval"},"cursor":251,"time":1.444070482533078e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let _ = sumList [1; 3; 5; 7; 9; 11]","let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"","let digits n = digitsOfInt (abs n)","let rec additivePersistence n = failwith \"TBD\"","let rec digitalRoot n = failwith \"TBD\"","let rec listReverse l = failwith \"TBD\"","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w = failwith \"TBD\"","type test = unit -> string","let key        = \"\"","let prefix130  = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let doTest f = \ntry f () with ex -> \nPrintf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let sampleTests =\n[\n(fun () -> mkTest\nsumList\n[1;2;3;4]\n10\n\"sample: sumList 1\"\n);\n(fun () -> mkTest \nsumList \n[1;-2;3;5] \n7 \n\"sample: sumList 2\"\n); \n(fun () -> mkTest \nsumList \n[1;3;5;7;9;11]\n36 \n\"sample: sumList 3\"\n); \n(fun () -> mkTest \ndigitsOfInt \n3124 \n[3;1;2;4] \n\"sample: digitsOfInt 1\"\n); \n(fun () -> mkTest \ndigitsOfInt \n352663 \n[3;5;2;6;6;3] \n\"sample: digitsOfInt 2\"\n); \n(fun () -> mkTest \ndigits\n31243\n[3;1;2;4;3] \n\"sample: digits 1\"\n); \n(fun () -> mkTest \ndigits\n(-23422)\n[2;3;4;2;2]\n\"sample: digits 2\"\n); \n(fun () -> mkTest \nadditivePersistence \n9876 \n2 \n\"sample: additivePersistence1\"\n); \n(fun () -> mkTest \ndigitalRoot \n9876 \n3 \n\"sample: digitalRoot\"\n); \n(fun () -> mkTest \nlistReverse\n[1;2;3;4] \n[4;3;2;1]\n\"sample: reverse 1\"\n); \n(fun () -> mkTest \nlistReverse \n[\"a\";\"b\";\"c\";\"d\"]\n[\"d\";\"c\";\"b\";\"a\"] \n\"sample: rev 2\"\n); \n(fun () -> mkTest \npalindrome \n\"malayalam\" \ntrue\n\"sample: palindrome 1\"\n); \n(fun () -> mkTest \npalindrome \n\"myxomatosis\" \nfalse\n\"sample: palindrome 2\"\n)]","let _ =\nlet report = List.map doTest (sampleTests) in\nlet _ = List.iter print130 (report@([scoreMsg()])) in\nlet _ = print130 (\"Compiled\\n\") in\n(!score, !max)"],"region":{"start":214,"stop":5513},"type":"eval"},"cursor":251,"time":1.444070492069313e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nfun n ->\nn mod 10::[]","min":"\nlet rec digitsOfInt n n = [n mod 10];;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nfun n ->\nn mod 10::[]"],"region":{"start":249,"stop":492},"type":"eval"},"cursor":480,"time":1.44407136012688e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun n ->\n    n mod 10::[] \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nfun n ->\nn mod 10::[]","min":"\nlet rec digitsOfInt n n = [n mod 10];;\n","type":"","out":""}],"event":{"phrases":["let rec digitsOfInt n = \nfun n ->\nn mod 10::[]"],"region":{"start":446,"stop":492},"type":"eval"},"cursor":495,"time":1.444071363684029e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun n ->\n    n mod 10::[] \n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n n = [n mod 10];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n n = [n mod 10];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":492,"stop":547},"type":"eval"},"cursor":548,"time":1.444071376196751e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun n ->\n    n mod 10::[] \n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nfun x ->\nn mod 10::[]","min":"\nlet rec digitsOfInt n x = [n mod 10];;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nfun x ->\nn mod 10::[]"],"region":{"start":249,"stop":492},"type":"eval"},"cursor":476,"time":1.444071396507653e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    n mod 10::[] \n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n x = [n mod 10];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n x = [n mod 10];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":492,"stop":547},"type":"eval"},"cursor":548,"time":1.444071400765155e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    n mod 10::[] \n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nfun x ->\nx mod 10::[]","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nfun x ->\nx mod 10::[]"],"region":{"start":249,"stop":492},"type":"eval"},"cursor":482,"time":1.444071482037398e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x mod 10::[]\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":492,"stop":546},"type":"eval"},"cursor":547,"time":1.444071488607727e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x mod 10::[]\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nn","min":"\nlet rec digitsOfInt n = n;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n = n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n = n;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nn","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":249,"stop":528},"type":"eval"},"cursor":529,"time":1.444071560233288e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  n;;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList t","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList t"],"region":{"start":84,"stop":153},"type":"eval"},"cursor":155,"time":1.444071577878727e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    xmod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nfun x ->\nxmod 10::[]","min":"\nlet rec digitsOfInt n x = [xmod 10];;\n","type":"scope","out":"Characters 34-38:\n  xmod 10::[];;\n  ^^^^\nError: Unbound value xmod\n"},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n = n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n = n;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let _ = sumList [1; 2; 3; 4]","let _ = sumList [1; -2; 3; 5]","let _ = sumList [1; 3; 5; 7; 9; 11]","let rec digitsOfInt n = \nfun x ->\nxmod 10::[]","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":153,"stop":549},"type":"eval"},"cursor":549,"time":1.444071582112748e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    xmod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nfun x ->\nx mod 10::[]","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nfun x ->\nx mod 10::[]","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":251,"stop":550},"type":"eval"},"cursor":552,"time":1.444071596944759e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"phrases":["let _ = sumList [1; 3; 5; 7; 9; 11]"],"region":{"start":216,"stop":251},"type":"eval"},"cursor":252,"time":1.444071608460532e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"phrases":["let _ = sumList [1; 3; 5; 7; 9; 11]"],"region":{"start":216,"stop":251},"type":"eval"},"cursor":252,"time":1.444071611535191e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"phrases":["let _ = sumList [1; 3; 5; 7; 9; 11]"],"region":{"start":216,"stop":251},"type":"eval"},"cursor":252,"time":1.44407161417443e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""}],"event":{"phrases":["let _ = sumList [1; 3; 5; 7; 9; 11]"],"region":{"start":216,"stop":251},"type":"eval"},"cursor":251,"time":1.444071619241182e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""}],"event":{"phrases":["let _ = sumList [1; 2; 3; 4]"],"region":{"start":157,"stop":185},"type":"eval"},"cursor":185,"time":1.444071622351817e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nfun x ->\nx mod 10::[]","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let _ = sumList [1; 2; 3; 4]","let _ = sumList [1; -2; 3; 5]","let _ = sumList [1; 3; 5; 7; 9; 11]","let rec digitsOfInt n = \nfun x ->\nx mod 10::[]","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663","let digits n = digitsOfInt (abs n)","let rec additivePersistence n = failwith \"TBD\"","let rec digitalRoot n = failwith \"TBD\"","let rec listReverse l = failwith \"TBD\"","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w = failwith \"TBD\"","type test = unit -> string","let key        = \"\"","let prefix130  = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let doTest f = \ntry f () with ex -> \nPrintf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let sampleTests =\n[\n(fun () -> mkTest\nsumList\n[1;2;3;4]\n10\n\"sample: sumList 1\"\n);\n(fun () -> mkTest \nsumList \n[1;-2;3;5] \n7 \n\"sample: sumList 2\"\n); \n(fun () -> mkTest \nsumList \n[1;3;5;7;9;11]\n36 \n\"sample: sumList 3\"\n); \n(fun () -> mkTest \ndigitsOfInt \n3124 \n[3;1;2;4] \n\"sample: digitsOfInt 1\"\n); \n(fun () -> mkTest \ndigitsOfInt \n352663 \n[3;5;2;6;6;3] \n\"sample: digitsOfInt 2\"\n); \n(fun () -> mkTest \ndigits\n31243\n[3;1;2;4;3] \n\"sample: digits 1\"\n); \n(fun () -> mkTest \ndigits\n(-23422)\n[2;3;4;2;2]\n\"sample: digits 2\"\n); \n(fun () -> mkTest \nadditivePersistence \n9876 \n2 \n\"sample: additivePersistence1\"\n); \n(fun () -> mkTest \ndigitalRoot \n9876 \n3 \n\"sample: digitalRoot\"\n); \n(fun () -> mkTest \nlistReverse\n[1;2;3;4] \n[4;3;2;1]\n\"sample: reverse 1\"\n); \n(fun () -> mkTest \nlistReverse \n[\"a\";\"b\";\"c\";\"d\"]\n[\"d\";\"c\";\"b\";\"a\"] \n\"sample: rev 2\"\n); \n(fun () -> mkTest \npalindrome \n\"malayalam\" \ntrue\n\"sample: palindrome 1\"\n); \n(fun () -> mkTest \npalindrome \n\"myxomatosis\" \nfalse\n\"sample: palindrome 2\"\n)]","let _ =\nlet report = List.map doTest (sampleTests) in\nlet _ = List.iter print130 (report@([scoreMsg()])) in\nlet _ = print130 (\"Compiled\\n\") in\n(!score, !max)"],"region":{"start":157,"stop":5447},"type":"eval"},"cursor":185,"time":1.444071628020893e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nfun x ->\nx mod 10::[]","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n","type":"","out":""}],"event":{"phrases":["let rec digitsOfInt n = \nfun x ->\nx mod 10::[]"],"region":{"start":448,"stop":494},"type":"eval"},"cursor":496,"time":1.444071678004815e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n x = [x mod 10];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":494,"stop":550},"type":"eval"},"cursor":551,"time":1.444071681141712e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nfun x ->\nx","min":"\nlet rec digitsOfInt n x = x;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nfun x ->\nx"],"region":{"start":251,"stop":483},"type":"eval"},"cursor":485,"time":1.444071686891165e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x;;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n x = x;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""}],"event":{"phrases":["","let _ = digitsOfInt 3124"],"region":{"start":483,"stop":512},"type":"eval"},"cursor":512,"time":1.444071690334991e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  fun x ->\n    x;;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nn","min":"\nlet rec digitsOfInt n = n;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n = n;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n = n;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nn","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":251,"stop":530},"type":"eval"},"cursor":530,"time":1.44407170312085e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  n;;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nn mod 10","min":"\nlet rec digitsOfInt n = n mod 10;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n = n mod 10;;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n = n mod 10;;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nn mod 10","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":251,"stop":537},"type":"eval"},"cursor":537,"time":1.444071712004756e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  n mod 10;;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nn mod 10::[]","min":"\nlet rec digitsOfInt n = [n mod 10];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n = [n mod 10];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n = [n mod 10];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nn mod 10::[]","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":251,"stop":541},"type":"eval"},"cursor":541,"time":1.444071764523773e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  n mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \ndigitsOfInt n::n mod 10::[]","min":"\nlet rec digitsOfInt n = [digitsOfInt n; n mod 10];;\n","type":"type","out":"Characters 25-38:\n  digitsOfInt n::n mod 10::[];;\n  ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}],"event":{"phrases":["","let rec digitsOfInt n = \ndigitsOfInt n::n mod 10::[]"],"region":{"start":251,"stop":500},"type":"eval"},"cursor":486,"time":1.444071798083778e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  digitsOfInt n::n mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nif (n > 0) then n mod 10::[]","min":"\nlet rec digitsOfInt n = if n > 0 then [n mod 10];;\n","type":"type","out":"Characters 49-51:\n  if (n > 0) then n mod 10::[];;\n                          ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n = [n mod 10];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n = [n mod 10];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nif (n > 0) then n mod 10::[]","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":251,"stop":557},"type":"eval"},"cursor":558,"time":1.44407193196313e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then n mod 10::[];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nif (n > 0) then n mod 10::[] else []","min":"\nlet rec digitsOfInt n = if n > 0 then [n mod 10] else [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n = if n > 0 then [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n = if n > 0 then [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nif (n > 0) then n mod 10::[] else []","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":251,"stop":565},"type":"eval"},"cursor":566,"time":1.444071957310409e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then n mod 10::[] else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n mod 10)::[] \nelse []","min":"\nlet rec digitsOfInt n = if n > 0 then [digitsOfInt (n mod 10)] else [];;\n","type":"type","out":"Characters 41-62:\n  if (n > 0) then digitsOfInt(n mod 10)::[] \n                  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n = if n > 0 then [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n = if n > 0 then [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n mod 10)::[] \nelse []","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":251,"stop":579},"type":"eval"},"cursor":579,"time":1.444072028879273e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n mod 10)::[] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n mod 10)::[n mod 10] \nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then [digitsOfInt (n mod 10); n mod 10] else [];;\n","type":"type","out":"Characters 41-62:\n  if (n > 0) then digitsOfInt(n mod 10)::[n mod 10] \n                  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}],"event":{"phrases":["","let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n mod 10)::[n mod 10] \nelse []"],"region":{"start":251,"stop":531},"type":"eval"},"cursor":521,"time":1.444072050390382e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n mod 10)::[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nif (n > 0) then n mod 100::[n mod 10] \nelse []","min":"\nlet rec digitsOfInt n = if n > 0 then [n mod 100; n mod 10] else [];;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nif (n > 0) then n mod 100::[n mod 10] \nelse []"],"region":{"start":251,"stop":519},"type":"eval"},"cursor":498,"time":1.444072105380747e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then n mod 100::[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n = if n > 0 then [n mod 100; n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n = if n > 0 then [n mod 100; n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":519,"stop":575},"type":"eval"},"cursor":575,"time":1.444072109774608e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then n mod 100::[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nif (n > 0) then n mod 10 mod 10::[n mod 10] \nelse []","min":"\nlet rec digitsOfInt n = if n > 0 then [(n mod 10) mod 10; n mod 10] else [];;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nif (n > 0) then n mod 10 mod 10::[n mod 10] \nelse []"],"region":{"start":251,"stop":525},"type":"eval"},"cursor":504,"time":1.444072235799678e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then n mod 10 mod 10::[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n = if n > 0 then [(n mod 10) mod 10; n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""}],"event":{"phrases":["","let _ = digitsOfInt 3124"],"region":{"start":525,"stop":554},"type":"eval"},"cursor":554,"time":1.444072239550847e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then n mod 10 mod 10::[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)::[n mod 10] \nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then [digitsOfInt (n / 10); n mod 10] else [];;\n","type":"type","out":"Characters 41-58:\n  if (n > 0) then digitsOfInt(n/10)::[n mod 10] \n                  ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}],"event":{"phrases":["","let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)::[n mod 10] \nelse []"],"region":{"start":251,"stop":527},"type":"eval"},"cursor":506,"time":1.444072275007532e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)::[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nif (n > 0) then n/10::[n mod 10] \nelse []","min":"\nlet rec digitsOfInt n = if n > 0 then [n / 10; n mod 10] else [];;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nif (n > 0) then n/10::[n mod 10] \nelse []"],"region":{"start":251,"stop":514},"type":"eval"},"cursor":493,"time":1.444072281313828e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then n/10::[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n = if n > 0 then [n / 10; n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""}],"event":{"phrases":["","let _ = digitsOfInt 3124"],"region":{"start":514,"stop":543},"type":"eval"},"cursor":543,"time":1.444072284312587e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then n/10::[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)@[n mod 10] \nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)@[n mod 10] \nelse []","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663"],"region":{"start":251,"stop":583},"type":"eval"},"cursor":583,"time":1.444072427067939e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""}],"event":{"phrases":["","let digits n = digitsOfInt (abs n)"],"region":{"start":583,"stop":809},"type":"eval"},"cursor":810,"time":1.444072590960948e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)@[n mod 10] \nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = failwith \"TBD\"","min":"\nlet rec additivePersistence n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec digitalRoot n = failwith \"TBD\"","min":"\nlet rec digitalRoot n = failwith \"TBD\";;\n","type":"","out":""},{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let _ = sumList [1; 3; 5; 7; 9; 11]","let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)@[n mod 10] \nelse []","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663","let digits n = digitsOfInt (abs n)","let rec additivePersistence n = failwith \"TBD\"","let rec digitalRoot n = failwith \"TBD\"","let rec listReverse l = failwith \"TBD\"","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w = failwith \"TBD\"","type test = unit -> string","let key        = \"\"","let prefix130  = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let doTest f = \ntry f () with ex -> \nPrintf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let sampleTests =\n[\n(fun () -> mkTest\nsumList\n[1;2;3;4]\n10\n\"sample: sumList 1\"\n);\n(fun () -> mkTest \nsumList \n[1;-2;3;5] \n7 \n\"sample: sumList 2\"\n); \n(fun () -> mkTest \nsumList \n[1;3;5;7;9;11]\n36 \n\"sample: sumList 3\"\n); \n(fun () -> mkTest \ndigitsOfInt \n3124 \n[3;1;2;4] \n\"sample: digitsOfInt 1\"\n); \n(fun () -> mkTest \ndigitsOfInt \n352663 \n[3;5;2;6;6;3] \n\"sample: digitsOfInt 2\"\n); \n(fun () -> mkTest \ndigits\n31243\n[3;1;2;4;3] \n\"sample: digits 1\"\n); \n(fun () -> mkTest \ndigits\n(-23422)\n[2;3;4;2;2]\n\"sample: digits 2\"\n); \n(fun () -> mkTest \nadditivePersistence \n9876 \n2 \n\"sample: additivePersistence1\"\n); \n(fun () -> mkTest \ndigitalRoot \n9876 \n3 \n\"sample: digitalRoot\"\n); \n(fun () -> mkTest \nlistReverse\n[1;2;3;4] \n[4;3;2;1]\n\"sample: reverse 1\"\n); \n(fun () -> mkTest \nlistReverse \n[\"a\";\"b\";\"c\";\"d\"]\n[\"d\";\"c\";\"b\";\"a\"] \n\"sample: rev 2\"\n); \n(fun () -> mkTest \npalindrome \n\"malayalam\" \ntrue\n\"sample: palindrome 1\"\n); \n(fun () -> mkTest \npalindrome \n\"myxomatosis\" \nfalse\n\"sample: palindrome 2\"\n)]","let _ =\nlet report = List.map doTest (sampleTests) in\nlet _ = List.iter print130 (report@([scoreMsg()])) in\nlet _ = print130 (\"Compiled\\n\") in\n(!score, !max)"],"region":{"start":216,"stop":5480},"type":"eval"},"cursor":233,"time":1.44407260582498e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\nlet rec additivePersistence n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList t","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)@[n mod 10] \nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nn mod 10 + additivePersistence n/10","min":"\nlet rec additivePersistence n = (n mod 10) + ((additivePersistence n) / 10);;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList t","let _ = sumList [1; 2; 3; 4]","let _ = sumList [1; -2; 3; 5]","let _ = sumList [1; 3; 5; 7; 9; 11]","let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)@[n mod 10] \nelse []","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663","let digits n = digitsOfInt (abs n)","let rec additivePersistence n = \nn mod 10 + additivePersistence n/10"],"region":{"start":0,"stop":1537},"type":"eval"},"cursor":1609,"time":1.444170079998655e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  n mod 10 + additivePersistence n/10\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nn mod 10 + additivePersistence n/10","min":"\nlet rec additivePersistence n = (n mod 10) + ((additivePersistence n) / 10);;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec additivePersistence n = (n mod 10) + ((additivePersistence n) / 10);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"phrases":["","let rec additivePersistence n = \nn mod 10 + additivePersistence n/10","let _ = additivePersistence 9876"],"region":{"start":809,"stop":1571},"type":"eval"},"cursor":1573,"time":1.444170096804274e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  n mod 10 + additivePersistence n/10\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nif n > 0 then n mod 10 + additivePersistence n/10","min":"\nlet rec additivePersistence n =\n  if n > 0 then (n mod 10) + ((additivePersistence n) / 10);;\n","type":"type","out":"Characters 47-82:\n  if n > 0 then n mod 10 + additivePersistence n/10;;\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n"}],"event":{"phrases":["","let rec additivePersistence n = \nif n > 0 then n mod 10 + additivePersistence n/10"],"region":{"start":809,"stop":1551},"type":"eval"},"cursor":1552,"time":1.444170121753009e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  if n > 0 then n mod 10 + additivePersistence n/10\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nif n > 0 then (n mod 10 + additivePersistence n/10)","min":"\nlet rec additivePersistence n =\n  if n > 0 then (n mod 10) + ((additivePersistence n) / 10);;\n","type":"type","out":"Characters 47-84:\n  if n > 0 then (n mod 10 + additivePersistence n/10);;\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n"},{"in":"let _ = additivePersistence 9876","min":"\nlet rec additivePersistence n = (n mod 10) + ((additivePersistence n) / 10);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"phrases":["","let rec additivePersistence n = \nif n > 0 then (n mod 10 + additivePersistence n/10)","let _ = additivePersistence 9876"],"region":{"start":809,"stop":1587},"type":"eval"},"cursor":1588,"time":1.444170133437186e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  if n > 0 then (n mod 10 + additivePersistence n/10)\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nif (n > 0) then (n mod 10 + additivePersistence n/10)","min":"\nlet rec additivePersistence n =\n  if n > 0 then (n mod 10) + ((additivePersistence n) / 10);;\n","type":"type","out":"Characters 49-86:\n  if (n > 0) then (n mod 10 + additivePersistence n/10);;\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n"}],"event":{"phrases":["","let rec additivePersistence n = \nif (n > 0) then (n mod 10 + additivePersistence n/10)"],"region":{"start":809,"stop":1555},"type":"eval"},"cursor":1506,"time":1.444170149755568e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  if (n > 0) then (n mod 10 + additivePersistence n/10)\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet x = digits n","min":"","type":"syntax","out":"Characters 49-51:\n  let x = digits n;;\n                  ^^\nError: Syntax error\n"}],"event":{"phrases":["","let rec additivePersistence n = \nlet x = digits n"],"region":{"start":809,"stop":1518},"type":"eval"},"cursor":1519,"time":1.444170192110835e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = digits n\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet x = digits n","min":"","type":"syntax","out":"Characters 49-51:\n  let x = digits n;;\n                  ^^\nError: Syntax error\n"}],"event":{"phrases":["","let rec additivePersistence n = \nlet x = digits n"],"region":{"start":809,"stop":1518},"type":"eval"},"cursor":1520,"time":1.444170198374509e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = digits n;;\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet x = digits n","min":"","type":"syntax","out":"Characters 49-51:\n  let x = digits n;;\n                  ^^\nError: Syntax error\n"},{"in":"let _ = additivePersistence 9876","min":"\nlet rec additivePersistence n = (n mod 10) + ((additivePersistence n) / 10);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"phrases":["","let rec additivePersistence n = \nlet x = digits n","let _ = additivePersistence 9876"],"region":{"start":809,"stop":1552},"type":"eval"},"cursor":1554,"time":1.444170211415356e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = digits n\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet x = digits n","min":"","type":"syntax","out":"Characters 49-51:\n  let x = digits n;;\n                  ^^\nError: Syntax error\n"}],"event":{"phrases":["","let rec additivePersistence n = \nlet x = digits n"],"region":{"start":809,"stop":1518},"type":"eval"},"cursor":1520,"time":1.444170226690796e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = digits n;;\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet x = digitsOfInt (n)","min":"","type":"syntax","out":"Characters 56-58:\n  let x = digitsOfInt (n);;\n                         ^^\nError: Syntax error\n"}],"event":{"phrases":["","let rec additivePersistence n = \nlet x = digitsOfInt (n)"],"region":{"start":809,"stop":1525},"type":"eval"},"cursor":1525,"time":1.444170235563457e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = digitsOfInt (n)\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet x = digitsOfInt (n)","min":"","type":"syntax","out":"Characters 56-58:\n  let x = digitsOfInt (n);;\n                         ^^\nError: Syntax error\n"}],"event":{"phrases":["","let rec additivePersistence n = \nlet x = digitsOfInt (n)"],"region":{"start":809,"stop":1525},"type":"eval"},"cursor":1527,"time":1.44417023875733e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = digitsOfInt (n);;\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \ndigitsOfInt (n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec additivePersistence n = digitsOfInt n;;\n","type":"","out":""}],"event":{"phrases":["","let rec additivePersistence n = \ndigitsOfInt (n)"],"region":{"start":809,"stop":1517},"type":"eval"},"cursor":1502,"time":1.44417025820619e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  digitsOfInt (n);;\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nsumList digitsOfInt (n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = sumList digitsOfInt n;;\n","type":"type","out":"Characters 33-40:\n  sumList digitsOfInt (n);;\n  ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let rec additivePersistence n = \nsumList digitsOfInt (n)"],"region":{"start":809,"stop":1525},"type":"eval"},"cursor":1526,"time":1.444170316054294e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  sumList digitsOfInt (n)\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nsumList digitsOfInt (n);\n\nlet _ = additivePersistence 9876","min":"","type":"syntax","out":"Characters 91-93:\n  let _ = additivePersistence 9876;;\n                                  ^^\nError: Syntax error\n"}],"event":{"phrases":["","let rec additivePersistence n = \nsumList digitsOfInt (n);\n\nlet _ = additivePersistence 9876"],"region":{"start":809,"stop":1560},"type":"eval"},"cursor":1526,"time":1.444170334852568e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  sumList digitsOfInt (n);\n\n  let _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nsumList digitsOfInt (n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = sumList digitsOfInt n;;\n","type":"type","out":"Characters 33-40:\n  sumList digitsOfInt (n);;\n  ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let rec additivePersistence n = \nsumList digitsOfInt (n)"],"region":{"start":809,"stop":1525},"type":"eval"},"cursor":1527,"time":1.444170340660652e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  sumList digitsOfInt (n);;\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nsumList (digitsOfInt (n))","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = sumList (digitsOfInt n);;\n","type":"","out":""}],"event":{"phrases":["","let rec additivePersistence n = \nsumList (digitsOfInt (n))"],"region":{"start":809,"stop":1527},"type":"eval"},"cursor":1528,"time":1.44417035489073e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  sumList (digitsOfInt (n))\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n = sumList (digitsOfInt n);;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"phrases":["","let _ = additivePersistence 9876"],"region":{"start":1527,"stop":1561},"type":"eval"},"cursor":1563,"time":1.44417037836935e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  sumList (digitsOfInt (n))\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nif (sumList (digitsOfInt (n)) > 10) then 1 + additivePersistence\nelse 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digitsOfInt n)) > 10 then 1 + additivePersistence else 0;;\n","type":"type","out":"Characters 78-97:\n  if (sumList (digitsOfInt (n)) > 10) then 1 + additivePersistence\n                                               ^^^^^^^^^^^^^^^^^^^\nError: This expression has type int -> 'a\n       but an expression was expected of type int\n"}],"event":{"phrases":["","let rec additivePersistence n = \nif (sumList (digitsOfInt (n)) > 10) then 1 + additivePersistence\nelse 0"],"region":{"start":809,"stop":1573},"type":"eval"},"cursor":1574,"time":1.444170517036033e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  if (sumList (digitsOfInt (n)) > 10) then 1 + additivePersistence\n  else 0\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePersistence x\nelse 0","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence x) else 0;;\n","type":"","out":""}],"event":{"phrases":["","let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePersistence x\nelse 0"],"region":{"start":809,"stop":1581},"type":"eval"},"cursor":1582,"time":1.444170554804824e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 0\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence x) else 0;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"phrases":["","let _ = additivePersistence 9876"],"region":{"start":1581,"stop":1615},"type":"eval"},"cursor":1616,"time":1.444170557770262e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 0\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then x\nelse x","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in if x > 10 then x else x;;\n","type":"","out":""}],"event":{"phrases":["","let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then x\nelse x"],"region":{"start":809,"stop":1557},"type":"eval"},"cursor":1557,"time":1.444170575054976e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then x\n    else x\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in if x > 10 then x else x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"phrases":["","let _ = additivePersistence 9876"],"region":{"start":1557,"stop":1591},"type":"eval"},"cursor":1592,"time":1.444170577925908e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then x\n    else x\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePeristence n\nelse 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePeristence n) else 1;;\n","type":"scope","out":"Characters 84-102:\n  if (x > 10) then 1 + additivePeristence n\n                       ^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePeristence\n"},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in if x > 10 then x else x;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"phrases":["","let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePeristence n\nelse 1","let _ = additivePersistence 9876"],"region":{"start":809,"stop":1614},"type":"eval"},"cursor":1616,"time":1.444170611757611e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePeristence n\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePersistence n\nelse 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence n) else 1;;\n","type":"","out":""}],"event":{"phrases":["","let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePersistence n\nelse 1"],"region":{"start":809,"stop":1581},"type":"eval"},"cursor":1582,"time":1.444170616795351e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence n\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence n) else 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"phrases":["","let _ = additivePersistence 9876"],"region":{"start":1581,"stop":1615},"type":"eval"},"cursor":1616,"time":1.444170619351629e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence n\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePersistence x\nelse 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence x) else 1;;\n","type":"","out":""}],"event":{"phrases":["","let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePersistence x\nelse 1"],"region":{"start":809,"stop":1581},"type":"eval"},"cursor":1582,"time":1.444170627162356e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence x) else 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""}],"event":{"phrases":["","let _ = additivePersistence 9876"],"region":{"start":1581,"stop":1615},"type":"eval"},"cursor":1617,"time":1.444170630357528e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then additivePersistence x\nelse x","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence x) else 1;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then additivePersistence x else x;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence x) else 1;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then additivePersistence x else x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then additivePersistence x\nelse x","let _ = digitalRoot 9876"],"region":{"start":1615,"stop":1818},"type":"eval"},"cursor":1821,"time":1.444170662491606e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then additivePersistence x\n    else x\n\nlet _ = digitalRoot 9876\n\n\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then digitalRoot x\nelse x","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then digitalRoot x else x;;\n","type":"","out":""}],"event":{"phrases":["","let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then digitalRoot x\nelse x"],"region":{"start":1615,"stop":1784},"type":"eval"},"cursor":1785,"time":1.444170689167408e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then digitalRoot x else x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""}],"event":{"phrases":["","let _ = digitalRoot 9876"],"region":{"start":1784,"stop":1810},"type":"eval"},"cursor":1811,"time":1.44417069138066e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec listReverse l = failwith \"TBD\"","min":"\nlet rec listReverse l = failwith \"TBD\";;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["","let rec listReverse l = failwith \"TBD\"","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w = failwith \"TBD\"","type test = unit -> string","let key        = \"\"","let prefix130  = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let doTest f = \ntry f () with ex -> \nPrintf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let sampleTests =\n[\n(fun () -> mkTest\nsumList\n[1;2;3;4]\n10\n\"sample: sumList 1\"\n);\n(fun () -> mkTest \nsumList \n[1;-2;3;5] \n7 \n\"sample: sumList 2\"\n); \n(fun () -> mkTest \nsumList \n[1;3;5;7;9;11]\n36 \n\"sample: sumList 3\"\n); \n(fun () -> mkTest \ndigitsOfInt \n3124 \n[3;1;2;4] \n\"sample: digitsOfInt 1\"\n); \n(fun () -> mkTest \ndigitsOfInt \n352663 \n[3;5;2;6;6;3] \n\"sample: digitsOfInt 2\"\n); \n(fun () -> mkTest \ndigits\n31243\n[3;1;2;4;3] \n\"sample: digits 1\"\n); \n(fun () -> mkTest \ndigits\n(-23422)\n[2;3;4;2;2]\n\"sample: digits 2\"\n); \n(fun () -> mkTest \nadditivePersistence \n9876 \n2 \n\"sample: additivePersistence1\"\n); \n(fun () -> mkTest \ndigitalRoot \n9876 \n3 \n\"sample: digitalRoot\"\n); \n(fun () -> mkTest \nlistReverse\n[1;2;3;4] \n[4;3;2;1]\n\"sample: reverse 1\"\n); \n(fun () -> mkTest \nlistReverse \n[\"a\";\"b\";\"c\";\"d\"]\n[\"d\";\"c\";\"b\";\"a\"] \n\"sample: rev 2\"\n); \n(fun () -> mkTest \npalindrome \n\"malayalam\" \ntrue\n\"sample: palindrome 1\"\n); \n(fun () -> mkTest \npalindrome \n\"myxomatosis\" \nfalse\n\"sample: palindrome 2\"\n)]","let _ =\nlet report = List.map doTest (sampleTests) in\nlet _ = List.iter print130 (report@([scoreMsg()])) in\nlet _ = print130 (\"Compiled\\n\") in\n(!score, !max)"],"region":{"start":1810,"stop":5464},"type":"eval"},"cursor":1853,"time":1.444170694444633e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\n\n\nlet rec listReverse l = failwith \"TBD\"\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse l @ h","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse l) @ h;;\n","type":"","out":""}],"event":{"phrases":["","let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse l @ h"],"region":{"start":1810,"stop":1890},"type":"eval"},"cursor":1890,"time":1.444171210722074e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse l @ h\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse l) @ h;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"type","out":"Characters 21-22:\n  let _ = listReverse [1; 2; 3; 4];;\n                       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse l) @ h;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"type","out":"Characters 21-24:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n                       ^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["","let _ = listReverse [1; 2; 3; 4]","let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"],"region":{"start":1890,"stop":1965},"type":"eval"},"cursor":1966,"time":1.444171213263178e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse l @ h\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse l::h","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse l) :: h;;\n","type":"type","out":"Characters 60-73:\n  | h::tl -> listReverse l::h;;\n             ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}],"event":{"phrases":["","let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse l::h"],"region":{"start":1810,"stop":1889},"type":"eval"},"cursor":1889,"time":1.44417122534089e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse l::h\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse l@h","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse l) @ h;;\n","type":"","out":""}],"event":{"phrases":["","let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse l@h"],"region":{"start":1810,"stop":1888},"type":"eval"},"cursor":1888,"time":1.444171236805618e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse l@h\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@h","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ h;;\n","type":"","out":""}],"event":{"phrases":["","let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@h"],"region":{"start":1810,"stop":1889},"type":"eval"},"cursor":1886,"time":1.444171239435164e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@h\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ h;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"type","out":"Characters 21-22:\n  let _ = listReverse [1; 2; 3; 4];;\n                       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["","let _ = listReverse [1; 2; 3; 4]"],"region":{"start":1889,"stop":1923},"type":"eval"},"cursor":1923,"time":1.444171241767489e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@h\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@[h]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n","type":"","out":""}],"event":{"phrases":["","let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@[h]"],"region":{"start":1810,"stop":1891},"type":"eval"},"cursor":1891,"time":1.444171276730224e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""}],"event":{"phrases":["","let _ = listReverse [1; 2; 3; 4]","let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]"],"region":{"start":1891,"stop":1966},"type":"eval"},"cursor":1967,"time":1.444171281563994e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w = failwith \"TBD\"","min":"\nlet palindrome w = failwith \"TBD\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let _ = listReverse [1; 2; 3; 4]","let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w = failwith \"TBD\"","type test = unit -> string","let key        = \"\"","let prefix130  = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let doTest f = \ntry f () with ex -> \nPrintf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let sampleTests =\n[\n(fun () -> mkTest\nsumList\n[1;2;3;4]\n10\n\"sample: sumList 1\"\n);\n(fun () -> mkTest \nsumList \n[1;-2;3;5] \n7 \n\"sample: sumList 2\"\n); \n(fun () -> mkTest \nsumList \n[1;3;5;7;9;11]\n36 \n\"sample: sumList 3\"\n); \n(fun () -> mkTest \ndigitsOfInt \n3124 \n[3;1;2;4] \n\"sample: digitsOfInt 1\"\n); \n(fun () -> mkTest \ndigitsOfInt \n352663 \n[3;5;2;6;6;3] \n\"sample: digitsOfInt 2\"\n); \n(fun () -> mkTest \ndigits\n31243\n[3;1;2;4;3] \n\"sample: digits 1\"\n); \n(fun () -> mkTest \ndigits\n(-23422)\n[2;3;4;2;2]\n\"sample: digits 2\"\n); \n(fun () -> mkTest \nadditivePersistence \n9876 \n2 \n\"sample: additivePersistence1\"\n); \n(fun () -> mkTest \ndigitalRoot \n9876 \n3 \n\"sample: digitalRoot\"\n); \n(fun () -> mkTest \nlistReverse\n[1;2;3;4] \n[4;3;2;1]\n\"sample: reverse 1\"\n); \n(fun () -> mkTest \nlistReverse \n[\"a\";\"b\";\"c\";\"d\"]\n[\"d\";\"c\";\"b\";\"a\"] \n\"sample: rev 2\"\n); \n(fun () -> mkTest \npalindrome \n\"malayalam\" \ntrue\n\"sample: palindrome 1\"\n); \n(fun () -> mkTest \npalindrome \n\"myxomatosis\" \nfalse\n\"sample: palindrome 2\"\n)]","let _ =\nlet report = List.map doTest (sampleTests) in\nlet _ = List.iter print130 (report@([scoreMsg()])) in\nlet _ = print130 (\"Compiled\\n\") in\n(!score, !max)"],"region":{"start":1893,"stop":5439},"type":"eval"},"cursor":1925,"time":1.444171289068955e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w = failwith \"TBD\"\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w =\nlet x = explode w","min":"","type":"syntax","out":"Characters 36-38:\n  let x = explode w;;\n                   ^^\nError: Syntax error\n"}],"event":{"phrases":["","let palindrome w =\nlet x = explode w"],"region":{"start":2255,"stop":2293},"type":"eval"},"cursor":2293,"time":1.444174412472529e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let x = explode w\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w =\nlet x = explode w","min":"","type":"syntax","out":"Characters 36-38:\n  let x = explode w;;\n                   ^^\nError: Syntax error\n"}],"event":{"phrases":["","let palindrome w =\nlet x = explode w"],"region":{"start":2255,"stop":2293},"type":"eval"},"cursor":2295,"time":1.444174420443052e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let x = explode w;;\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w =\nlet y = listReverse w in \nlet r = explode y","min":"","type":"syntax","out":"Characters 62-64:\n  let r = explode y;;\n                   ^^\nError: Syntax error\n"}],"event":{"phrases":["","let palindrome w =\nlet y = listReverse w in \nlet r = explode y"],"region":{"start":2255,"stop":2319},"type":"eval"},"cursor":2319,"time":1.444174507131919e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let y = listReverse w in \n  let r = explode y\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then digitalRoot x\nelse x","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then digitalRoot x else x;;\n","type":"","out":""}],"event":{"phrases":["let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then digitalRoot x\nelse x"],"region":{"start":1692,"stop":1784},"type":"eval"},"cursor":1785,"time":1.444174515077075e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let y = listReverse w in \n    r = explode y\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then digitalRoot x else x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@[h]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w =\nlet y = listReverse w in \nr = explode y\nr","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let y = listReverse w in r = (explode y r);;\n","type":"scope","out":"Characters 45-46:\n  r = explode y\n  ^\nError: Unbound value r\n"}],"event":{"phrases":["","let _ = digitalRoot 9876","let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@[h]","let _ = listReverse [1; 2; 3; 4]","let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w =\nlet y = listReverse w in \nr = explode y\nr"],"region":{"start":1784,"stop":2317},"type":"eval"},"cursor":2317,"time":1.444174520187707e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let y = listReverse w in \n    r = explode y\n          r\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w =\nlet y = listReverse w in r = explode y","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let y = listReverse w in r = (explode y);;\n","type":"scope","out":"Characters 44-45:\n  let y = listReverse w in r = explode y;;\n                           ^\nError: Unbound value r\n"}],"event":{"phrases":["","let palindrome w =\nlet y = listReverse w in r = explode y"],"region":{"start":2255,"stop":2314},"type":"eval"},"cursor":2314,"time":1.444174541858491e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let y = listReverse w in r = explode y\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w =\nlet y = listReverse w","min":"","type":"syntax","out":"Characters 40-42:\n  let y = listReverse w;;\n                       ^^\nError: Syntax error\n"},{"in":";;","min":"\n;;\n","type":"","out":""}],"event":{"phrases":["","let palindrome w =\nlet y = listReverse w",";;"],"region":{"start":2255,"stop":2301},"type":"eval"},"cursor":2301,"time":1.444176727592969e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let y = listReverse w;;;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w =\nlet y = listReverse w in y","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let y = listReverse w in y;;\n","type":"","out":""}],"event":{"phrases":["","let palindrome w =\nlet y = listReverse w in y"],"region":{"start":2255,"stop":2302},"type":"eval"},"cursor":2304,"time":1.444176739170861e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let y = listReverse w in y;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w =\nlet y = listReverse w in y","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let y = listReverse w in y;;\n","type":"","out":""}],"event":{"phrases":["let palindrome w =\nlet y = listReverse w in y"],"region":{"start":2257,"stop":2302},"type":"eval"},"cursor":2305,"time":1.444176742257494e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let y = listReverse w in y;;\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"y","min":"\nlet _ = y;;\n","type":"scope","out":"Characters 0-1:\n  y;;\n  ^\nError: Unbound value y\n"}],"event":{"phrases":["","y"],"region":{"start":2302,"stop":2306},"type":"eval"},"cursor":2306,"time":1.444176745525754e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let y = listReverse w in y;;\ny\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec equiv =\nlet fun x = fun y =\nx < y","min":"","type":"syntax","out":"Characters 20-23:\n  let fun x = fun y =\n      ^^^\nError: Syntax error\n"}],"event":{"phrases":["","let rec equiv =\nlet fun x = fun y =\nx < y"],"region":{"start":2255,"stop":2298},"type":"eval"},"cursor":2298,"time":1.444177049072836e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  let fun x = fun y =\n    x < y\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec equiv =\nfun x = fun y =\nx < y","min":"","type":"syntax","out":"Characters 22-23:\n  fun x = fun y =\n        ^\nError: Syntax error\n"}],"event":{"phrases":["","let rec equiv =\nfun x = fun y =\nx < y"],"region":{"start":2255,"stop":2294},"type":"eval"},"cursor":2294,"time":1.444177059979841e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x = fun y =\n    x < y\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec equiv =\nfun x -> fun y ->\nx < y","min":"\nlet rec equiv x y = x < y;;\n","type":"","out":""}],"event":{"phrases":["","let rec equiv =\nfun x -> fun y ->\nx < y"],"region":{"start":2255,"stop":2296},"type":"eval"},"cursor":2296,"time":1.444177069015144e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    x < y\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec equiv =\nfun x -> fun y ->\nmatch x with \n| [] -> if( y = []) then true","min":"\nlet rec equiv x y = match x with | [] -> if y = [] then true;;\n","type":"type","out":"Characters 73-77:\n  | [] -> if( y = []) then true;;\n                           ^^^^\nError: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n"}],"event":{"phrases":["","let rec equiv =\nfun x -> fun y ->\nmatch x with \n| [] -> if( y = []) then true"],"region":{"start":2255,"stop":2334},"type":"eval"},"cursor":2334,"time":1.444177117713446e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | [] -> if( y = []) then true\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec equiv =\nfun x -> fun y ->\nmatch x with \n| [] -> if( y = []) then True","min":"\nlet rec equiv x y = match x with | [] -> if y = [] then True;;\n","type":"type","out":"Characters 73-77:\n  | [] -> if( y = []) then True;;\n                           ^^^^\nError: This variant expression is expected to have type unit\n       The constructor True does not belong to type unit\n"}],"event":{"phrases":["","let rec equiv =\nfun x -> fun y ->\nmatch x with \n| [] -> if( y = []) then True"],"region":{"start":2255,"stop":2334},"type":"eval"},"cursor":2334,"time":1.444177132035315e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | [] -> if( y = []) then True\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec equiv =\nnum1 x -> num2 y ->\nmatch x with \n| h::tl -> if ( list.hd y = h) then 1","min":"","type":"syntax","out":"Characters 23-25:\n  num1 x -> num2 y ->\n         ^^\nError: Syntax error\n"}],"event":{"phrases":["","let rec equiv =\nnum1 x -> num2 y ->\nmatch x with \n| h::tl -> if ( list.hd y = h) then 1"],"region":{"start":2255,"stop":2344},"type":"eval"},"cursor":2344,"time":1.444177329683094e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  num1 x -> num2 y ->\n  match x with \n    | h::tl -> if ( list.hd y = h) then 1\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec equiv =\nnum1 x = num2 y =\nmatch x with \n| h::tl -> if ( list.hd y = h) then 1","min":"\nlet rec equiv =\n  ((num1 x) = (num2 y)) = (match x with | h::tl -> if (list.hd y) = h then 1);;\n","type":"scope","out":"Characters 16-20:\n  num1 x = num2 y =\n  ^^^^\nError: Unbound value num1\n"}],"event":{"phrases":["","let rec equiv =\nnum1 x = num2 y =\nmatch x with \n| h::tl -> if ( list.hd y = h) then 1"],"region":{"start":2255,"stop":2342},"type":"eval"},"cursor":2290,"time":1.44417733936747e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  num1 x = num2 y =\n  match x with \n    | h::tl -> if ( list.hd y = h) then 1\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let rec equiv =\nfun x -> fun y ->\nmatch x with \n| h::tl -> if ( list.hd y = h) then 1","min":"\nlet rec equiv x y = match x with | h::tl -> if (list.hd y) = h then 1;;\n","type":"scope","out":"Characters 64-68:\n  | h::tl -> if ( list.hd y = h) then 1;;\n                  ^^^^\nError: Unbound value list\n"}],"event":{"phrases":["","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let rec equiv =\nfun x -> fun y ->\nmatch x with \n| h::tl -> if ( list.hd y = h) then 1"],"region":{"start":1966,"stop":2342},"type":"eval"},"cursor":2277,"time":1.444177361228921e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | h::tl -> if ( list.hd y = h) then 1\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec equiv =\nfun x -> fun y ->\nmatch x with \n| h::tl -> if ( List.hd y = h) then 1","min":"\nlet rec equiv x y = match x with | h::tl -> if (List.hd y) = h then 1;;\n","type":"type","out":"Characters 84-85:\n  | h::tl -> if ( List.hd y = h) then 1;;\n                                      ^\nError: This expression has type int but an expression was expected of type\n         unit\n"}],"event":{"phrases":["","let rec equiv =\nfun x -> fun y ->\nmatch x with \n| h::tl -> if ( List.hd y = h) then 1"],"region":{"start":2255,"stop":2342},"type":"eval"},"cursor":2272,"time":1.44417737622539e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | h::tl -> if ( List.hd y = h) then 1\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec equiv =\nfun x -> fun y ->\nmatch x with \n| h::tl -> if ( List.hd y = h) then true","min":"\nlet rec equiv x y = match x with | h::tl -> if (List.hd y) = h then true;;\n","type":"type","out":"Characters 84-88:\n  | h::tl -> if ( List.hd y = h) then true;;\n                                      ^^^^\nError: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n"}],"event":{"phrases":["","let rec equiv =\nfun x -> fun y ->\nmatch x with \n| h::tl -> if ( List.hd y = h) then true"],"region":{"start":2255,"stop":2345},"type":"eval"},"cursor":2345,"time":1.444177394475394e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | h::tl -> if ( List.hd y = h) then true\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec equiv =\nfun x -> fun y ->\nmatch x with \n| h::tl -> ( List.hd y = h)","min":"\nlet rec equiv x y = match x with | h::tl -> (List.hd y) = h;;\n","type":"","out":""}],"event":{"phrases":["","let rec equiv =\nfun x -> fun y ->\nmatch x with \n| h::tl -> ( List.hd y = h)"],"region":{"start":2255,"stop":2332},"type":"eval"},"cursor":2315,"time":1.444177402335041e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | h::tl -> ( List.hd y = h)\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then digitalRoot x\nelse x","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then digitalRoot x else x;;\n","type":"","out":""}],"event":{"phrases":["let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then digitalRoot x\nelse x"],"region":{"start":1692,"stop":1784},"type":"eval"},"cursor":1784,"time":1.44417743336183e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | [] -> (List.hd y = [])\n      | h::tl -> ( List.hd y = h)\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then digitalRoot x else x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@[h]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let rec equiv =\nfun x -> fun y ->\nmatch x with \n| [] -> (List.hd y = [])\n| h::tl -> ( List.hd y = h)","min":"\nlet rec equiv x y =\n  match x with | [] -> (List.hd y) = [] | h::tl -> (List.hd y) = h;;\n","type":"","out":""}],"event":{"phrases":["","let _ = digitalRoot 9876","let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@[h]","let _ = listReverse [1; 2; 3; 4]","let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let rec equiv =\nfun x -> fun y ->\nmatch x with \n| [] -> (List.hd y = [])\n| h::tl -> ( List.hd y = h)"],"region":{"start":1784,"stop":2357},"type":"eval"},"cursor":2359,"time":1.44417743579199e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | [] -> (List.hd y = [])\n      | h::tl -> ( List.hd y = h)\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec equiv =\nfun x -> fun y ->\nmatch x with \n| [] -> (List.hd y = [])\n| h::tl -> ( List.hd y = h)","min":"\nlet rec equiv x y =\n  match x with | [] -> (List.hd y) = [] | h::tl -> (List.hd y) = h;;\n","type":"","out":""}],"event":{"phrases":["let rec equiv =\nfun x -> fun y ->\nmatch x with \n| [] -> (List.hd y = [])\n| h::tl -> ( List.hd y = h)"],"region":{"start":2257,"stop":2357},"type":"eval"},"cursor":2358,"time":1.444177444209492e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | [] -> (List.hd y = [])\n      | h::tl -> ( List.hd y = h)\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let test = equiv [1;2]","min":"\nlet rec equiv x y =\n  match x with | [] -> (List.hd y) = [] | h::tl -> (List.hd y) = h;;\n\nlet test = equiv [1; 2];;\n","type":"type","out":"Characters 18-19:\n  let test = equiv [1;2];;\n                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"},{"in":"let meh = test [1;2]","min":"\ntype test = unit -> string;;\n\nlet meh = test [1; 2];;\n","type":"scope","out":"Characters 10-14:\n  let meh = test [1;2];;\n            ^^^^\nError: Unbound value test\n"}],"event":{"phrases":["","let test = equiv [1;2]","let meh = test [1;2]"],"region":{"start":2357,"stop":2402},"type":"eval"},"cursor":2402,"time":1.444177495579249e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | [] -> (List.hd y = [])\n      | h::tl -> ( List.hd y = h)\n\nlet test = equiv [1;2]\nlet meh = test [1;2]\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let test = equiv [1; 2]","min":"\nlet rec equiv x y =\n  match x with | [] -> (List.hd y) = [] | h::tl -> (List.hd y) = h;;\n\nlet test = equiv [1; 2];;\n","type":"type","out":"Characters 18-19:\n  let test = equiv [1; 2];;\n                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["","let test = equiv [1; 2]"],"region":{"start":2357,"stop":2382},"type":"eval"},"cursor":2382,"time":1.444177512317351e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | [] -> (List.hd y = [])\n      | h::tl -> ( List.hd y = h)\n\nlet test = equiv [1; 2]\nlet meh = test [1; 2]\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let test = equiv [1; 2; 3; 4]","min":"\nlet rec equiv x y =\n  match x with | [] -> (List.hd y) = [] | h::tl -> (List.hd y) = h;;\n\nlet test = equiv [1; 2; 3; 4];;\n","type":"type","out":"Characters 18-19:\n  let test = equiv [1; 2; 3; 4];;\n                    ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["","let test = equiv [1; 2; 3; 4]"],"region":{"start":2357,"stop":2388},"type":"eval"},"cursor":2388,"time":1.444177539235099e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet rec equiv =\n  fun x -> fun y ->\n    match x with \n      | [] -> (List.hd y = [])\n      | h::tl -> ( List.hd y = h)\n\nlet test = equiv [1; 2; 3; 4]\nlet meh = test [1; 2]\n\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let neg = fun f -> fun x -> not f x","min":"\nlet neg f x = not f x;;\n","type":"type","out":"Characters 28-31:\n  let neg = fun f -> fun x -> not f x;;\n                              ^^^\nError: This function has type bool -> bool\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let neg = fun f -> fun x -> not f x"],"region":{"start":2255,"stop":2292},"type":"eval"},"cursor":2292,"time":1.444177760714612e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet neg = fun f -> fun x -> not f x\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let neg = fun f -> fun x -> Not f x","min":"","type":"syntax","out":"Characters 34-35:\n  let neg = fun f -> fun x -> Not f x;;\n                                    ^\nError: Syntax error\n"}],"event":{"phrases":["","let neg = fun f -> fun x -> Not f x"],"region":{"start":2255,"stop":2292},"type":"eval"},"cursor":2292,"time":1.444177775143775e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet neg = fun f -> fun x -> Not f x\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let neg = fun f -> fun x -> Not (f x)","min":"\nlet neg f x = Not (f x);;\n","type":"scope","out":"Characters 28-31:\n  let neg = fun f -> fun x -> Not (f x);;\n                              ^^^\nError: Unbound constructor Not\n"}],"event":{"phrases":["","let neg = fun f -> fun x -> Not (f x)"],"region":{"start":2255,"stop":2294},"type":"eval"},"cursor":2294,"time":1.444177780469173e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet neg = fun f -> fun x -> Not (f x)\n\nlet palindrome w =\n  let y = listReverse w in\n  let r = explode y in\n  let o = explode w in\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXX*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n    (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList t","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)@[n mod 10] \nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePersistence x\nelse 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence x) else 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence x) else 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then digitalRoot x\nelse x","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then digitalRoot x else x;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then digitalRoot x else x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@[h]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w =\nlet o = explode w in\nlet r = listReverse o in\n(o = r)","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let o = explode w in let r = listReverse o in o = r;;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList t","let _ = sumList [1; 2; 3; 4]","let _ = sumList [1; -2; 3; 5]","let _ = sumList [1; 3; 5; 7; 9; 11]","let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)@[n mod 10] \nelse []","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663","let digits n = digitsOfInt (abs n)","let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePersistence x\nelse 1","let _ = additivePersistence 9876","let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then digitalRoot x\nelse x","let _ = digitalRoot 9876","let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@[h]","let _ = listReverse [1; 2; 3; 4]","let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w =\nlet o = explode w in\nlet r = listReverse o in\n(o = r)"],"region":{"start":0,"stop":2329},"type":"eval"},"cursor":2329,"time":1.444253160098696e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let o = explode w in\n  let r = listReverse o in\n    (o = r)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let palindrome w =\nlet o = explode w in\nlet r = listReverse o in\n(o = r)","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let o = explode w in let r = listReverse o in o = r;;\n","type":"","out":""}],"event":{"phrases":["let palindrome w =\nlet o = explode w in\nlet r = listReverse o in\n(o = r)"],"region":{"start":2257,"stop":2329},"type":"eval"},"cursor":2330,"time":1.444253164567099e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let o = explode w in\n  let r = listReverse o in\n    (o = r)\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let o = explode w in let r = listReverse o in o = r;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let o = explode w in let r = listReverse o in o = r;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""}],"event":{"phrases":["","let _ = palindrome \"malayalam\"","let _ = palindrome \"myxomatosis\""],"region":{"start":2329,"stop":2395},"type":"eval"},"cursor":2396,"time":1.444253178916756e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let o = explode w in\n  let r = listReverse o in\n    (o = r)\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let o = explode w in let r = listReverse o in o = r;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let _ = palindrome \"myxomatosis\"","type test = unit -> string","let key        = \"\"","let prefix130  = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let doTest f = \ntry f () with ex -> \nPrintf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let sampleTests =\n[\n(fun () -> mkTest\nsumList\n[1;2;3;4]\n10\n\"sample: sumList 1\"\n);\n(fun () -> mkTest \nsumList \n[1;-2;3;5] \n7 \n\"sample: sumList 2\"\n); \n(fun () -> mkTest \nsumList \n[1;3;5;7;9;11]\n36 \n\"sample: sumList 3\"\n); \n(fun () -> mkTest \ndigitsOfInt \n3124 \n[3;1;2;4] \n\"sample: digitsOfInt 1\"\n); \n(fun () -> mkTest \ndigitsOfInt \n352663 \n[3;5;2;6;6;3] \n\"sample: digitsOfInt 2\"\n); \n(fun () -> mkTest \ndigits\n31243\n[3;1;2;4;3] \n\"sample: digits 1\"\n); \n(fun () -> mkTest \ndigits\n(-23422)\n[2;3;4;2;2]\n\"sample: digits 2\"\n); \n(fun () -> mkTest \nadditivePersistence \n9876 \n2 \n\"sample: additivePersistence1\"\n); \n(fun () -> mkTest \ndigitalRoot \n9876 \n3 \n\"sample: digitalRoot\"\n); \n(fun () -> mkTest \nlistReverse\n[1;2;3;4] \n[4;3;2;1]\n\"sample: reverse 1\"\n); \n(fun () -> mkTest \nlistReverse \n[\"a\";\"b\";\"c\";\"d\"]\n[\"d\";\"c\";\"b\";\"a\"] \n\"sample: rev 2\"\n); \n(fun () -> mkTest \npalindrome \n\"malayalam\" \ntrue\n\"sample: palindrome 1\"\n); \n(fun () -> mkTest \npalindrome \n\"myxomatosis\" \nfalse\n\"sample: palindrome 2\"\n)]","let _ =\nlet report = List.map doTest (sampleTests) in\nlet _ = List.iter print130 (report@([scoreMsg()])) in\nlet _ = print130 (\"Compiled\\n\") in\n(!score, !max)"],"region":{"start":2363,"stop":5413},"type":"eval"},"cursor":2396,"time":1.444253183544916e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let o = explode w in\n  let r = listReverse o in\n    (o = r)\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList t","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n","type":"","out":""},{"in":"let _ = sumList [1; 2; 3; 4]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = sumList [1; -2; 3; 5]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; (-2); 3; 5];;\n","type":"","out":""},{"in":"let _ = sumList [1; 3; 5; 7; 9; 11]","min":"\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList [1; 3; 5; 7; 9; 11];;\n","type":"","out":""},{"in":"let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)@[n mod 10] \nelse []","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n","type":"","out":""},{"in":"let _ = digitsOfInt 3124","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 3124;;\n","type":"","out":""},{"in":"let _ = digitsOfInt 352663","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet _ = digitsOfInt 352663;;\n","type":"","out":""},{"in":"let digits n = digitsOfInt (abs n)","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n","type":"","out":""},{"in":"let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePersistence x\nelse 1","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence x) else 1;;\n","type":"","out":""},{"in":"let _ = additivePersistence 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x > 10 then 1 + (additivePersistence x) else 1;;\n\nlet _ = additivePersistence 9876;;\n","type":"","out":""},{"in":"let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then digitalRoot x\nelse x","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then digitalRoot x else x;;\n","type":"","out":""},{"in":"let _ = digitalRoot 9876","min":"\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 10 then digitalRoot x else x;;\n\nlet _ = digitalRoot 9876;;\n","type":"","out":""},{"in":"let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@[h]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n","type":"","out":""},{"in":"let _ = listReverse [1; 2; 3; 4]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [1; 2; 3; 4];;\n","type":"","out":""},{"in":"let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","min":"\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n","type":"","out":""},{"in":"let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n","type":"","out":""},{"in":"let palindrome w =\nlet o = explode w in\nlet r = listReverse o in\n(o = r)","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let o = explode w in let r = listReverse o in o = r;;\n","type":"","out":""},{"in":"let _ = palindrome \"malayalam\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let o = explode w in let r = listReverse o in o = r;;\n\nlet _ = palindrome \"malayalam\";;\n","type":"","out":""},{"in":"let _ = palindrome \"myxomatosis\"","min":"\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::tl -> (listReverse tl) @ [h];;\n\nlet palindrome w = let o = explode w in let r = listReverse o in o = r;;\n\nlet _ = palindrome \"myxomatosis\";;\n","type":"","out":""},{"in":"type test = unit -> string","min":"\ntype test = unit -> string;;\n","type":"","out":""},{"in":"let key        = \"\"","min":"\nlet key = \"\";;\n","type":"","out":""},{"in":"let prefix130  = \"130\"","min":"\nlet prefix130 = \"130\";;\n","type":"","out":""},{"in":"let print130 s = print_string (prefix130^\">>\"^s)","min":"\nlet prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n","type":"","out":""},{"in":"exception ErrorCode of string","min":"\nexception ErrorCode of string;;\n","type":"","out":""},{"in":"type result = Pass | Fail | ErrorCode of string","min":"\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n","type":"","out":""},{"in":"let score = ref 0","min":"\nlet score = ref 0;;\n","type":"","out":""},{"in":"let max = ref 0","min":"\nlet max = ref 0;;\n","type":"","out":""},{"in":"let timeout = 300","min":"\nlet timeout = 300;;\n","type":"","out":""},{"in":"let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","min":"\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n","type":"","out":""},{"in":"let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","min":"\nlet max = ref 0;;\n\nlet score = ref 0;;\n\nlet scoreMsg () =\n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" (!score) (!max);;\n","type":"","out":""}],"event":{"phrases":["let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t ->\nh + sumList t","let _ = sumList [1; 2; 3; 4]","let _ = sumList [1; -2; 3; 5]","let _ = sumList [1; 3; 5; 7; 9; 11]","let rec digitsOfInt n = \nif (n > 0) then digitsOfInt(n/10)@[n mod 10] \nelse []","let _ = digitsOfInt 3124","let _ = digitsOfInt 352663","let digits n = digitsOfInt (abs n)","let rec additivePersistence n = \nlet x = sumList (digits n) in\nif (x > 10) then 1 + additivePersistence x\nelse 1","let _ = additivePersistence 9876","let rec digitalRoot n = \nlet x = sumList (digits n) in\nif (x > 10) then digitalRoot x\nelse x","let _ = digitalRoot 9876","let rec listReverse l = \nmatch l with\n| [] -> []\n| h::tl -> listReverse tl@[h]","let _ = listReverse [1; 2; 3; 4]","let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]","let explode s = \nlet rec go i = \nif i >= String.length s \nthen [] \nelse (s.[i]) :: (go (i+1)) \nin\ngo 0","let palindrome w =\nlet o = explode w in\nlet r = listReverse o in\n(o = r)","let _ = palindrome \"malayalam\"","let _ = palindrome \"myxomatosis\"","type test = unit -> string","let key        = \"\"","let prefix130  = \"130\"","let print130 s = print_string (prefix130^\">>\"^s)","exception ErrorCode of string","exception TestException","type result = Pass | Fail | ErrorCode of string","let score = ref 0","let max = ref 0","let timeout = 300","let runWTimeout (f,arg,out,time) = \ntry if compare (f arg) out = 0 then Pass else Fail\nwith e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\")","let testTest () =\nlet testGood x = 1 in\nlet testBad x = 0 in \nlet testException x = raise TestException in\nlet rec testTimeout x = testTimeout x in\nrunWTimeout(testGood,0,1,5) = Pass &&  \nrunWTimeout(testBad,0,1,5) = Fail &&  \nrunWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \nrunWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"","let runTest ((f,arg,out),points,name) =\nlet _   = max := !max + points in\nlet outs = \nmatch runWTimeout(f,arg,out,timeout) with \nPass -> (score := !score + points; \"[pass]\")\n| Fail -> \"[fail]\"\n| ErrorCode e -> \"[error: \"^e^\"]\"  in\nname^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"","let mkTest f x y name = runTest ((f, x, y), 1, name)","let badTest () = \"WARNING: Your tests are not valid!!\\n\"","let scoreMsg () = \nPrintf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max","let doTest f = \ntry f () with ex -> \nPrintf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n(Printexc.to_string ex)","let sampleTests =\n[\n(fun () -> mkTest\nsumList\n[1;2;3;4]\n10\n\"sample: sumList 1\"\n);\n(fun () -> mkTest \nsumList \n[1;-2;3;5] \n7 \n\"sample: sumList 2\"\n); \n(fun () -> mkTest \nsumList \n[1;3;5;7;9;11]\n36 \n\"sample: sumList 3\"\n); \n(fun () -> mkTest \ndigitsOfInt \n3124 \n[3;1;2;4] \n\"sample: digitsOfInt 1\"\n); \n(fun () -> mkTest \ndigitsOfInt \n352663 \n[3;5;2;6;6;3] \n\"sample: digitsOfInt 2\"\n); \n(fun () -> mkTest \ndigits\n31243\n[3;1;2;4;3] \n\"sample: digits 1\"\n); \n(fun () -> mkTest \ndigits\n(-23422)\n[2;3;4;2;2]\n\"sample: digits 2\"\n); \n(fun () -> mkTest \nadditivePersistence \n9876 \n2 \n\"sample: additivePersistence1\"\n); \n(fun () -> mkTest \ndigitalRoot \n9876 \n3 \n\"sample: digitalRoot\"\n); \n(fun () -> mkTest \nlistReverse\n[1;2;3;4] \n[4;3;2;1]\n\"sample: reverse 1\"\n); \n(fun () -> mkTest \nlistReverse \n[\"a\";\"b\";\"c\";\"d\"]\n[\"d\";\"c\";\"b\";\"a\"] \n\"sample: rev 2\"\n); \n(fun () -> mkTest \npalindrome \n\"malayalam\" \ntrue\n\"sample: palindrome 1\"\n); \n(fun () -> mkTest \npalindrome \n\"myxomatosis\" \nfalse\n\"sample: palindrome 2\"\n)]","let _ =\nlet report = List.map doTest (sampleTests) in\nlet _ = List.iter print130 (report@([scoreMsg()])) in\nlet _ = print130 (\"Compiled\\n\") in\n(!score, !max)"],"region":{"start":0,"stop":5413},"type":"eval"},"cursor":119,"time":1.444415025036359e9,"body":"(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXX\n*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXX*) \nlet rec sumList xs = \n  match xs with\n    | [] -> 0\n    | h::t ->\n        h + sumList t;;\n\nlet _ = sumList [1; 2; 3; 4]\nlet _ = sumList [1; -2; 3; 5]\nlet _ = sumList [1; 3; 5; 7; 9; 11]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\nlet rec digitsOfInt n = \n  if (n > 0) then digitsOfInt(n/10)@[n mod 10] \n  else [];;\n\n\nlet _ = digitsOfInt 3124\nlet _ = digitsOfInt 352663\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\nlet digits n = digitsOfInt (abs n)\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\n\n\n\n\nlet rec additivePersistence n = \n  let x = sumList (digits n) in\n    if (x > 10) then 1 + additivePersistence x\n    else 1\n\nlet _ = additivePersistence 9876\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet rec digitalRoot n = \n  let x = sumList (digits n) in\n    if (x > 10) then digitalRoot x\n    else x\n\nlet _ = digitalRoot 9876\n\n\nlet rec listReverse l = \n  match l with\n    | [] -> []\n    | h::tl -> listReverse tl@[h]\n\nlet _ = listReverse [1; 2; 3; 4]\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"]\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*)\nlet explode s = \n  let rec go i = \n    if i >= String.length s \n    then [] \n    else (s.[i]) :: (go (i+1)) \n  in\n    go 0\n\nlet palindrome w =\n  let o = explode w in\n  let r = listReverse o in\n    (o = r)\n\n\nlet _ = palindrome \"malayalam\"\nlet _ = palindrome \"myxomatosis\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\ntype test = unit -> string\n\nlet key        = \"\"     (*XXXXXXXX*)\nlet prefix130  = \"130\"  (*XXXXXXXX*)\n\nlet print130 s = print_string (prefix130^\">>\"^s)\n\nexception ErrorCode of string\n\nexception TestException\n\ntype result = Pass | Fail | ErrorCode of string\n\nlet score = ref 0\nlet max = ref 0\nlet timeout = 300\n\nlet runWTimeout (f,arg,out,time) = \n  try if compare (f arg) out = 0 then Pass else Fail\n  with e -> (print130 (\"Uncaught Exception: \"^(Printexc.to_string e)); ErrorCode \"exception\") \n\nlet testTest () =\n  let testGood x = 1 in\n  let testBad x = 0 in \n  let testException x = raise TestException in\n  let rec testTimeout x = testTimeout x in\n    runWTimeout(testGood,0,1,5) = Pass &&  \n    runWTimeout(testBad,0,1,5) = Fail &&  \n    runWTimeout(testException,0,1,5) = ErrorCode \"exception\" && \n    runWTimeout(testTimeout,0,1,5) = ErrorCode \"timeout\"\n\nlet runTest ((f,arg,out),points,name) =\n  let _   = max := !max + points in\n  let outs = \n    match runWTimeout(f,arg,out,timeout) with \n        Pass -> (score := !score + points; \"[pass]\")\n      | Fail -> \"[fail]\"\n      | ErrorCode e -> \"[error: \"^e^\"]\"  in\n    name^\" \"^outs^\" (\"^(string_of_int points)^\")\\n\"\n\nlet mkTest f x y name = runTest ((f, x, y), 1, name)\n\nlet badTest () = \"WARNING: Your tests are not valid!!\\n\"\n\nlet scoreMsg () = \n  Printf.sprintf \"Results: Score/Max = %d / %d \\n\" !score !max \n\nlet doTest f = \n  try f () with ex -> \n    Printf.sprintf \"WARNING: INVALID TEST THROWS EXCEPTION!!: %s \\n\\n\"\n      (Printexc.to_string ex)\n\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n(*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n\nlet sampleTests =\n  [\n    (fun () -> mkTest\n                 sumList\n                 [1;2;3;4]\n                 10\n                 \"sample: sumList 1\"\n    );\n    (fun () -> mkTest \n                 sumList \n                 [1;-2;3;5] \n                 7 \n                 \"sample: sumList 2\"\n    ); \n    (fun () -> mkTest \n                 sumList \n                 [1;3;5;7;9;11]\n                 36 \n                 \"sample: sumList 3\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 3124 \n                 [3;1;2;4] \n                 \"sample: digitsOfInt 1\"\n    ); \n    (fun () -> mkTest \n                 digitsOfInt \n                 352663 \n                 [3;5;2;6;6;3] \n                 \"sample: digitsOfInt 2\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 31243\n                 [3;1;2;4;3] \n                 \"sample: digits 1\"\n    ); \n    (fun () -> mkTest \n                 digits\n                 (-23422)\n                 [2;3;4;2;2]\n                 \"sample: digits 2\"\n    ); \n    (fun () -> mkTest \n                 additivePersistence \n                 9876 \n                 2 \n                 \"sample: additivePersistence1\"\n    ); \n    (fun () -> mkTest \n                 digitalRoot \n                 9876 \n                 3 \n                 \"sample: digitalRoot\"\n    ); \n    (fun () -> mkTest \n                 listReverse\n                 [1;2;3;4] \n                 [4;3;2;1]\n                 \"sample: reverse 1\"\n    ); \n    (fun () -> mkTest \n                 listReverse \n                 [\"a\";\"b\";\"c\";\"d\"]\n                 [\"d\";\"c\";\"b\";\"a\"] \n                 \"sample: rev 2\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"malayalam\" \n                 true\n                 \"sample: palindrome 1\"\n    ); \n    (fun () -> mkTest \n                 palindrome \n                 \"myxomatosis\" \n                 false\n                 \"sample: palindrome 2\"\n    )] \n\nlet _ =\n  let report = List.map doTest (sampleTests) in\n  let _ = List.iter print130 (report@([scoreMsg()])) in\n  let _ = print130 (\"Compiled\\n\") in\n    (!score, !max)\n","file":"hw1.ml"}
{"ocaml":[{"in":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n","type":"","out":""},{"in":"let ans0 = Node (2, Node (1, Leaf, Leaf)\n, Node (3, Leaf, Leaf))","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet ans0 = Node (2, (Node (1, Leaf, Leaf)), (Node (3, Leaf, Leaf)));;\n","type":"","out":""},{"in":"let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec flerb xs =\n  match xs with | [] -> Leaf | x::xs' -> Node (x, Leaf, (flerb xs'));;\n","type":"","out":""},{"in":"let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n","type":"","out":""},{"in":"let ans = glub (fun x -> 2 * x) ans0","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet ans0 = Node (2, (Node (1, Leaf, Leaf)), (Node (3, Leaf, Leaf)));;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n\nlet ans = glub (fun x  -> 2 * x) ans0;;\n","type":"","out":""},{"in":"type 'a option = None | Some of 'a","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n","type":"","out":""},{"in":"let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet safeDiv num den = match den with | 0 -> None | _ -> Some (num / den);;\n","type":"","out":""}],"event":{"phrases":["type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree","let ans0 = Node (2, Node (1, Leaf, Leaf)\n, Node (3, Leaf, Leaf))","let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","let ans = glub (fun x -> 2 * x) ans0","type 'a option = None | Some of 'a","let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)"],"region":{"start":0,"stop":451},"type":"eval"},"cursor":451,"time":1.446705283984257e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n| _ -> Some (num / den)\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlookup \"a\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)]\r\nlookup \"z\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)","min":"","type":"syntax","out":"Characters 193-195:\n  lookup \"z\" [(\"a\", 1); (\"b\", 2), (\"a\", 10);;\n                                           ^^\nError: Syntax error\n"}],"event":{"phrases":["","let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlookup \"a\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)]\r\nlookup \"z\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)"],"region":{"start":451,"stop":646},"type":"eval"},"cursor":648,"time":1.446705739589693e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\n                                               lookup \"a\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)]\r\nlookup \"z\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)]\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n","type":"","out":""},{"in":"let ans0 = Node (2, Node (1, Leaf, Leaf)\n, Node (3, Leaf, Leaf))","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet ans0 = Node (2, (Node (1, Leaf, Leaf)), (Node (3, Leaf, Leaf)));;\n","type":"","out":""},{"in":"let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec flerb xs =\n  match xs with | [] -> Leaf | x::xs' -> Node (x, Leaf, (flerb xs'));;\n","type":"","out":""},{"in":"let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n","type":"","out":""},{"in":"let ans = glub (fun x -> 2 * x) ans0","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet ans0 = Node (2, (Node (1, Leaf, Leaf)), (Node (3, Leaf, Leaf)));;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n\nlet ans = glub (fun x  -> 2 * x) ans0;;\n","type":"","out":""},{"in":"type 'a option = None | Some of 'a","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n","type":"","out":""},{"in":"let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet safeDiv num den = match den with | 0 -> None | _ -> Some (num / den);;\n","type":"","out":""},{"in":"let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n","type":"","out":""},{"in":"let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)]","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet _ = lookup \"a\" [(\"a\", 1); ((\"b\", 2), (\"a\", 10))];;\n","type":"type","out":"Characters 30-38:\n  let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)];;\n                                ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n"},{"in":"let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)]","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet _ = lookup \"z\" [(\"a\", 1); ((\"b\", 2), (\"a\", 10))];;\n","type":"type","out":"Characters 30-38:\n  let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)];;\n                                ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type string\n"}],"event":{"phrases":["type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree","let ans0 = Node (2, Node (1, Leaf, Leaf)\n, Node (3, Leaf, Leaf))","let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","let ans = glub (fun x -> 2 * x) ans0","type 'a option = None | Some of 'a","let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)","let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl","let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)]","let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)]"],"region":{"start":0,"stop":664},"type":"eval"},"cursor":667,"time":1.44670576614871e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2), (\"a\", 10)]\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)];;\n","type":"","out":""},{"in":"let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)];;\n","type":"","out":""}],"event":{"phrases":["","let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]"],"region":{"start":558,"stop":664},"type":"eval"},"cursor":661,"time":1.446705795558166e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let lift1 f xo = match xo with\n| None -> None\n| Some x -> Some (f x)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n","type":"","out":""}],"event":{"phrases":["","let lift1 f xo = match xo with\n| None -> None\n| Some x -> Some (f x)"],"region":{"start":664,"stop":734},"type":"eval"},"cursor":737,"time":1.446705965163605e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n| Some x -> Some (f x)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = lift1  string_of_int (Some 1)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n\nlet _ = lift1 string_of_int (Some 1);;\n","type":"","out":""}],"event":{"phrases":["","let _ = lift1  string_of_int (Some 1)"],"region":{"start":734,"stop":773},"type":"eval"},"cursor":773,"time":1.446705985165478e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int (Some 1)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = lift1  string_of_int None","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n\nlet _ = lift1 string_of_int None;;\n","type":"","out":""}],"event":{"phrases":["","let _ = lift1  string_of_int None"],"region":{"start":734,"stop":769},"type":"eval"},"cursor":769,"time":1.446705994584661e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let lift2 f xo yo = match (xo,yo) with\n| (Some x, Some y) -> Some (f xo yo)\n| (_,_) -> None","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f xo yo) | (_,_) -> None;;\n","type":"","out":""},{"in":"let _ = lift2 (+) (Some 1) (Some 10)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f xo yo) | (_,_) -> None;;\n\nlet _ = lift2 (+) (Some 1) (Some 10);;\n","type":"type","out":"Characters 14-17:\n  let _ = lift2 (+) (Some 1) (Some 10);;\n                ^^^\nError: This expression has type int -> int -> int\n       but an expression was expected of type 'a option -> 'b option -> 'c\n       Type int is not compatible with type 'a option \n"}],"event":{"phrases":["","let lift2 f xo yo = match (xo,yo) with\n| (Some x, Some y) -> Some (f xo yo)\n| (_,_) -> None","let _ = lift2 (+) (Some 1) (Some 10)"],"region":{"start":769,"stop":900},"type":"eval"},"cursor":900,"time":1.446706110347662e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f xo yo)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let lift2 f xo yo = match (xo,yo) with\n| (Some x, Some y) -> Some (f x y)\n| (_,_) -> None","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n","type":"","out":""},{"in":"let _ = lift2 (+) (Some 1) (Some 10)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (+) (Some 1) (Some 10);;\n","type":"","out":""}],"event":{"phrases":["","let lift2 f xo yo = match (xo,yo) with\n| (Some x, Some y) -> Some (f x y)\n| (_,_) -> None","let _ = lift2 (+) (Some 1) (Some 10)"],"region":{"start":769,"stop":898},"type":"eval"},"cursor":898,"time":1.446706132771506e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = lift2 (+) (None) (Some 10)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (+) None (Some 10);;\n","type":"","out":""}],"event":{"phrases":["","let _ = lift2 (+) (None) (Some 10)"],"region":{"start":898,"stop":934},"type":"eval"},"cursor":936,"time":1.44670614255576e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (None) (Some 10);;\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = lift2 (+) (Some 1) (None)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (+) (Some 1) None;;\n","type":"","out":""}],"event":{"phrases":["","let _ = lift2 (+) (Some 1) (None)"],"region":{"start":898,"stop":933},"type":"eval"},"cursor":935,"time":1.446706158979605e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"\n| [] -> Leaf","min":"","type":"syntax","out":"Characters 1-2:\n  | [] -> Leaf;;\n  ^\nError: Syntax error\n"}],"event":{"phrases":["\n| [] -> Leaf"],"region":{"start":151,"stop":164},"type":"eval"},"cursor":151,"time":1.446706377539633e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\nlet _ = lift1 (!) Some 2\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec flerb xs =\n  match xs with | [] -> Leaf | x::xs' -> Node (x, Leaf, (flerb xs'));;\n","type":"","out":""},{"in":"let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n","type":"","out":""},{"in":"let ans = glub (fun x -> 2 * x) ans0","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet ans0 = Node (2, (Node (1, Leaf, Leaf)), (Node (3, Leaf, Leaf)));;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n\nlet ans = glub (fun x  -> 2 * x) ans0;;\n","type":"","out":""},{"in":"type 'a option = None | Some of 'a","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n","type":"","out":""},{"in":"let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet safeDiv num den = match den with | 0 -> None | _ -> Some (num / den);;\n","type":"","out":""},{"in":"let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n","type":"","out":""},{"in":"let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)];;\n","type":"","out":""},{"in":"let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)];;\n","type":"","out":""},{"in":"let lift1 f xo = match xo with\n| None -> None\n| Some x -> Some (f x)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n","type":"","out":""},{"in":"let _ = lift1  string_of_int None","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n\nlet _ = lift1 string_of_int None;;\n","type":"","out":""},{"in":"let lift2 f xo yo = match (xo,yo) with\n| (Some x, Some y) -> Some (f x y)\n| (_,_) -> None","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n","type":"","out":""},{"in":"let _ = lift2 (+) (Some 1) (Some 10)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (+) (Some 1) (Some 10);;\n","type":"","out":""},{"in":"let _ = lift2 (+) (Some 1) (None)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (+) (Some 1) None;;\n","type":"","out":""}],"event":{"phrases":["","let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","let ans = glub (fun x -> 2 * x) ans0","type 'a option = None | Some of 'a","let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)","let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl","let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","let lift1 f xo = match xo with\n| None -> None\n| Some x -> Some (f x)","let _ = lift1  string_of_int None","let lift2 f xo yo = match (xo,yo) with\n| (Some x, Some y) -> Some (f x y)\n| (_,_) -> None","let _ = lift2 (+) (Some 1) (Some 10)","let _ = lift2 (+) (Some 1) (None)"],"region":{"start":117,"stop":933},"type":"eval"},"cursor":935,"time":1.446706389235401e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = lift1 (!) (Some 2)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n\nlet _ = lift1 (!) (Some 2);;\n","type":"type","out":"Characters 24-25:\n  let _ = lift1 (!) (Some 2);;\n                          ^\nError: This expression has type int but an expression was expected of type\n         'a ref\n"}],"event":{"phrases":["","let _ = lift1 (!) (Some 2)"],"region":{"start":933,"stop":963},"type":"eval"},"cursor":963,"time":1.446706401147729e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\nlet _ = lift1 (!) (Some 2)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = lift1 (-) (Some 2)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n\nlet _ = lift1 (-) (Some 2);;\n","type":"","out":""}],"event":{"phrases":["","let _ = lift1 (-) (Some 2)"],"region":{"start":933,"stop":963},"type":"eval"},"cursor":964,"time":1.446706409583327e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\nlet _ = lift1 (-) (Some 2)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = lift2 (-) (Some 0) (Some 2)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (-) (Some 0) (Some 2);;\n","type":"","out":""}],"event":{"phrases":["","let _ = lift2 (-) (Some 0) (Some 2)"],"region":{"start":933,"stop":972},"type":"eval"},"cursor":972,"time":1.44670646173223e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\nlet _ = lift2 (-) (Some 0) (Some 2)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"type expr = Var of string (* variable *)\n| Con of int (* constant *)\n| Neg of expr (* negation of an expression *)\n| Plus of expr * expr","min":"\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr\n  | Plus of expr* expr;;\n","type":"","out":""},{"in":"\nlet rec eval env e =  match e with\n| Var x -> lookup x env\n| Con i -> Some i\n| Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1","min":"","type":"syntax","out":"Characters 130-131:\n  | Plus (e1;;\n         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"phrases":["","type expr = Var of string (* variable *)\n| Con of int (* constant *)\n| Neg of expr (* negation of an expression *)\n| Plus of expr * expr","\nlet rec eval env e =  match e with\n| Var x -> lookup x env\n| Con i -> Some i\n| Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1"],"region":{"start":972,"stop":1274},"type":"eval"},"cursor":1319,"time":1.446706566148987e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r          \nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\nlet _ = lift2 (-) (Some 0) (Some 2)\n\ntype expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\n  let rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n| Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n","type":"","out":""},{"in":"let ans0 = Node (2, Node (1, Leaf, Leaf)\n, Node (3, Leaf, Leaf))","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet ans0 = Node (2, (Node (1, Leaf, Leaf)), (Node (3, Leaf, Leaf)));;\n","type":"","out":""},{"in":"let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec flerb xs =\n  match xs with | [] -> Leaf | x::xs' -> Node (x, Leaf, (flerb xs'));;\n","type":"","out":""},{"in":"let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n","type":"","out":""},{"in":"let ans = glub (fun x -> 2 * x) ans0","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet ans0 = Node (2, (Node (1, Leaf, Leaf)), (Node (3, Leaf, Leaf)));;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n\nlet ans = glub (fun x  -> 2 * x) ans0;;\n","type":"","out":""},{"in":"type 'a option = None | Some of 'a","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n","type":"","out":""},{"in":"let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet safeDiv num den = match den with | 0 -> None | _ -> Some (num / den);;\n","type":"","out":""},{"in":"let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n","type":"","out":""},{"in":"let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)];;\n","type":"","out":""},{"in":"\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)","min":"","type":"syntax","out":"Characters 50-52:\n  let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10);;\n                                                   ^^\nError: Syntax error\n"},{"in":"\nlet lift1 f xo = match xo with\n| None -> None\n| Some ","min":"","type":"syntax","out":"Characters 54-56:\n  | Some ;;\n         ^^\nError: Syntax error\n"},{"in":"\nlet _ = lift1  string_of_int Non","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n\nlet _ = lift1 string_of_int Non;;\n","type":"type","out":"Characters 30-33:\n  let _ = lift1  string_of_int Non;;\n                               ^^^\nError: This variant expression is expected to have type int option\n       The constructor Non does not belong to type option\n"},{"in":"\nlet lift2 f xo yo = match (xo,yo) with\n| (Some x, Some","min":"","type":"syntax","out":"Characters 55-57:\n  | (Some x, Some;;\n                 ^^\nError: Syntax error: pattern expected.\n"},{"in":"\nlet _ = lift2 (+) (Some 1) (Some 10","min":"","type":"syntax","out":"Characters 28-29:\n  let _ = lift2 (+) (Some 1) (Some 10;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"\nlet _ = lift2 (+) (Some 1) (None","min":"","type":"syntax","out":"Characters 28-29:\n  let _ = lift2 (+) (Some 1) (None;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"\nlet _ = lift2 (-) (Some 0) (Some 2","min":"","type":"syntax","out":"Characters 28-29:\n  let _ = lift2 (-) (Some 0) (Some 2;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"\ntype expr = Var of string (* variable *)\n| Con of int (* constant *)\n| Neg of expr (* nega","min":"\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr;;\n","type":"","out":""}],"event":{"phrases":["type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree","let ans0 = Node (2, Node (1, Leaf, Leaf)\n, Node (3, Leaf, Leaf))","let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","let ans = glub (fun x -> 2 * x) ans0","type 'a option = None | Some of 'a","let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)","let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl","let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)","\nlet lift1 f xo = match xo with\n| None -> None\n| Some ","\nlet _ = lift1  string_of_int Non","\nlet lift2 f xo yo = match (xo,yo) with\n| (Some x, Some","\nlet _ = lift2 (+) (Some 1) (Some 10","\nlet _ = lift2 (+) (Some 1) (None","\nlet _ = lift2 (-) (Some 0) (Some 2","\ntype expr = Var of string (* variable *)\n| Con of int (* constant *)\n| Neg of expr (* nega"],"region":{"start":0,"stop":1067},"type":"eval"},"cursor":976,"time":1.4467066082482e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\n          let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\n  let lift1 f xo = match xo with\n  | None -> None\n                | Some x -> Some (f x)\n\n          let _ = lift1  string_of_int None\n\n  let lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n    | (_,_) -> None\n\n          let _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\n          let _ = lift2 (-) (Some 0) (Some 2)\n\n\n          type expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n                    | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\n  let rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n| Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)","min":"","type":"syntax","out":"Characters 50-52:\n  let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10);;\n                                                   ^^\nError: Syntax error\n"},{"in":"\nlet lift1 f xo = match xo with\n| None -> None\n| Some ","min":"","type":"syntax","out":"Characters 54-56:\n  | Some ;;\n         ^^\nError: Syntax error\n"},{"in":"\nlet _ = lift1  string_of_int Non","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n\nlet _ = lift1 string_of_int Non;;\n","type":"type","out":"Characters 30-33:\n  let _ = lift1  string_of_int Non;;\n                               ^^^\nError: This variant expression is expected to have type int option\n       The constructor Non does not belong to type option\n"},{"in":"\nlet lift2 f xo yo = match (xo,yo) with\n| (Some x, Some","min":"","type":"syntax","out":"Characters 55-57:\n  | (Some x, Some;;\n                 ^^\nError: Syntax error: pattern expected.\n"},{"in":"\nlet _ = lift2 (+) (Some 1) (Some 10","min":"","type":"syntax","out":"Characters 28-29:\n  let _ = lift2 (+) (Some 1) (Some 10;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"\nlet _ = lift2 (+) (Some 1) (None","min":"","type":"syntax","out":"Characters 28-29:\n  let _ = lift2 (+) (Some 1) (None;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"\nlet _ = lift2 (-) (Some 0) (Some 2","min":"","type":"syntax","out":"Characters 28-29:\n  let _ = lift2 (-) (Some 0) (Some 2;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"\nlet rec eval env e =  match e with\n| Var x -> lookup x env\n| Con i -> Some i\n| Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1","min":"","type":"syntax","out":"Characters 130-131:\n  | Plus (e1;;\n         ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"phrases":["","\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)","\nlet lift1 f xo = match xo with\n| None -> None\n| Some ","\nlet _ = lift1  string_of_int Non","\nlet lift2 f xo yo = match (xo,yo) with\n| (Some x, Some","\nlet _ = lift2 (+) (Some 1) (Some 10","\nlet _ = lift2 (+) (Some 1) (None","\nlet _ = lift2 (-) (Some 0) (Some 2","\nlet rec eval env e =  match e with\n| Var x -> lookup x env\n| Con i -> Some i\n| Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1"],"region":{"start":611,"stop":1108},"type":"eval"},"cursor":975,"time":1.446706626807902e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\n          let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\n  let lift1 f xo = match xo with\n  | None -> None\n                | Some x -> Some (f x)\n\n          let _ = lift1  string_of_int None\n\n  let lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n    | (_,_) -> None\n\n          let _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n          let _ = lift2 (-) (Some 0) (Some 2)\r\n\n  let rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n| Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)","min":"","type":"syntax","out":"Characters 50-52:\n  let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10);;\n                                                   ^^\nError: Syntax error\n"},{"in":"\nlet lift1 f xo = match xo with\n| None -> None\n| Some ","min":"","type":"syntax","out":"Characters 54-56:\n  | Some ;;\n         ^^\nError: Syntax error\n"},{"in":"\nlet _ = lift1  string_of_int Non","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n\nlet _ = lift1 string_of_int Non;;\n","type":"type","out":"Characters 30-33:\n  let _ = lift1  string_of_int Non;;\n                               ^^^\nError: This variant expression is expected to have type int option\n       The constructor Non does not belong to type option\n"},{"in":"\nlet lift2 f xo yo = match (xo,yo) with\n| (Some x, Some","min":"","type":"syntax","out":"Characters 55-57:\n  | (Some x, Some;;\n                 ^^\nError: Syntax error: pattern expected.\n"},{"in":"\nlet _ = lift2 (+) (Some 1) (Some 10","min":"","type":"syntax","out":"Characters 28-29:\n  let _ = lift2 (+) (Some 1) (Some 10;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"\nlet _ = lift2 (+) (Some 1) (None","min":"","type":"syntax","out":"Characters 28-29:\n  let _ = lift2 (+) (Some 1) (None;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"\nlet _ = lift2 (-) (Some 0) (Some 2","min":"","type":"syntax","out":"Characters 28-29:\n  let _ = lift2 (-) (Some 0) (Some 2;;\n                             ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"phrases":["","\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)","\nlet lift1 f xo = match xo with\n| None -> None\n| Some ","\nlet _ = lift1  string_of_int Non","\nlet lift2 f xo yo = match (xo,yo) with\n| (Some x, Some","\nlet _ = lift2 (+) (Some 1) (Some 10","\nlet _ = lift2 (+) (Some 1) (None","\nlet _ = lift2 (-) (Some 0) (Some 2"],"region":{"start":611,"stop":973},"type":"eval"},"cursor":975,"time":1.446706648324751e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\n          let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\n  let lift1 f xo = match xo with\n  | None -> None\n                | Some x -> Some (f x)\n\n          let _ = lift1  string_of_int None\n\n  let lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n    | (_,_) -> None\n\n          let _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\n          let _ = lift2 (-) (Some 0) (Some 2)\n\n\n\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n","type":"","out":""},{"in":"let ans0 = Node (2, Node (1, Leaf, Leaf)\n, Node (3, Leaf, Leaf))","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet ans0 = Node (2, (Node (1, Leaf, Leaf)), (Node (3, Leaf, Leaf)));;\n","type":"","out":""},{"in":"let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec flerb xs =\n  match xs with | [] -> Leaf | x::xs' -> Node (x, Leaf, (flerb xs'));;\n","type":"","out":""},{"in":"let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n","type":"","out":""},{"in":"let ans = glub (fun x -> 2 * x) ans0","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet ans0 = Node (2, (Node (1, Leaf, Leaf)), (Node (3, Leaf, Leaf)));;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n\nlet ans = glub (fun x  -> 2 * x) ans0;;\n","type":"","out":""},{"in":"type 'a option = None | Some of 'a","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n","type":"","out":""},{"in":"let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet safeDiv num den = match den with | 0 -> None | _ -> Some (num / den);;\n","type":"","out":""},{"in":"let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n","type":"","out":""},{"in":"let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)];;\n","type":"","out":""},{"in":"let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)];;\n","type":"","out":""},{"in":"let lift1 f xo = match xo with\n| None -> None\n| Some x -> Some (f x)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n","type":"","out":""},{"in":"let _ = lift1  string_of_int None","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n\nlet _ = lift1 string_of_int None;;\n","type":"","out":""},{"in":"let lift2 f xo yo = match (xo,yo) with\n| (Some x, Some y) -> Some (f x y)\n| (_,_) -> None","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n","type":"","out":""},{"in":"let _ = lift2 (+) (Some 1) (Some 10)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (+) (Some 1) (Some 10);;\n","type":"","out":""},{"in":"let _ = lift2 (+) (Some 1) (None)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (+) (Some 1) None;;\n","type":"","out":""},{"in":"let _ = lift2 (-) (Some 0) (Some 2)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (-) (Some 0) (Some 2);;\n","type":"","out":""},{"in":"type expr = Var of string (* variable *)\n| Con of int (* constant *)\n| Neg of expr (* negation of an expression *)\n| Plus of expr * expr","min":"\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr\n  | Plus of expr* expr;;\n","type":"","out":""},{"in":"let rec eval env e =  match e with\n| Var x -> lookup x env\n| Con i -> Some i\n| Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr\n  | Plus of expr* expr;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet rec eval env e =\n  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2);;\n","type":"","out":""}],"event":{"phrases":["type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree","let ans0 = Node (2, Node (1, Leaf, Leaf)\n, Node (3, Leaf, Leaf))","let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","let ans = glub (fun x -> 2 * x) ans0","type 'a option = None | Some of 'a","let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)","let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl","let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","let lift1 f xo = match xo with\n| None -> None\n| Some x -> Some (f x)","let _ = lift1  string_of_int None","let lift2 f xo yo = match (xo,yo) with\n| (Some x, Some y) -> Some (f x y)\n| (_,_) -> None","let _ = lift2 (+) (Some 1) (Some 10)","let _ = lift2 (+) (Some 1) (None)","let _ = lift2 (-) (Some 0) (Some 2)","type expr = Var of string (* variable *)\n| Con of int (* constant *)\n| Neg of expr (* negation of an expression *)\n| Plus of expr * expr","let rec eval env e =  match e with\n| Var x -> lookup x env\n| Con i -> Some i\n| Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)"],"region":{"start":0,"stop":1322},"type":"eval"},"cursor":1322,"time":1.446706658507492e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\nlet _ = lift2 (-) (Some 0) (Some 2)\n\n\ntype expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\nlet rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Var \"y\"))","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr\n  | Plus of expr* expr;;\n\nlet rec eval env e =\n  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2);;\n\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus ((Var \"x\"), (Var \"y\")));;\n","type":"","out":""}],"event":{"phrases":["","let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Var \"y\"))"],"region":{"start":1322,"stop":1395},"type":"eval"},"cursor":1398,"time":1.4467066746431e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\nlet _ = lift2 (-) (Some 0) (Some 2)\n\n\ntype expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\nlet rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\n\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Var \"y\"));;\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20)","min":"","type":"syntax","out":"Characters 47-48:\n  let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20);;\n                                                ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"phrases":["","\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20)"],"region":{"start":1395,"stop":1468},"type":"eval"},"cursor":1472,"time":1.446706682477438e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\nlet _ = lift2 (-) (Some 0) (Some 2)\n\n\ntype expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\nlet rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\n\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Var \"y\"));;\r\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20));;\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20)","min":"","type":"syntax","out":"Characters 47-48:\n  let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20);;\n                                                ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"phrases":["","\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20)"],"region":{"start":1322,"stop":1395},"type":"eval"},"cursor":1396,"time":1.446706696752659e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\nlet _ = lift2 (-) (Some 0) (Some 2)\n\n\ntype expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\nlet rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\n\n\r\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20))\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20)","min":"","type":"syntax","out":"Characters 47-48:\n  let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20);;\n                                                ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":")","min":"","type":"syntax","out":"Characters 0-1:\n  );;\n  ^\nError: Syntax error\n"}],"event":{"phrases":["","\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20)",")"],"region":{"start":1322,"stop":1396},"type":"eval"},"cursor":1397,"time":1.446706710004531e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\nlet _ = lift2 (-) (Some 0) (Some 2)\n\n\ntype expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\nlet rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\n\n\r\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20))]\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20)","min":"","type":"syntax","out":"Characters 47-48:\n  let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20);;\n                                                ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"phrases":["","\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20)"],"region":{"start":1322,"stop":1395},"type":"eval"},"cursor":1396,"time":1.446706740160798e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\nlet _ = lift2 (-) (Some 0) (Some 2)\n\n\ntype expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\nlet rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\n\n\r\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20))\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n","type":"","out":""},{"in":"let ans0 = Node (2, Node (1, Leaf, Leaf)\n, Node (3, Leaf, Leaf))","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet ans0 = Node (2, (Node (1, Leaf, Leaf)), (Node (3, Leaf, Leaf)));;\n","type":"","out":""},{"in":"let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec flerb xs =\n  match xs with | [] -> Leaf | x::xs' -> Node (x, Leaf, (flerb xs'));;\n","type":"","out":""},{"in":"let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n","type":"","out":""},{"in":"let ans = glub (fun x -> 2 * x) ans0","min":"\ntype 'a tree =\n  | Leaf\n  | Node of 'a* 'a tree* 'a tree;;\n\nlet ans0 = Node (2, (Node (1, Leaf, Leaf)), (Node (3, Leaf, Leaf)));;\n\nlet rec glub f t =\n  match t with\n  | Leaf  -> Leaf\n  | Node (x,l,r) -> Node ((f x), (glub f l), (glub f r));;\n\nlet ans = glub (fun x  -> 2 * x) ans0;;\n","type":"","out":""},{"in":"type 'a option = None | Some of 'a","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n","type":"","out":""},{"in":"let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet safeDiv num den = match den with | 0 -> None | _ -> Some (num / den);;\n","type":"","out":""},{"in":"let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n","type":"","out":""},{"in":"let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)];;\n","type":"","out":""},{"in":"let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)];;\n","type":"","out":""},{"in":"let lift1 f xo = match xo with\n| None -> None\n| Some x -> Some (f x)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n","type":"","out":""},{"in":"let _ = lift1  string_of_int None","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift1 f xo = match xo with | None  -> None | Some x -> Some (f x);;\n\nlet _ = lift1 string_of_int None;;\n","type":"","out":""},{"in":"let lift2 f xo yo = match (xo,yo) with\n| (Some x, Some y) -> Some (f x y)\n| (_,_) -> None","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n","type":"","out":""},{"in":"let _ = lift2 (+) (Some 1) (Some 10)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (+) (Some 1) (Some 10);;\n","type":"","out":""},{"in":"let _ = lift2 (+) (Some 1) (None)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (+) (Some 1) None;;\n","type":"","out":""},{"in":"let _ = lift2 (-) (Some 0) (Some 2)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet _ = lift2 (-) (Some 0) (Some 2);;\n","type":"","out":""},{"in":"type expr = Var of string (* variable *)\n| Con of int (* constant *)\n| Neg of expr (* negation of an expression *)\n| Plus of expr * expr","min":"\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr\n  | Plus of expr* expr;;\n","type":"","out":""},{"in":"let rec eval env e =  match e with\n| Var x -> lookup x env\n| Con i -> Some i\n| Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr\n  | Plus of expr* expr;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\nlet rec eval env e =\n  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2);;\n","type":"","out":""},{"in":"let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20))","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr\n  | Plus of expr* expr;;\n\nlet rec eval env e =\n  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2);;\n\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus ((Var \"x\"), (Con 20)));;\n","type":"","out":""}],"event":{"phrases":["type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree","let ans0 = Node (2, Node (1, Leaf, Leaf)\n, Node (3, Leaf, Leaf))","let rec flerb xs = match xs with\n| [] -> Leaf\n| x::xs' -> Node (x, Leaf, flerb xs')","let rec glub f t = match t with\n| Leaf -> Leaf\n| Node (x,l,r) -> Node (f x, glub f l, glub f r)","let ans = glub (fun x -> 2 * x) ans0","type 'a option = None | Some of 'a","let safeDiv num den = match den with\n| 0 -> None\n| _ -> Some (num / den)","let rec lookup k kvs = match kvs with\n| [] -> None\n| (c,v)::tl -> if (c = k) then Some v else lookup k tl","let _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","let _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]","let lift1 f xo = match xo with\n| None -> None\n| Some x -> Some (f x)","let _ = lift1  string_of_int None","let lift2 f xo yo = match (xo,yo) with\n| (Some x, Some y) -> Some (f x y)\n| (_,_) -> None","let _ = lift2 (+) (Some 1) (Some 10)","let _ = lift2 (+) (Some 1) (None)","let _ = lift2 (-) (Some 0) (Some 2)","type expr = Var of string (* variable *)\n| Con of int (* constant *)\n| Neg of expr (* negation of an expression *)\n| Plus of expr * expr","let rec eval env e =  match e with\n| Var x -> lookup x env\n| Con i -> Some i\n| Neg e' -> lift2 (-) (Some 0) (eval env e')\n| Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)","let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20))"],"region":{"start":0,"stop":1396},"type":"eval"},"cursor":1396,"time":1.446706748736346e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\nlet _ = lift2 (-) (Some 0) (Some 2)\n\n\ntype expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\nlet rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\n\n\r\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Con 20))\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Var \"z\"))","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr\n  | Plus of expr* expr;;\n\nlet rec eval env e =\n  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2);;\n\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus ((Var \"x\"), (Var \"z\")));;\n","type":"","out":""}],"event":{"phrases":["","let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Var \"z\"))"],"region":{"start":1322,"stop":1397},"type":"eval"},"cursor":1400,"time":1.446706771888817e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\nlet _ = lift2 (-) (Some 0) (Some 2)\n\n\ntype expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\nlet rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\n\n\r  \nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Plus (Var \"x\", Var \"z\"));;\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Neg (Var \"y\"))","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr\n  | Plus of expr* expr;;\n\nlet rec eval env e =\n  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2);;\n\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Neg (Var \"y\"));;\n","type":"","out":""}],"event":{"phrases":["","let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Neg (Var \"y\"))"],"region":{"start":1322,"stop":1387},"type":"eval"},"cursor":1390,"time":1.446706784489581e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\nlet _ = lift2 (-) (Some 0) (Some 2)\n\n\ntype expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\nlet rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\n\n\r  \nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Neg (Var \"y\"));;\r\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Neg (Var \"z\"))","min":"\ntype 'a option =\n  | None\n  | Some of 'a;;\n\nlet lift2 f xo yo =\n  match (xo, yo) with | (Some x,Some y) -> Some (f x y) | (_,_) -> None;;\n\nlet rec lookup k kvs =\n  match kvs with\n  | [] -> None\n  | (c,v)::tl -> if c = k then Some v else lookup k tl;;\n\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr\n  | Plus of expr* expr;;\n\nlet rec eval env e =\n  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2);;\n\nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Neg (Var \"z\"));;\n","type":"","out":""}],"event":{"phrases":["","let _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Neg (Var \"z\"))"],"region":{"start":1322,"stop":1387},"type":"eval"},"cursor":1390,"time":1.446706796281285e9,"body":"type 'a tree = Leaf | Node of 'a * 'a tree * 'a tree\nlet ans0 = Node (2, Node (1, Leaf, Leaf)\n                , Node (3, Leaf, Leaf))\n\nlet rec flerb xs = match xs with\n  | [] -> Leaf\n  | x::xs' -> Node (x, Leaf, flerb xs')\r\n\n\nlet rec glub f t = match t with\n  | Leaf -> Leaf\n  | Node (x,l,r) -> Node (f x, glub f l, glub f r)\r\nlet ans = glub (fun x -> 2 * x) ans0\n\n\n\ntype 'a option = None | Some of 'a\n\nlet safeDiv num den = match den with\n  | 0 -> None\n  | _ -> Some (num / den)\n\nlet rec lookup k kvs = match kvs with\n  | [] -> None\n  | (c,v)::tl -> if (c = k) then Some v else lookup k tl\n\n\nlet _ = lookup \"a\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\r\nlet _ = lookup \"z\" [(\"a\", 1); (\"b\", 2); (\"a\", 10)]\n\nlet lift1 f xo = match xo with\n  | None -> None\n  | Some x -> Some (f x)\n\nlet _ = lift1  string_of_int None\n\nlet lift2 f xo yo = match (xo,yo) with\n  | (Some x, Some y) -> Some (f x y)\n  | (_,_) -> None\n\nlet _ = lift2 (+) (Some 1) (Some 10)\n\nlet _ = lift2 (+) (Some 1) (None);;\n\n\n\nlet _ = lift2 (-) (Some 0) (Some 2)\n\n\ntype expr = Var of string (*XXXXXXXXXX*)\n          | Con of int (*XXXXXXXXXX*)\n          | Neg of expr (*XXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n          | Plus of expr * expr (*XXXXXXXXXXXXXXXXXXXXXXXX*)\r\n\nlet rec eval env e =  match e with\n  | Var x -> lookup x env\n  | Con i -> Some i\n  | Neg e' -> lift2 (-) (Some 0) (eval env e')\n  | Plus (e1,e2) -> lift2 (+) (eval env e1) (eval env e2)\n\n\r  \nlet _ = eval [(\"x\", 1); (\"y\", 2); (\"x\", 100)] (Neg (Var \"z\"));;\r\r\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let test = fun f g x -> f (g x)","min":"\nlet test f g x = f (g x);;\n","type":"","out":""}],"event":{"phrases":["let test = fun f g x -> f (g x)"],"region":{"start":0,"stop":31},"type":"eval"},"cursor":31,"time":1.446709040887569e9,"body":"let test = fun f g x -> f (g x)\r\r\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let hmm f g x -> f(g x)","min":"","type":"syntax","out":"Characters 14-16:\n  let hmm f g x -> f(g x);;\n                ^^\nError: Syntax error\n"}],"event":{"phrases":["","let hmm f g x -> f(g x)"],"region":{"start":31,"stop":55},"type":"eval"},"cursor":55,"time":1.446709094811593e9,"body":"let test = fun f g x -> f (g x)\nlet hmm f g x -> f(g x)\r\r\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let hmm f g x = f(g x)","min":"\nlet hmm f g x = f (g x);;\n","type":"","out":""}],"event":{"phrases":["","let hmm f g x = f(g x)"],"region":{"start":31,"stop":54},"type":"eval"},"cursor":57,"time":1.446709102166363e9,"body":"let test = fun f g x -> f (g x)\nlet hmm f g x = f(g x)\r\r\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let hmm f g x = f(g x)\r\r\r","min":"","type":"type","out":"Characters 22-23:\n  let hmm f g x = f(g x);;\n                        ^\nError: Illegal character (\\r)\n"}],"event":{"phrases":["","let hmm f g x = f(g x)\r\r\r"],"region":{"start":31,"stop":57},"type":"eval"},"cursor":60,"time":1.44670939017131e9,"body":"let test = fun f g x -> f (g x)\nlet hmm f g x = f(g x)\r\r\r(+)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"(+)","min":"\nlet _ = (+);;\n","type":"","out":""}],"event":{"phrases":["(+)"],"region":{"start":0,"stop":3},"type":"eval"},"cursor":0,"time":1.446709398349411e9,"body":"(+)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"(<.>)","min":"\nlet _ = (<.>);;\n","type":"scope","out":"Characters 0-5:\n  (<.>);;\n  ^^^^^\nError: Unbound value <.>\n"}],"event":{"phrases":["(<.>)"],"region":{"start":0,"stop":5},"type":"eval"},"cursor":5,"time":1.446709411170803e9,"body":"(<.>)\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let test = fun f g x -> f (g x)","min":"\nlet test f g x = f (g x);;\n","type":"","out":""},{"in":"\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g","min":"","type":"type","out":"Characters 0-1:\n  let foo = fun x -> x + 10 in\n  ^\nError: Illegal character (\\r)\n"}],"event":{"phrases":["let test = fun f g x -> f (g x)","\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g"],"region":{"start":0,"stop":96},"type":"eval"},"cursor":124,"time":1.446709539004126e9,"body":"let test = fun f g x -> f (g x)\n\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet goo = test foo bar in\ngoo 0\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g","min":"","type":"type","out":"Characters 0-1:\n  let foo = fun x -> x + 10 in\n  ^\nError: Illegal character (\\r)\n"}],"event":{"phrases":["","\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g"],"region":{"start":31,"stop":98},"type":"eval"},"cursor":127,"time":1.44670954476711e9,"body":"let test = fun f g x -> f (g x)\n\n\n\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet goo = test foo bar in\ngoo 0\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let test = fun f g x -> f (g x)","min":"\nlet test f g x = f (g x);;\n","type":"","out":""},{"in":"\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g","min":"","type":"type","out":"Characters 0-1:\n  let foo = fun x -> x + 10 in\n  ^\nError: Illegal character (\\r)\n"}],"event":{"phrases":["let test = fun f g x -> f (g x)","\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g"],"region":{"start":0,"stop":98},"type":"eval"},"cursor":128,"time":1.446709552306052e9,"body":"let test = fun f g x -> f (g x)\n\n\n\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet goo = test foo bar in\ngoo 0\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let test = fun f g x -> f (g x);\n\n\n\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g","min":"","type":"type","out":"Characters 35-36:\n  let foo = fun x -> x + 10 in\n  ^\nError: Illegal character (\\r)\n"}],"event":{"phrases":["let test = fun f g x -> f (g x);\n\n\n\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g"],"region":{"start":0,"stop":99},"type":"eval"},"cursor":128,"time":1.446709559089361e9,"body":"let test = fun f g x -> f (g x);\n\n\n\r  let foo = fun x -> x + 10 in\n  let bar = fun x -> x * 10 in\nlet goo = test foo bar in\ngoo 0\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let test = fun f g x -> f (g x)","min":"\nlet test f g x = f (g x);;\n","type":"","out":""},{"in":"\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g","min":"","type":"type","out":"Characters 0-1:\n  let foo = fun x -> x + 10 in\n  ^\nError: Illegal character (\\r)\n"}],"event":{"phrases":["let test = fun f g x -> f (g x)","\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g"],"region":{"start":0,"stop":100},"type":"eval"},"cursor":130,"time":1.446709563526574e9,"body":"let test = fun f g x -> f (g x);;\n\n\n\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet goo = test foo bar in\ngoo 0\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g","min":"","type":"type","out":"Characters 0-1:\n  let foo = fun x -> x + 10 in\n  ^\nError: Illegal character (\\r)\n"}],"event":{"phrases":["","\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g"],"region":{"start":31,"stop":98},"type":"eval"},"cursor":125,"time":1.446709571294215e9,"body":"let test = fun f g x -> f (g x);;\n\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet goo = test foo bar in\ngoo 0\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"let test = fun f g x -> f (g x)","min":"\nlet test f g x = f (g x);;\n","type":"","out":""},{"in":"\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g","min":"","type":"type","out":"Characters 0-1:\n  let foo = fun x -> x + 10 in\n  ^\nError: Illegal character (\\r)\n"}],"event":{"phrases":["let test = fun f g x -> f (g x)","\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g"],"region":{"start":0,"stop":95},"type":"eval"},"cursor":123,"time":1.446709575224561e9,"body":"let test = fun f g x -> f (g x)\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet goo = test foo bar in\ngoo 0\r\r\r\r","file":"hw1.ml"}
{"ocaml":[{"in":"\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g","min":"","type":"type","out":"Characters 0-1:\n  let foo = fun x -> x + 10 in\n  ^\nError: Illegal character (\\r)\n"},{"in":"oo = test foo bar in\ngoo 0\r\r\rtype ('a,'b) eith","min":"","type":"syntax","out":"Characters 18-20:\n  oo = test foo bar in\n                    ^^\nError: Syntax error\n"}],"event":{"phrases":["","\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet g","oo = test foo bar in\ngoo 0\r\r\rtype ('a,'b) eith"],"region":{"start":31,"stop":141},"type":"eval"},"cursor":172,"time":1.446711148152446e9,"body":"let test = fun f g x -> f (g x)\rlet foo = fun x -> x + 10 in\nlet bar = fun x -> x * 10 in\nlet goo = test foo bar in\n                        goo 0\r\r\rtype ('a,'b) either = Left of 'a | Right of 'b\n\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"\r\rtype ('a,'b) either = Left of 'a | Right of ","min":"","type":"type","out":"Characters 0-1:\n  type ('a,'b) either = Left of 'a | Right of ;;\n  ^\nError: Illegal character (\\r)\n"}],"event":{"phrases":["\r\rtype ('a,'b) either = Left of 'a | Right of "],"region":{"start":0,"stop":46},"type":"eval"},"cursor":0,"time":1.446711152470606e9,"body":"\r\rtype ('a,'b) either = Left of 'a | Right of 'b\n\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"type ('a,'b) either = Left of 'a | Right of 'b","min":"\ntype ('a,'b) either =\n  | Left of 'a\n  | Right of 'b;;\n","type":"","out":""}],"event":{"phrases":["type ('a,'b) either = Left of 'a | Right of 'b"],"region":{"start":0,"stop":46},"type":"eval"},"cursor":49,"time":1.446711157588745e9,"body":"type ('a,'b) either = Left of 'a | Right of 'b\n\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = Left 3","min":"\ntype ('a,'b) either =\n  | Left of 'a\n  | Right of 'b;;\n\nlet _ = Left 3;;\n","type":"","out":""}],"event":{"phrases":["","let _ = Left 3"],"region":{"start":46,"stop":62},"type":"eval"},"cursor":63,"time":1.446711172725935e9,"body":"type ('a,'b) either = Left of 'a | Right of 'b\n\nlet _ = Left 3\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = Left 3","min":"\ntype ('a,'b) either =\n  | Left of 'a\n  | Right of 'b;;\n\nlet _ = Left 3;;\n","type":"","out":""},{"in":"let _ = Right 3","min":"\ntype ('a,'b) either =\n  | Left of 'a\n  | Right of 'b;;\n\nlet _ = Right 3;;\n","type":"","out":""}],"event":{"phrases":["","let _ = Left 3","let _ = Right 3"],"region":{"start":46,"stop":79},"type":"eval"},"cursor":79,"time":1.446711186130594e9,"body":"type ('a,'b) either = Left of 'a | Right of 'b\n\nlet _ = Left 3\n\nlet _ = Right 3\n","file":"hw1.ml"}
{"ocaml":[{"in":"type 'a set = Set of 'a list","min":"\ntype 'a set =\n  | Set of 'a list;;\n","type":"","out":""},{"in":"let empty = set []","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = set [];;\n","type":"scope","out":"Characters 12-15:\n  let empty = set [];;\n              ^^^\nError: Unbound value set\n"}],"event":{"phrases":["type 'a set = Set of 'a list","let empty = set []"],"region":{"start":0,"stop":48},"type":"eval"},"cursor":48,"time":1.446755650092623e9,"body":"type 'a set = Set of 'a list\n\nlet empty = set []\n","file":"hw1.ml"}
{"ocaml":[{"in":"let empty = [] set","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = [];;\n","type":"type","out":"Characters 12-18:\n  let empty = [] set;;\n              ^^^^^^\nError: The constructor [] expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}],"event":{"phrases":["","let empty = [] set"],"region":{"start":28,"stop":48},"type":"eval"},"cursor":49,"time":1.446755661105989e9,"body":"type 'a set = Set of 'a list\n\nlet empty = [] set\n","file":"hw1.ml"}
{"ocaml":[{"in":"let empty = Set []","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n","type":"","out":""}],"event":{"phrases":["","let empty = Set []"],"region":{"start":28,"stop":48},"type":"eval"},"cursor":48,"time":1.446755675989586e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n","file":"hw1.ml"}
{"ocaml":[{"in":"let member x s = match s with\n| Set [] -> false\n| Set h::tl -> if(h = x) then true else member x (Set tl)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet member x s =\n  match s with\n  | Set [] -> false\n  | (Set h)::tl -> if h = x then true else member x (Set tl);;\n","type":"type","out":"Characters 55-57:\n  | Set h::tl -> if(h = x) then true else member x (Set tl);;\n         ^^\nError: This variant pattern is expected to have type 'a set\n       The constructor :: does not belong to type set\n"}],"event":{"phrases":["","let member x s = match s with\n| Set [] -> false\n| Set h::tl -> if(h = x) then true else member x (Set tl)"],"region":{"start":48,"stop":155},"type":"eval"},"cursor":155,"time":1.44675579980794e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet member x s = match s with\n  | Set [] -> false\n  | Set h::tl -> if(h = x) then true else member x (Set tl)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n","type":"scope","out":"Characters 103-109:\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl);;\n                                                         ^^^^^^\nError: Unbound value member\n"}],"event":{"phrases":["","let member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)"],"region":{"start":48,"stop":170},"type":"eval"},"cursor":128,"time":1.446755849330391e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n","type":"","out":""}],"event":{"phrases":["","let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)"],"region":{"start":48,"stop":174},"type":"eval"},"cursor":175,"time":1.44675585780223e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let _ = member 5 test","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = member 5 test;;\n","type":"","out":""}],"event":{"phrases":["","let test = Set [1;2;3;4;5]","let _ = member 5 test"],"region":{"start":174,"stop":226},"type":"eval"},"cursor":226,"time":1.446755886299206e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet test = Set [1;2;3;4;5]\n\nlet _ = member 5 test\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = member 20 test","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = member 20 test;;\n","type":"","out":""}],"event":{"phrases":["","let _ = member 20 test"],"region":{"start":203,"stop":227},"type":"eval"},"cursor":228,"time":1.446755892053873e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet test = Set [1;2;3;4;5]\n\nlet _ = member 20 test\n","file":"hw1.ml"}
{"ocaml":[{"in":"let add x s = match s with\n| Set l -> l@x","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> l @ x;;\n","type":"","out":""},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""},{"in":"let _ = member 20 test","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = member 20 test;;\n","type":"","out":""},{"in":"let _ = add test hmm","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> l @ x;;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = add test hmm;;\n","type":"type","out":"Characters 12-16:\n  let _ = add test hmm;;\n              ^^^^\nError: This expression has type int set\n       but an expression was expected of type 'a list\n"}],"event":{"phrases":["","let add x s = match s with\n| Set l -> l@x","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]","let _ = member 20 test","let _ = add test hmm"],"region":{"start":174,"stop":320},"type":"eval"},"cursor":320,"time":1.446756022717818e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> l@x\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n","file":"hw1.ml"}
{"ocaml":[{"in":"let add x s = match s with\n| Set l -> match x with Set z -> l@z","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> l @ z);;\n","type":"","out":""},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""},{"in":"let _ = member 20 test","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = member 20 test;;\n","type":"","out":""},{"in":"let _ = add test hmm","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> l @ z);;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = add test hmm;;\n","type":"","out":""}],"event":{"phrases":["","let add x s = match s with\n| Set l -> match x with Set z -> l@z","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]","let _ = member 20 test","let _ = add test hmm"],"region":{"start":174,"stop":342},"type":"eval"},"cursor":343,"time":1.44675610625994e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> l@z\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n","file":"hw1.ml"}
{"ocaml":[{"in":"let add x s = match s with\n| Set l -> match x with Set z -> z@l","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n","type":"","out":""},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""}],"event":{"phrases":["","let add x s = match s with\n| Set l -> match x with Set z -> z@l","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]"],"region":{"start":174,"stop":296},"type":"eval"},"cursor":297,"time":1.446756119078567e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = member 20 test","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = member 20 test;;\n","type":"","out":""},{"in":"let _ = add test hmm","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = add test hmm;;\n","type":"","out":""}],"event":{"phrases":["","let _ = member 20 test","let _ = add test hmm"],"region":{"start":296,"stop":342},"type":"eval"},"cursor":343,"time":1.446756122489505e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n","file":"hw1.ml"}
{"ocaml":[{"in":"let s0 = empty","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet s0 = empty;;\n","type":"","out":""}],"event":{"phrases":["","let s0 = empty"],"region":{"start":342,"stop":358},"type":"eval"},"cursor":358,"time":1.446756188777504e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n","file":"hw1.ml"}
{"ocaml":[{"in":"let empty = Set [(false,false)]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [(false, false)];;\n","type":"","out":""},{"in":"let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n","type":"","out":""},{"in":"let add x s = match s with\n| Set l -> match x with Set z -> z@l","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n","type":"","out":""},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""},{"in":"let _ = member 20 test","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = member 20 test;;\n","type":"","out":""},{"in":"let _ = add test hmm","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = add test hmm;;\n","type":"","out":""},{"in":"let s0 = empty","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [(false, false)];;\n\nlet s0 = empty;;\n","type":"","out":""}],"event":{"phrases":["","let empty = Set [(false,false)]","let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","let add x s = match s with\n| Set l -> match x with Set z -> z@l","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]","let _ = member 20 test","let _ = add test hmm","let s0 = empty"],"region":{"start":28,"stop":371},"type":"eval"},"cursor":372,"time":1.446756345522807e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set [(false,false)]\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n","file":"hw1.ml"}
{"ocaml":[{"in":"let empty = Set [false,false]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [(false, false)];;\n","type":"","out":""},{"in":"let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n","type":"","out":""},{"in":"let add x s = match s with\n| Set l -> match x with Set z -> z@l","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n","type":"","out":""},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""},{"in":"let _ = member 20 test","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = member 20 test;;\n","type":"","out":""},{"in":"let _ = add test hmm","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = add test hmm;;\n","type":"","out":""},{"in":"let s0 = empty\n\n\n(mem 1 s0, mem 2 s0)","min":"","type":"scope","out":"Error: This expression has type (bool * bool) set\n       This is not a function; it cannot be applied.\nError: Unbound constructor Set\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 9-14:\n  let s0 = empty\n           ^^^^^\nError: This expression has type (bool * bool) set\n       This is not a function; it cannot be applied.\n"}],"event":{"phrases":["","let empty = Set [false,false]","let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","let add x s = match s with\n| Set l -> match x with Set z -> z@l","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]","let _ = member 20 test","let _ = add test hmm","let s0 = empty\n\n\n(mem 1 s0, mem 2 s0)"],"region":{"start":28,"stop":392},"type":"eval"},"cursor":372,"time":1.44675638996295e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set [false,false]\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\n\n           (mem 1 s0, mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = add test hmm\n\n\n\n\n(mem 1 s0, mem 2 s0)","min":"","type":"scope","out":"Error: This function has type 'a set -> 'a set -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor Set\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 8-11:\n  let _ = add test hmm\n          ^^^\nError: This function has type 'a set -> 'a set -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let _ = add test hmm\n\n\n\n\n(mem 1 s0, mem 2 s0)"],"region":{"start":331,"stop":378},"type":"eval"},"cursor":355,"time":1.446756410269524e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set [false,false]\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\n\n\n\n          (mem 1 s0, mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = add test hmm","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = add test hmm;;\n","type":"","out":""},{"in":"let s0 = empty\n\n\n(List.mem 1 s0, List.mem 2 s0)","min":"","type":"scope","out":"Error: This expression has type (bool * bool) set\n       This is not a function; it cannot be applied.\nError: Unbound constructor Set\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 9-14:\n  let s0 = empty\n           ^^^^^\nError: This expression has type (bool * bool) set\n       This is not a function; it cannot be applied.\n"}],"event":{"phrases":["","let _ = add test hmm","let s0 = empty\n\n\n(List.mem 1 s0, List.mem 2 s0)"],"region":{"start":331,"stop":402},"type":"eval"},"cursor":403,"time":1.446756502281474e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set [false,false]\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\n\n           (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"\n(List.mem 1 s0, List.mem 2 s0)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [(false, false)];;\n\nlet s0 = empty;;\n\nlet _ = ((List.mem 1 s0), (List.mem 2 s0));;\n","type":"type","out":"Characters 13-15:\n  (List.mem 1 s0, List.mem 2 s0);;\n              ^^\nError: This expression has type (bool * bool) set\n       but an expression was expected of type int list\n"}],"event":{"phrases":["\n(List.mem 1 s0, List.mem 2 s0)"],"region":{"start":371,"stop":403},"type":"eval"},"cursor":371,"time":1.446756510690879e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set [false;false]\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\n\n           (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let empty = Set [0;0]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [0; 0];;\n","type":"","out":""},{"in":"let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n","type":"","out":""},{"in":"let add x s = match s with\n| Set l -> match x with Set z -> z@l","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n","type":"","out":""},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""},{"in":"let _ = member 20 test","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = member 20 test;;\n","type":"","out":""},{"in":"let _ = add test hmm","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = add test hmm;;\n","type":"","out":""},{"in":"let s0 = empty","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [0; 0];;\n\nlet s0 = empty;;\n","type":"","out":""},{"in":"let _, _ = (List.mem 1 s0, List.mem 2 s0)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [0; 0];;\n\nlet s0 = empty;;\n\nlet (_,_) = ((List.mem 1 s0), (List.mem 2 s0));;\n","type":"type","out":"Characters 23-25:\n  let _, _ = (List.mem 1 s0, List.mem 2 s0);;\n                         ^^\nError: This expression has type int set\n       but an expression was expected of type int list\n"}],"event":{"phrases":["","let empty = Set [0;0]","let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","let add x s = match s with\n| Set l -> match x with Set z -> z@l","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]","let _ = member 20 test","let _ = add test hmm","let s0 = empty","let _, _ = (List.mem 1 s0, List.mem 2 s0)"],"region":{"start":28,"stop":404},"type":"eval"},"cursor":405,"time":1.446756535588683e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set [0;0]\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let empty = Set []","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n","type":"","out":""}],"event":{"phrases":["","let empty = Set []"],"region":{"start":28,"stop":48},"type":"eval"},"cursor":49,"time":1.446756561080502e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n","type":"","out":""},{"in":"let add x s = match s with\n| Set l -> match x with Set z -> z@l","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n","type":"","out":""},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""},{"in":"let _ = member 20 test","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = member 20 test;;\n","type":"","out":""},{"in":"let _ = add test hmm","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet test = Set [1; 2; 3; 4; 5];;\n\nlet _ = add test hmm;;\n","type":"","out":""},{"in":"let s0 = empty","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet s0 = empty;;\n","type":"","out":""},{"in":"let _, _ = (List.mem 1 s0, List.mem 2 s0)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet s0 = empty;;\n\nlet (_,_) = ((List.mem 1 s0), (List.mem 2 s0));;\n","type":"type","out":"Characters 23-25:\n  let _, _ = (List.mem 1 s0, List.mem 2 s0);;\n                         ^^\nError: This expression has type 'a set but an expression was expected of type\n         int list\n"}],"event":{"phrases":["","let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","let add x s = match s with\n| Set l -> match x with Set z -> z@l","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]","let _ = member 20 test","let _ = add test hmm","let s0 = empty","let _, _ = (List.mem 1 s0, List.mem 2 s0)"],"region":{"start":48,"stop":401},"type":"eval"},"cursor":402,"time":1.446756565502225e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let add x s = match s with\n| Set l -> match x with Set z -> z@l","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> z @ l);;\n","type":"","out":""}],"event":{"phrases":["let add x s = match s with\n| Set l -> match x with Set z -> z@l"],"region":{"start":177,"stop":240},"type":"eval"},"cursor":241,"time":1.446756637674686e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> z@l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let add x s = match s with\n| Set l -> match x with Set z -> Set (z@l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> Set (z @ l));;\n","type":"","out":""}],"event":{"phrases":["","let add x s = match s with\n| Set l -> match x with Set z -> Set (z@l)"],"region":{"start":174,"stop":246},"type":"eval"},"cursor":247,"time":1.446756652788745e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> Set (z@l)\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion Set(meh) s","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s =\n  match s with\n  | Set l -> let meh = List.filter (fun z  -> z = x) l in union Set meh s;;\n","type":"scope","out":"Characters 80-85:\n  union Set(meh) s;;\n  ^^^^^\nError: Unbound value union\n"}],"event":{"phrases":["","let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion Set(meh) s"],"region":{"start":246,"stop":344},"type":"eval"},"cursor":345,"time":1.446756823355499e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> Set (z@l)\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union Set(meh) s\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let union s1 s2 = match s2 with\n| Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> (match x with | Set z -> Set (z @ l));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n","type":"","out":""},{"in":"let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion Set(meh) s","min":"","type":"scope","out":"Error: This function has type 'a set -> 'a set set -> 'a set\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor Set\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 80-85:\n  union Set(meh) s;;\n  ^^^^^\nError: This function has type 'a set -> 'a set set -> 'a set\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let union s1 s2 = match s2 with\n| Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s","let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion Set(meh) s"],"region":{"start":246,"stop":433},"type":"eval"},"cursor":434,"time":1.446756836023491e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> Set (z@l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union Set(meh) s\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion (Set(meh) s)","min":"","type":"syntax","out":"Characters 96-97:\n  union (Set(meh) s);;\n                  ^\nError: Syntax error: operator expected.\n"}],"event":{"phrases":["","let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion (Set(meh) s)"],"region":{"start":335,"stop":435},"type":"eval"},"cursor":436,"time":1.446756870147715e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> Set (z@l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union (Set(meh) s)\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion Set(meh) Set(l)","min":"","type":"scope","out":"Error: This function has type 'a set -> 'a set set -> 'a set\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor Set\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 80-85:\n  union Set(meh) Set(l);;\n  ^^^^^\nError: This function has type 'a set -> 'a set set -> 'a set\n       It is applied to too many arguments; maybe you forgot a `;'.\n"},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion Set(meh) Set(l)","let test = Set [1;2;3;4;5]"],"region":{"start":335,"stop":466},"type":"eval"},"cursor":466,"time":1.446756884960447e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> match x with Set z -> Set (z@l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union Set(meh) Set(l)\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let add x s = match s with\n| Set l -> Set (z@l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (z @ l);;\n","type":"scope","out":"Characters 43-44:\n  | Set l -> Set (z@l);;\n                  ^\nError: Unbound value z\n"}],"event":{"phrases":["","let add x s = match s with\n| Set l -> Set (z@l)"],"region":{"start":174,"stop":224},"type":"eval"},"cursor":225,"time":1.44675693007512e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (z@l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union Set(meh) Set(l)\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let add x s = match s with\n| Set l -> Set (x@l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x @ l);;\n","type":"","out":""}],"event":{"phrases":["","let add x s = match s with\n| Set l -> Set (x@l)"],"region":{"start":174,"stop":224},"type":"eval"},"cursor":225,"time":1.446756937328305e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x@l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union Set(meh) Set(l)\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let add x s = match s with\n| Set l -> Set (x::l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n","type":"","out":""}],"event":{"phrases":["","let add x s = match s with\n| Set l -> Set (x::l)"],"region":{"start":174,"stop":225},"type":"eval"},"cursor":225,"time":1.446756956546904e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union Set(meh) Set(l)\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let union s1 s2 = match s2 with\n| Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n","type":"","out":""}],"event":{"phrases":["","let union s1 s2 = match s2 with\n| Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s"],"region":{"start":225,"stop":314},"type":"eval"},"cursor":315,"time":1.446756966150543e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union Set(meh) Set(l)\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion Set(meh) Set(l)","min":"","type":"scope","out":"Error: This function has type 'a set -> 'a set -> 'a set\n       It is applied to too many arguments; maybe you forgot a `;'.\nError: Unbound constructor Set\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 80-85:\n  union Set(meh) Set(l);;\n  ^^^^^\nError: This function has type 'a set -> 'a set -> 'a set\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}],"event":{"phrases":["","let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion Set(meh) Set(l)"],"region":{"start":314,"stop":417},"type":"eval"},"cursor":418,"time":1.446756970146056e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union Set(meh) Set(l)\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion s l","min":"","type":"scope","out":"Error: This expression has type 'a list\n       but an expression was expected of type 'a set\nError: Unbound constructor Set\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 88-89:\n  union s l;;\n          ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a set\n"}],"event":{"phrases":["","let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion s l"],"region":{"start":314,"stop":405},"type":"eval"},"cursor":405,"time":1.446756987392615e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union s l\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion s s","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet del x s =\n  match s with\n  | Set l -> let meh = List.filter (fun z  -> z = x) l in union s s;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion s s"],"region":{"start":314,"stop":405},"type":"eval"},"cursor":405,"time":1.446756993234797e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union s s\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> let meh = Set(List.filter (fun z -> z=x) l) in\nunion meh s","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet del x s =\n  match s with\n  | Set l -> let meh = Set (List.filter (fun z  -> z = x) l) in union meh s;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> let meh = Set(List.filter (fun z -> z=x) l) in\nunion meh s"],"region":{"start":314,"stop":412},"type":"eval"},"cursor":412,"time":1.44675701040433e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = Set(List.filter (fun z -> z=x) l) in\n        union meh s\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion (Set(meh) s)","min":"","type":"syntax","out":"Characters 96-97:\n  union (Set(meh) s);;\n                  ^\nError: Syntax error: operator expected.\n"}],"event":{"phrases":["","let del x s = match s with\n| Set l -> let meh = List.filter (fun z -> z=x) l in\nunion (Set(meh) s)"],"region":{"start":314,"stop":414},"type":"eval"},"cursor":414,"time":1.446757030280909e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = List.filter (fun z -> z=x) l in\n        union (Set(meh) s)\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> let meh = Set(List.filter (fun z -> z=x) l) in \nunion meh s","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet del x s =\n  match s with\n  | Set l -> let meh = Set (List.filter (fun z  -> z = x) l) in union meh s;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> let meh = Set(List.filter (fun z -> z=x) l) in \nunion meh s"],"region":{"start":314,"stop":413},"type":"eval"},"cursor":413,"time":1.446757052445217e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = Set(List.filter (fun z -> z=x) l) in \n        union meh s\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""},{"in":"let _ = del 12 hmm","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet del x s =\n  match s with\n  | Set l -> let meh = Set (List.filter (fun z  -> z = x) l) in union meh s;;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet _ = del 12 hmm;;\n","type":"","out":""}],"event":{"phrases":["","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]","let _ = del 12 hmm"],"region":{"start":413,"stop":490},"type":"eval"},"cursor":490,"time":1.446757062584661e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = Set(List.filter (fun z -> z=x) l) in \n        union meh s\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\n\nlet _ = del 12 hmm\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> let meh = Set(List.filter (fun z -> z=x) l) in \nSet(meh)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s =\n  match s with\n  | Set l -> let meh = Set (List.filter (fun z  -> z = x) l) in Set meh;;\n","type":"type","out":"Characters 89-94:\n  Set(meh);;\n     ^^^^^\nError: This expression has type 'a set but an expression was expected of type\n         'b list\n"},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""},{"in":"let _ = del 12 hmm","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet del x s =\n  match s with\n  | Set l -> let meh = Set (List.filter (fun z  -> z = x) l) in union meh s;;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet _ = del 12 hmm;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> let meh = Set(List.filter (fun z -> z=x) l) in \nSet(meh)","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]","let _ = del 12 hmm"],"region":{"start":314,"stop":487},"type":"eval"},"cursor":489,"time":1.446757144421728e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> let meh = Set(List.filter (fun z -> z=x) l) in \n        Set(meh)\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\n\nlet _ = del 12 hmm\n\n\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> meh = Set(List.filter (fun z -> z=x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s =\n  match s with | Set l -> meh = (Set (List.filter (fun z  -> z = x) l));;\n","type":"scope","out":"Characters 38-41:\n  | Set l -> meh = Set(List.filter (fun z -> z=x) l);;\n             ^^^\nError: Unbound value meh\n"},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""},{"in":"let _ = del 12 hmm","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet del x s =\n  match s with\n  | Set l -> let meh = Set (List.filter (fun z  -> z = x) l) in union meh s;;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet _ = del 12 hmm;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> meh = Set(List.filter (fun z -> z=x) l)","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]","let _ = del 12 hmm"],"region":{"start":314,"stop":471},"type":"eval"},"cursor":472,"time":1.446757158826545e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> meh = Set(List.filter (fun z -> z=x) l)\n\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\n\nlet _ = del 12 hmm\n\n\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z=x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z = x) l);;\n","type":"","out":""},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""},{"in":"let _ = del 12 hmm","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z = x) l);;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet _ = del 12 hmm;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z=x) l)","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]","let _ = del 12 hmm"],"region":{"start":314,"stop":465},"type":"eval"},"cursor":468,"time":1.446757164007601e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z=x) l)\n\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\n\nlet _ = del 12 hmm\n\n\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n","type":"","out":""},{"in":"let test = Set [1;2;3;4;5]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet test = Set [1; 2; 3; 4; 5];;\n","type":"","out":""},{"in":"let hmm = Set [12;23;14;56]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet hmm = Set [12; 23; 14; 56];;\n","type":"","out":""},{"in":"let _ = del 12 hmm","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet hmm = Set [12; 23; 14; 56];;\n\nlet _ = del 12 hmm;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","let test = Set [1;2;3;4;5]","let hmm = Set [12;23;14;56]","let _ = del 12 hmm"],"region":{"start":314,"stop":466},"type":"eval"},"cursor":466,"time":1.446757212557781e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet test = Set [1;2;3;4;5]\nlet hmm = Set [12;23;14;56]\n\n\nlet _ = del 12 hmm\n\n\n\nlet _ = member 20 test\n\nlet _ = add test hmm\n\nlet s0 = empty\n\nlet _, _ = (List.mem 1 s0, List.mem 2 s0)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (delete x e2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndelete x (free e1)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Var of string\n  | Con of int\n  | Neg of expr\n  | Plus of expr* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (delete x e2)\n  | Fun (x,e1) -> delete x (free e1);;\n","type":"type","out":"Characters 66-71:\n  | Const n          -> empty\n    ^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Const does not belong to type expr\n"}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (delete x e2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndelete x (free e1)"],"region":{"start":388,"stop":1163},"type":"eval"},"cursor":1163,"time":1.446758944801433e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (delete x e2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      delete x (free e1)\n","file":"hw1.ml"}
{"ocaml":[{"in":"type binop = Plus","min":"\ntype binop =\n  | Plus;;\n","type":"","out":""},{"in":"type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n","type":"","out":""},{"in":"\nlet rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (delete x e2)\n| Fun (x, e1)      ->\n(* free vars in a ","min":"","type":"syntax","out":"Characters 351-353:\n  ;;\n  ^^\nError: Syntax error\n"}],"event":{"phrases":["","type binop = Plus","type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","\nlet rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (delete x e2)\n| Fun (x, e1)      ->\n(* free vars in a "],"region":{"start":388,"stop":1250},"type":"eval"},"cursor":554,"time":1.446758956922601e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\r\n\n  let rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n      | Bin (e1, op, e2) ->\n       (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n        let f2 = free e2 in\n  union f1 f2\n      | App (e1, e2)     ->\n       (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n        let f2 = free e2 in\n  union f1 f2\n      | Let (x, e1, e2)  ->\n       (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n        let f2 = free e2 in\n  union f1 (delete x e2)\n      | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n        delete x (free e1)\n","file":"hw1.ml"}
{"event":{"type":"abort"},"cursor":553,"time":1.446758971684208e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (delete x e2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      delete x (free e1)\n","file":"hw1.ml"}
{"ocaml":[{"in":"type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n","type":"scope","out":"Characters 57-62:\n  | Bin of expr * binop * expr\n                  ^^^^^\nError: Unbound type constructor binop\n"},{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (delete x e2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndelete x (free e1)","min":"\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (delete x e2)\n  | Fun (x,e1) -> delete x (free e1);;\n","type":"scope","out":"Characters 32-35:\n  | Var x            -> add x empty\n    ^^^\nError: Unbound constructor Var\n"}],"event":{"phrases":["","type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (delete x e2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndelete x (free e1)"],"region":{"start":408,"stop":1325},"type":"eval"},"cursor":1326,"time":1.446758974393558e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (delete x e2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      delete x (free e1)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x e2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x e2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"scope","out":"Characters 32-35:\n  | Var x            -> add x empty\n    ^^^\nError: Unbound constructor Var\n"}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x e2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)"],"region":{"start":552,"stop":1319},"type":"eval"},"cursor":1320,"time":1.44675898706061e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x e2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"scope","out":"Characters 32-35:\n  | Var x            -> add x empty\n    ^^^\nError: Unbound constructor Var\n"}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)"],"region":{"start":552,"stop":1319},"type":"eval"},"cursor":1319,"time":1.446759003947774e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let isWellFormed e = free e","min":"\nlet isWellFormed e = free e;;\n","type":"scope","out":"Characters 21-25:\n  let isWellFormed e = free e;;\n                       ^^^^\nError: Unbound value free\n"}],"event":{"phrases":["","let isWellFormed e = free e"],"region":{"start":1319,"stop":1348},"type":"eval"},"cursor":1349,"time":1.446759080830794e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n","file":"hw1.ml"}
{"ocaml":[{"in":"let e1’ = Bin (Const 1, Plus, Var \"x\")\n(","min":"","type":"type","out":"Characters 7-8:\n  let e1’ = Bin (Const 1, Plus, Var \"x\")\n         ^\nError: Illegal character (\\128)\n"},{"in":"let e2’ = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"","type":"type","out":"Characters 7-8:\n  let e2’ = Let (\"y\", Const 2,\n         ^\nError: Illegal character (\\128)\n"},{"in":"let e3’ = App (Let (\"z\", Const 10,\nFun (\"y\", Plus (Var \"y\", Plus, Var \"z\")))\n,Var \"z\")","min":"","type":"type","out":"Characters 7-8:\n  let e3’ = App (Let (\"z\", Const 10,\n         ^\nError: Illegal character (\\128)\n"}],"event":{"phrases":["","let e1’ = Bin (Const 1, Plus, Var \"x\")\n(","let e2’ = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3’ = App (Let (\"z\", Const 10,\nFun (\"y\", Plus (Var \"y\", Plus, Var \"z\")))\n,Var \"z\")"],"region":{"start":1348,"stop":1636},"type":"eval"},"cursor":1638,"time":1.446759137447262e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n(*XXXXXXXXXXXXXXX*)\nlet e1’ = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2’ = Let (\"y\", Const 2,\n                 Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3’ = App (Let (\"z\", Const 10,\n                      Fun (\"y\", Plus (Var \"y\", Plus, Var \"z\")))\n                ,Var \"z\")\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"scope","out":"Characters 10-13:\n  let e1' = Bin (Const 1, Plus, Var \"x\");;\n            ^^^\nError: Unbound constructor Bin\n"},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"scope","out":"Characters 10-13:\n  let e2' = Let (\"y\", Const 2,\n            ^^^\nError: Unbound constructor Let\n"},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Plus (Var \"y\", Plus, Var \"z\")))\n,Var \"z\")","min":"\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Plus ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"scope","out":"Characters 10-13:\n  let e3' = App (Let (\"z\", Const 10,\n            ^^^\nError: Unbound constructor App\n"}],"event":{"phrases":["","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Plus (Var \"y\", Plus, Var \"z\")))\n,Var \"z\")"],"region":{"start":1348,"stop":1636},"type":"eval"},"cursor":1638,"time":1.446759147667955e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Plus (Var \"y\", Plus, Var \"z\")))\n              ,Var \"z\")\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n","type":"scope","out":"Characters 57-62:\n  | Bin of expr * binop * expr\n                  ^^^^^\nError: Unbound type constructor binop\n"},{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"scope","out":"Characters 32-35:\n  | Var x            -> add x empty\n    ^^^\nError: Unbound constructor Var\n"},{"in":"let isWellFormed e = free e","min":"\nlet isWellFormed e = free e;;\n","type":"scope","out":"Characters 21-25:\n  let isWellFormed e = free e;;\n                       ^^^^\nError: Unbound value free\n"},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"scope","out":"Characters 10-13:\n  let e1' = Bin (Const 1, Plus, Var \"x\");;\n            ^^^\nError: Unbound constructor Bin\n"},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"scope","out":"Characters 10-13:\n  let e2' = Let (\"y\", Const 2,\n            ^^^\nError: Unbound constructor Let\n"},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Plus (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Plus ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"scope","out":"Characters 10-13:\n  let e3' = App (Let (\"z\", Const 10,\n            ^^^\nError: Unbound constructor App\n"}],"event":{"phrases":["","type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Plus (Var \"y\", Plus, Var \"z\"))),Var \"z\")"],"region":{"start":408,"stop":1636},"type":"eval"},"cursor":1637,"time":1.446759196387953e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Plus (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"type 'a set = Set of 'a list","min":"\ntype 'a set =\n  | Set of 'a list;;\n","type":"","out":""},{"in":"let empty = Set []","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n","type":"","out":""},{"in":"let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n","type":"","out":""},{"in":"let add x s = match s with\n| Set l -> Set (x::l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n","type":"","out":""},{"in":"let union s1 s2 = match s2 with\n| Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n","type":"","out":""},{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n","type":"","out":""},{"in":"type binop = Plus","min":"\ntype binop =\n  | Plus;;\n","type":"","out":""},{"in":"type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n","type":"","out":""},{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Plus (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Plus ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"type","out":"Characters 45-49:\n  Fun (\"y\", Plus (Var \"y\", Plus, Var \"z\"))),Var \"z\");;\n            ^^^^\nError: This variant expression is expected to have type expr\n       The constructor Plus does not belong to type expr\n"}],"event":{"phrases":["type 'a set = Set of 'a list","let empty = Set []","let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","let add x s = match s with\n| Set l -> Set (x::l)","let union s1 s2 = match s2 with\n| Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","type binop = Plus","type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Plus (Var \"y\", Plus, Var \"z\"))),Var \"z\")"],"region":{"start":0,"stop":1636},"type":"eval"},"cursor":1637,"time":1.446759207168857e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Plus (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""}],"event":{"phrases":["","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")"],"region":{"start":1501,"stop":1635},"type":"eval"},"cursor":1635,"time":1.446759223693469e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Plus (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Plus ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"type","out":"Characters 44-48:\n  App (Fun (\"y\", Plus (Var \"x\", Plus, Var \"y\"))\n                 ^^^^\nError: This variant expression is expected to have type expr\n       The constructor Plus does not belong to type expr\n"},{"in":"(* e1’ === 1 + x *)\nlet e1' = Bin (Con","min":"","type":"syntax","out":"Characters 15-16:\n  let e1' = Bin (Con;;\n                ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"x + y *)\nlet e2' = Let (\"y\", Const 2,\n","min":"","type":"syntax","out":"Characters 7-8:\n  x + y *)\n         ^\nError: Syntax error\n"},{"in":"(fun y -> y + z)) z *)\nlet e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin ","min":"","type":"syntax","out":"Characters 16-17:\n  (fun y -> y + z)) z *)\n                  ^\nError: Syntax error\n"}],"event":{"phrases":["","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Plus (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","(* e1’ === 1 + x *)\nlet e1' = Bin (Con","x + y *)\nlet e2' = Let (\"y\", Const 2,\n","(fun y -> y + z)) z *)\nlet e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin "],"region":{"start":1349,"stop":1914},"type":"eval"},"cursor":1950,"time":1.44675923599098e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Plus (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\r\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n   (*XXXXXXXXXXXXXXXXXXXXX\nXXXXXX*)\n               let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))\n   (*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX*)\n                    let e3' = App (Let (\"z\", Const 10,\n            Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""}],"event":{"phrases":["","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))"],"region":{"start":1531,"stop":1662},"type":"eval"},"cursor":1663,"time":1.446759241872148e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\r\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n   (*XXXXXXXXXXXXXXXXXXXXX\nXXXXXX*)\n               let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))\n   (*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX*)\n                    let e3' = App (Let (\"z\", Const 10,\n            Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"(* e1’ === 1 + x *)\nlet e1' = Bin (Con","min":"","type":"syntax","out":"Characters 15-16:\n  let e1' = Bin (Con;;\n                ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"x + y *)\nlet e2' = Let (\"y\", Const 2,\n","min":"","type":"syntax","out":"Characters 7-8:\n  x + y *)\n         ^\nError: Syntax error\n"},{"in":"(fun y -> y + z)) z *)\nlet e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin ","min":"","type":"syntax","out":"Characters 16-17:\n  (fun y -> y + z)) z *)\n                  ^\nError: Syntax error\n"},{"in":"\r\nlet _ = List.map isWellFormed [e1; e2; e","min":"","type":"syntax","out":"Characters 42-44:\n  let _ = List.map isWellFormed [e1; e2; e;;\n                                          ^^\nError: Syntax error\n"}],"event":{"phrases":["","(* e1’ === 1 + x *)\nlet e1' = Bin (Con","x + y *)\nlet e2' = Let (\"y\", Const 2,\n","(fun y -> y + z)) z *)\nlet e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin ","\r\nlet _ = List.map isWellFormed [e1; e2; e"],"region":{"start":1662,"stop":1991},"type":"eval"},"cursor":1995,"time":1.446759252809978e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\r\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n   (*XXXXXXXXXXXXXXXXXXXXX\nXXXXXX*)\n               let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))\n   (*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX*)\n                    let e3' = App (Let (\"z\", Const 10,\n            Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r  \nlet _ = List.map isWellFormed [e1; e2; e3];;\n","file":"hw1.ml"}
{"ocaml":[{"in":"(* e1’ === 1 + x *)\nlet e1' = Bin (Con","min":"","type":"syntax","out":"Characters 15-16:\n  let e1' = Bin (Con;;\n                ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"x + y *)\nlet e2' = Let (\"y\", Const 2,\n","min":"","type":"syntax","out":"Characters 7-8:\n  x + y *)\n         ^\nError: Syntax error\n"},{"in":"(fun y -> y + z)) z *)\nlet e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin ","min":"","type":"syntax","out":"Characters 16-17:\n  (fun y -> y + z)) z *)\n                  ^\nError: Syntax error\n"}],"event":{"phrases":["","(* e1’ === 1 + x *)\nlet e1' = Bin (Con","x + y *)\nlet e2' = Let (\"y\", Const 2,\n","(fun y -> y + z)) z *)\nlet e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin "],"region":{"start":1662,"stop":1913},"type":"eval"},"cursor":1949,"time":1.446759268149575e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\r\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n   (*XXXXXXXXXXXXXXXXXXXXX\nXXXXXX*)\n               let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))\n   (*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX*)\n                    let e3' = App (Let (\"z\", Const 10,\n            Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n","file":"hw1.ml"}
{"ocaml":[{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"(* e1’ === 1 + x *)\nlet e1' = Bin (Con","min":"","type":"syntax","out":"Characters 15-16:\n  let e1' = Bin (Con;;\n                ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"},{"in":"x + y *)\nlet e2' = Let (\"y\", Const 2,\n","min":"","type":"syntax","out":"Characters 7-8:\n  x + y *)\n         ^\nError: Syntax error\n"},{"in":"(fun y -> y + z)) z *)\nlet e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin ","min":"","type":"syntax","out":"Characters 16-17:\n  (fun y -> y + z)) z *)\n                  ^\nError: Syntax error\n"}],"event":{"phrases":["","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","(* e1’ === 1 + x *)\nlet e1' = Bin (Con","x + y *)\nlet e2' = Let (\"y\", Const 2,\n","(fun y -> y + z)) z *)\nlet e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin "],"region":{"start":1531,"stop":1913},"type":"eval"},"cursor":1951,"time":1.446759284340151e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\r\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n   (*XXXXXXXXXXXXXXXXXXXXX\nXXXXXX*)\n               let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))\n   (*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX*)\n                    let e3' = App (Let (\"z\", Const 10,\n            Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r  \n","file":"hw1.ml"}
{"ocaml":[{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\")))\n,Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10), (App (Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\")))))),\n      (Var \"x\"));;\n","type":"type","out":"Characters 9-84:\n  .........Let (\"x\", Const 10,\n  App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\")))\n  ,Var \"x\")..\nError: The constructor Let expects 3 argument(s),\n       but is applied here to 4 argument(s)\n"}],"event":{"phrases":["","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\")))\n,Var \"x\")"],"region":{"start":1531,"stop":1662},"type":"eval"},"cursor":1662,"time":1.446759317396749e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\")))\n             ,Var \"x\")\r\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n   (*XXXXXXXXXXXXXXXXXXXXX\nXXXXXX*)\n               let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))\n   (*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX*)\n                    let e3' = App (Let (\"z\", Const 10,\n            Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r  \n","file":"hw1.ml"}
{"ocaml":[{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"(* e1’ === 1 + x *)\nlet e1' = Bin (Con","min":"","type":"syntax","out":"Characters 15-16:\n  let e1' = Bin (Con;;\n                ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"phrases":["","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","(* e1’ === 1 + x *)\nlet e1' = Bin (Con"],"region":{"start":1531,"stop":1702},"type":"eval"},"cursor":1683,"time":1.446759333148981e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\r\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n   (*XXXXXXXXXXXXXXXXXXXXX\nXXXXXX*)\n               let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))\n   (*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX*)\n                    let e3' = App (Let (\"z\", Const 10,\n            Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r  \n","file":"hw1.ml"}
{"ocaml":[{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""}],"event":{"phrases":["","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")"],"region":{"start":1531,"stop":1947},"type":"eval"},"cursor":1948,"time":1.446759349790945e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r  \n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":1947,"stop":1991},"type":"eval"},"cursor":1993,"time":1.446759361074683e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (Union (f1 f2))\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (Union (f1 f2))\n  | Fun (x,e1) -> del x (free e1);;\n","type":"type","out":"Characters 312-317:\n  del x (Union (f1 f2))\n         ^^^^^\nError: This variant expression is expected to have type string set\n       The constructor Union does not belong to type set\n"},{"in":"let isWellFormed e = free e","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (Union (f1 f2))\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":553,"stop":1993},"type":"eval"},"cursor":1995,"time":1.446759411298613e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (Union (f1 f2))\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union (f1 f2))\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union (f1 f2))\n  | Fun (x,e1) -> del x (free e1);;\n","type":"type","out":"Characters 319-321:\n  del x (union (f1 f2))\n                ^^\nError: This expression has type string set\n       This is not a function; it cannot be applied.\n"},{"in":"let isWellFormed e = free e","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union (f1 f2))\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":553,"stop":1993},"type":"eval"},"cursor":1995,"time":1.446759417039608e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union (f1 f2))\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")"],"region":{"start":553,"stop":1947},"type":"eval"},"cursor":1948,"time":1.446759430362368e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":1947,"stop":1991},"type":"eval"},"cursor":1995,"time":1.446759433911312e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let isWellFormed e = let check = free e in check=empty","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = let check = free e in check = empty;;\n","type":"","out":""}],"event":{"phrases":["","let isWellFormed e = let check = free e in check=empty"],"region":{"start":1320,"stop":1376},"type":"eval"},"cursor":1378,"time":1.446759546725464e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = let check = free e in check=empty\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = let check = free e in check = empty;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":1376,"stop":2018},"type":"eval"},"cursor":2022,"time":1.446759550013719e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = let check = free e in check=empty\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = List.map isWellFormed [e1'; e2'; e3']","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n\nlet isWellFormed e = let check = free e in check = empty;;\n\nlet _ = List.map isWellFormed [e1'; e2'; e3'];;\n","type":"","out":""}],"event":{"phrases":["","let _ = List.map isWellFormed [e1'; e2'; e3']"],"region":{"start":1974,"stop":2021},"type":"eval"},"cursor":2025,"time":1.446759566821062e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = let check = free e in check=empty\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1'; e2'; e3'];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let testee = Set [2;3;4;4;4;4;4;4]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [2; 3; 4; 4; 4; 4; 4; 4];;\n","type":"","out":""},{"in":"let _ = del 4 testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testee = Set [2; 3; 4; 4; 4; 4; 4; 4];;\n\nlet _ = del 4 testee;;\n","type":"","out":""}],"event":{"phrases":["","let testee = Set [2;3;4;4;4;4;4;4]","let _ = del 4 testee"],"region":{"start":388,"stop":447},"type":"eval"},"cursor":447,"time":1.44675960970199e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = let check = free e in check=empty\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1'; e2'; e3'];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"type binop = Plus","min":"\ntype binop =\n  | Plus;;\n","type":"","out":""},{"in":"type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n","type":"","out":""},{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = let check = free e in check=empty","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = let check = free e in check = empty;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = let check = free e in check = empty;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","type binop = Plus","type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = let check = free e in check=empty","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":447,"stop":2076},"type":"eval"},"cursor":2078,"time":1.446759640047906e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = let check = free e in check=empty\n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let isWellFormed e = free e","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":1378,"stop":2050},"type":"eval"},"cursor":2052,"time":1.446759649083708e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\nfree e1","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> free e1;;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> free e1;;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> free e1;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\nfree e1","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":611,"stop":2042},"type":"eval"},"cursor":2046,"time":1.446759671288874e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      free e1\n\nlet isWellFormed e = free e \n\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> free e1;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":1399,"stop":1445},"type":"eval"},"cursor":1449,"time":1.446759685571477e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      free e1\n\nlet isWellFormed e = free e \n\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n   (*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXX*)\n              let e2 = Let (\"x\", Const 1,\n                   Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))\n   (*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXX*)\n              let e3 = Let (\"x\", Const 10,\n                  App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n   (*XXXXXXXXXXXXXXXXXXXXX\nXXXXXX*)\n               let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))\n   (*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXX*)\n                    let e3' = App (Let (\"z\", Const 10,\n            Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\n(union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\n(union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":611,"stop":1447},"type":"eval"},"cursor":1449,"time":1.446759723149712e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel \"y\" (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"y\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"y\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"y\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel \"y\" (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":611,"stop":1455},"type":"eval"},"cursor":1457,"time":1.446759736133775e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del \"y\" (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nf1\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in f1\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in f1\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in f1\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nf1\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":611,"stop":1436},"type":"eval"},"cursor":1458,"time":1.44675974903148e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        f1\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n","type":"","out":""}],"event":{"phrases":["type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr"],"region":{"start":468,"stop":611},"type":"eval"},"cursor":612,"time":1.446759758375324e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nf2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in f2\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in f2\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"","type":"scope","out":"Error: This expression has type expr/1362\n       but an expression was expected of type expr/1500\nError: Unbound type constructor binop\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 31-33:\n  let _ = List.map isWellFormed [e1; e2; e3];;\n                                 ^^\nError: This expression has type expr/1362\n       but an expression was expected of type expr/1500\n"}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nf2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":611,"stop":1436},"type":"eval"},"cursor":1438,"time":1.446759763584853e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\n(union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"","type":"scope","out":"Error: This expression has type expr/1362\n       but an expression was expected of type expr/1500\nError: Unbound type constructor binop\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 31-33:\n  let _ = List.map isWellFormed [e1; e2; e3];;\n                                 ^^\nError: This expression has type expr/1362\n       but an expression was expected of type expr/1500\n"}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\n(union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":611,"stop":1447},"type":"eval"},"cursor":1450,"time":1.446759772638794e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"","type":"scope","out":"Error: This expression has type expr/1362\n       but an expression was expected of type expr/1500\nError: Unbound type constructor binop\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 31-33:\n  let _ = List.map isWellFormed [e1; e2; e3];;\n                                 ^^\nError: This expression has type expr/1362\n       but an expression was expected of type expr/1500\n"},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""}],"event":{"phrases":["","let _ = List.map isWellFormed [e1; e2; e3]","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")"],"region":{"start":1401,"stop":2046},"type":"eval"},"cursor":2047,"time":1.446759777292444e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\nlet e1 = Bin (Const 1, Plus, Const 2)\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""}],"event":{"phrases":["","let e1 = Bin (Const 1, Plus, Const 2)"],"region":{"start":1401,"stop":1441},"type":"eval"},"cursor":1442,"time":1.446759785061881e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":1441,"stop":1485},"type":"eval"},"cursor":1487,"time":1.446759787875516e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":1441,"stop":1715},"type":"eval"},"cursor":1718,"time":1.446759801400888e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel \"y\" (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"y\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"y\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"y\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel \"y\" (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":611,"stop":1723},"type":"eval"},"cursor":1725,"time":1.446759834230792e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del \"y\" (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel \"x\" (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"x\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\ntype 'a set =\n  | Set of 'a list;;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"x\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> add x empty\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"x\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> add x empty\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel \"x\" (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":611,"stop":1723},"type":"eval"},"cursor":1725,"time":1.44675984378669e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> add x empty\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del \"x\" (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel \"x\" (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"x\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> empty\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel \"x\" (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)"],"region":{"start":611,"stop":1375},"type":"eval"},"cursor":1261,"time":1.446759862099356e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del \"x\" (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let isWellFormed e = free e","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"x\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet empty = Set [];;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> empty\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"x\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":1375,"stop":1718},"type":"eval"},"cursor":1720,"time":1.446759865313896e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> empty\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del \"x\" (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel \"x\" (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"x\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"x\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"x\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel \"x\" (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":611,"stop":1718},"type":"eval"},"cursor":1721,"time":1.446759890913749e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del \"x\" (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e4; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del \"x\" (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e4; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let _ = List.map isWellFormed [e4; e2; e3]"],"region":{"start":1654,"stop":1775},"type":"eval"},"cursor":1778,"time":1.446759935295135e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del \"x\" (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e4; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e4; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let _ = List.map isWellFormed [e4; e2; e3]"],"region":{"start":611,"stop":1773},"type":"eval"},"cursor":1775,"time":1.446759948814104e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nUnion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"","type":"syntax","out":"Characters 309-310:\n  Union f1 (del x f2)\n           ^\nError: Syntax error\n"},{"in":"let isWellFormed e = free e","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e4; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e4; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nUnion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let _ = List.map isWellFormed [e4; e2; e3]"],"region":{"start":611,"stop":1773},"type":"eval"},"cursor":1775,"time":1.446759971012375e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        Union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e4; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e4; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let _ = List.map isWellFormed [e4; e2; e3]"],"region":{"start":611,"stop":1773},"type":"eval"},"cursor":1776,"time":1.446759986039861e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e4; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e4; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let _ = List.map isWellFormed [e4; e2; e3]"],"region":{"start":611,"stop":1765},"type":"eval"},"cursor":1767,"time":1.446759999309144e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n","type":"","out":""}],"event":{"phrases":["let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)"],"region":{"start":316,"stop":388},"type":"eval"},"cursor":390,"time":1.446760009641514e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let testee = Set [2;3;4;4;4;4;4;4]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [2; 3; 4; 4; 4; 4; 4; 4];;\n","type":"","out":""},{"in":"let _ = del 4 testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testee = Set [2; 3; 4; 4; 4; 4; 4; 4];;\n\nlet _ = del 4 testee;;\n","type":"","out":""},{"in":"type binop = Plus","min":"\ntype binop =\n  | Plus;;\n","type":"","out":""},{"in":"type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n","type":"","out":""},{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e4; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e4; e2; e3];;\n","type":"","out":""},{"in":"let testeeee = Set[\"x\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testeeee = Set [\"x\"];;\n","type":"","out":""},{"in":"let _ = del \"x\" testeeeee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet _ = del \"x\" testeeeee;;\n","type":"scope","out":"Characters 16-25:\n  let _ = del \"x\" testeeeee;;\n                  ^^^^^^^^^\nError: Unbound value testeeeee\n"}],"event":{"phrases":["","let testee = Set [2;3;4;4;4;4;4;4]","let _ = del 4 testee","type binop = Plus","type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let _ = List.map isWellFormed [e4; e2; e3]","let testeeee = Set[\"x\"]","let _ = del \"x\" testeeeee"],"region":{"start":388,"stop":1819},"type":"eval"},"cursor":1819,"time":1.446760039920438e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = del \"x\" testeeee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testeeee = Set [\"x\"];;\n\nlet _ = del \"x\" testeeee;;\n","type":"","out":""}],"event":{"phrases":["","let _ = del \"x\" testeeee"],"region":{"start":1792,"stop":1818},"type":"eval"},"cursor":1818,"time":1.446760046424868e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z=x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z = x) l);;\n","type":"","out":""},{"in":"let testee = Set [2;3;4;4;4;4;4;4]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [2; 3; 4; 4; 4; 4; 4; 4];;\n","type":"","out":""},{"in":"let _ = del 4 testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z = x) l);;\n\nlet testee = Set [2; 3; 4; 4; 4; 4; 4; 4];;\n\nlet _ = del 4 testee;;\n","type":"","out":""},{"in":"type binop = Plus","min":"\ntype binop =\n  | Plus;;\n","type":"","out":""},{"in":"type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n","type":"","out":""},{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z = x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z = x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e4; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z = x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e4; e2; e3];;\n","type":"","out":""},{"in":"let testeeee = Set[\"x\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testeeee = Set [\"x\"];;\n","type":"","out":""},{"in":"let _ = del \"x\" testeeee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z = x) l);;\n\nlet testeeee = Set [\"x\"];;\n\nlet _ = del \"x\" testeeee;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z=x) l)","let testee = Set [2;3;4;4;4;4;4;4]","let _ = del 4 testee","type binop = Plus","type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let _ = List.map isWellFormed [e4; e2; e3]","let testeeee = Set[\"x\"]","let _ = del \"x\" testeeee"],"region":{"start":314,"stop":1817},"type":"eval"},"cursor":1817,"time":1.446760064541332e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = del 4 testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z = x) l);;\n\nlet testee = Set [2; 3; 4; 4; 4; 4; 4; 4];;\n\nlet _ = del 4 testee;;\n","type":"","out":""}],"event":{"phrases":["let _ = del 4 testee"],"region":{"start":426,"stop":446},"type":"eval"},"cursor":446,"time":1.446760073012312e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z=x) l)\n\n\nlet testee = Set [2;3;4;4;4;4;4;4]\n\nlet _ = del 4 testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n","type":"","out":""},{"in":"let testee = Set [\"z\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [\"z\"];;\n","type":"","out":""},{"in":"let _ = del \"z'\" testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testee = Set [\"z\"];;\n\nlet _ = del \"z'\" testee;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","let testee = Set [\"z\"]","let _ = del \"z'\" testee"],"region":{"start":314,"stop":438},"type":"eval"},"cursor":438,"time":1.446760102758174e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\"]\n\nlet _ = del \"z'\" testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = del \"z\" testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testee = Set [\"z\"];;\n\nlet _ = del \"z\" testee;;\n","type":"","out":""}],"event":{"phrases":["","let _ = del \"z\" testee"],"region":{"start":413,"stop":437},"type":"eval"},"cursor":437,"time":1.446760111320986e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\"]\n\nlet _ = del \"z\" testee\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = \"z\" = \"z\"","min":"\nlet _ = \"z\" = \"z\";;\n","type":"","out":""}],"event":{"phrases":["","let _ = \"z\" = \"z\""],"region":{"start":437,"stop":456},"type":"eval"},"cursor":456,"time":1.446760127003943e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\"]\n\nlet _ = del \"z\" testee\n\nlet _ = \"z\" = \"z\"\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = match testee with \n| Set l -> let (h::tl) = l in h = \"z\"","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [\"z\"];;\n\nlet _ = match testee with | Set l -> let h::tl = l in h = \"z\";;\n","type":"","out":""}],"event":{"phrases":["","let _ = match testee with \n| Set l -> let (h::tl) = l in h = \"z\""],"region":{"start":437,"stop":503},"type":"eval"},"cursor":503,"time":1.446760172266522e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\"]\n\nlet _ = del \"z\" testee\n\nlet _ = match testee with \n  | Set l -> let (h::tl) = l in h = \"z\"\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n","type":"","out":""}],"event":{"phrases":["let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)"],"region":{"start":316,"stop":388},"type":"eval"},"cursor":388,"time":1.446760179652939e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\"]\n\nlet _ = del \"z\" testee\n\nlet _ = match testee with \n  | Set l -> let (h::tl) = l in h = \"z\"\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let testee = Set [\"z\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [\"z\"];;\n","type":"","out":""},{"in":"let _ = del \"z\" testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testee = Set [\"z\"];;\n\nlet _ = del \"z\" testee;;\n","type":"","out":""}],"event":{"phrases":["","let testee = Set [\"z\"]","let _ = del \"z\" testee"],"region":{"start":388,"stop":437},"type":"eval"},"cursor":437,"time":1.446760182400926e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\"]\n\nlet _ = del \"z\" testee\n\nlet _ = match testee with \n  | Set l -> let (h::tl) = l in h = \"z\"\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = del 'z' testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testee = Set [\"z\"];;\n\nlet _ = del 'z' testee;;\n","type":"type","out":"Characters 16-22:\n  let _ = del 'z' testee;;\n                  ^^^^^^\nError: This expression has type string set\n       but an expression was expected of type char set\n       Type string is not compatible with type char \n"}],"event":{"phrases":["","let _ = del 'z' testee"],"region":{"start":413,"stop":437},"type":"eval"},"cursor":437,"time":1.446760209255454e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\"]\n\nlet _ = del 'z' testee\n\nlet _ = match testee with \n  | Set l -> let (h::tl) = l in h = \"z\"\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = del \"z\" testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testee = Set [\"z\"];;\n\nlet _ = del \"z\" testee;;\n","type":"","out":""}],"event":{"phrases":["","let _ = del \"z\" testee"],"region":{"start":413,"stop":437},"type":"eval"},"cursor":437,"time":1.446760217931045e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\"]\n\nlet _ = del \"z\" testee\n\nlet _ = match testee with \n  | Set l -> let (h::tl) = l in h = \"z\"\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let testee = Set [\"z\";\"a\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [\"z\"; \"a\"];;\n","type":"","out":""},{"in":"let _ = del \"z\" testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testee = Set [\"z\"; \"a\"];;\n\nlet _ = del \"z\" testee;;\n","type":"","out":""}],"event":{"phrases":["","let testee = Set [\"z\";\"a\"]","let _ = del \"z\" testee"],"region":{"start":388,"stop":441},"type":"eval"},"cursor":441,"time":1.446760228622238e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\";\"a\"]\n\nlet _ = del \"z\" testee\n\nlet _ = match testee with \n  | Set l -> let (h::tl) = l in h = \"z\"\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let omg = [\"z\"]","min":"\nlet omg = [\"z\"];;\n","type":"","out":""},{"in":"let _ = match omg with \n| [] -> false\n| h::tl -> \"z\" = h","min":"\nlet omg = [\"z\"];;\n\nlet _ = match omg with | [] -> false | h::tl -> \"z\" = h;;\n","type":"","out":""}],"event":{"phrases":["","let omg = [\"z\"]","let _ = match omg with \n| [] -> false\n| h::tl -> \"z\" = h"],"region":{"start":441,"stop":515},"type":"eval"},"cursor":515,"time":1.446760326686484e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\";\"a\"]\n\nlet _ = del \"z\" testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" = h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = match omg with \n| [] -> false\n| h::tl -> \"z\" != h","min":"\nlet omg = [\"z\"];;\n\nlet _ = match omg with | [] -> false | h::tl -> \"z\" != h;;\n","type":"","out":""}],"event":{"phrases":["","let _ = match omg with \n| [] -> false\n| h::tl -> \"z\" != h"],"region":{"start":458,"stop":516},"type":"eval"},"cursor":516,"time":1.446760337720501e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\";\"a\"]\n\nlet _ = del \"z\" testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z=x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z = x) l);;\n","type":"","out":""},{"in":"let testee = Set [\"z\";\"a\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [\"z\"; \"a\"];;\n","type":"","out":""},{"in":"let _ = del \"z\" testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z = x) l);;\n\nlet testee = Set [\"z\"; \"a\"];;\n\nlet _ = del \"z\" testee;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z=x) l)","let testee = Set [\"z\";\"a\"]","let _ = del \"z\" testee"],"region":{"start":314,"stop":440},"type":"eval"},"cursor":440,"time":1.446760341397473e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z=x) l)\n\n\nlet testee = Set [\"z\";\"a\"]\n\nlet _ = del \"z\" testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> (not x)) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> not x) l);;\n","type":"","out":""},{"in":"let testee = Set [\"z\";\"a\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [\"z\"; \"a\"];;\n","type":"","out":""},{"in":"let _ = del \"z\" testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> not x) l);;\n\nlet testee = Set [\"z\"; \"a\"];;\n\nlet _ = del \"z\" testee;;\n","type":"type","out":"Characters 12-15:\n  let _ = del \"z\" testee;;\n              ^^^\nError: This expression has type string but an expression was expected of type\n         bool\n"}],"event":{"phrases":["","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> (not x)) l)","let testee = Set [\"z\";\"a\"]","let _ = del \"z\" testee"],"region":{"start":314,"stop":444},"type":"eval"},"cursor":444,"time":1.446760536267355e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> (not x)) l)\n\n\nlet testee = Set [\"z\";\"a\"]\n\nlet _ = del \"z\" testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n","type":"","out":""},{"in":"let testee = Set [\"z\";\"a\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [\"z\"; \"a\"];;\n","type":"","out":""},{"in":"let _ = del \"z\" testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testee = Set [\"z\"; \"a\"];;\n\nlet _ = del \"z\" testee;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","let testee = Set [\"z\";\"a\"]","let _ = del \"z\" testee"],"region":{"start":314,"stop":441},"type":"eval"},"cursor":442,"time":1.446760775526603e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [\"z\";\"a\"]\n\nlet _ = del \"z\" testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"type 'a set = Set of 'a list","min":"\ntype 'a set =\n  | Set of 'a list;;\n","type":"","out":""}],"event":{"phrases":["type 'a set = Set of 'a list"],"region":{"start":0,"stop":28},"type":"eval"},"cursor":28,"time":1.446760783608165e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=\"z\") l)\n\n\nlet testee = Set [\"z\";\"a\"]\n\nlet _ = del \"z\" testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let empty = Set []","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n","type":"","out":""},{"in":"let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n","type":"","out":""},{"in":"let add x s = match s with\n| Set l -> Set (x::l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n","type":"","out":""},{"in":"let union s1 s2 = match s2 with\n| Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n","type":"","out":""},{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=\"z\") l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s =\n  match s with | Set l -> Set (List.filter (fun z  -> z != \"z\") l);;\n","type":"","out":""},{"in":"let testee = Set [\"z\";\"a\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [\"z\"; \"a\"];;\n","type":"","out":""},{"in":"let _ = del \"z\" testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s =\n  match s with | Set l -> Set (List.filter (fun z  -> z != \"z\") l);;\n\nlet testee = Set [\"z\"; \"a\"];;\n\nlet _ = del \"z\" testee;;\n","type":"","out":""}],"event":{"phrases":["","let empty = Set []","let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","let add x s = match s with\n| Set l -> Set (x::l)","let union s1 s2 = match s2 with\n| Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=\"z\") l)","let testee = Set [\"z\";\"a\"]","let _ = del \"z\" testee"],"region":{"start":28,"stop":443},"type":"eval"},"cursor":444,"time":1.446760786649954e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=\"z\") l)\n\n\nlet testee = Set [\"z\";\"a\"]\n\nlet _ = del \"z\" testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=\"a\") l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s =\n  match s with | Set l -> Set (List.filter (fun z  -> z != \"a\") l);;\n","type":"","out":""},{"in":"let testee = Set [\"z\";\"a\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [\"z\"; \"a\"];;\n","type":"","out":""},{"in":"let _ = del \"z\" testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s =\n  match s with | Set l -> Set (List.filter (fun z  -> z != \"a\") l);;\n\nlet testee = Set [\"z\"; \"a\"];;\n\nlet _ = del \"z\" testee;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=\"a\") l)","let testee = Set [\"z\";\"a\"]","let _ = del \"z\" testee"],"region":{"start":314,"stop":443},"type":"eval"},"cursor":444,"time":1.446760800567535e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=\"a\") l)\n\n\nlet testee = Set [\"z\";\"a\"]\n\nlet _ = del \"z\" testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=\"z\") l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s =\n  match s with | Set l -> Set (List.filter (fun z  -> z != \"z\") l);;\n","type":"","out":""},{"in":"let delete x l = List.filter (fun z -> z!=x) l","min":"\nlet delete x l = List.filter (fun z  -> z != x) l;;\n","type":"","out":""},{"in":"let testee = Set [\"z\";\"a\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [\"z\"; \"a\"];;\n","type":"","out":""},{"in":"let mm = [\"z\";\"a\"]","min":"\nlet mm = [\"z\"; \"a\"];;\n","type":"","out":""},{"in":"let _ = delete \"z\" mm","min":"\nlet delete x l = List.filter (fun z  -> z != x) l;;\n\nlet mm = [\"z\"; \"a\"];;\n\nlet _ = delete \"z\" mm;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=\"z\") l)","let delete x l = List.filter (fun z -> z!=x) l","let testee = Set [\"z\";\"a\"]","let mm = [\"z\";\"a\"]","let _ = delete \"z\" mm"],"region":{"start":314,"stop":508},"type":"eval"},"cursor":508,"time":1.446760873495547e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=\"z\") l)\n\nlet delete x l = List.filter (fun z -> z!=x) l\n\nlet testee = Set [\"z\";\"a\"]\n\nlet mm = [\"z\";\"a\"]\nlet _ = delete \"z\" mm\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let testee = Set [2131;123123;4]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [2131; 123123; 4];;\n","type":"","out":""},{"in":"let mm = [\"z\";\"a\"]","min":"\nlet mm = [\"z\"; \"a\"];;\n","type":"","out":""},{"in":"let _ = del 4 testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s =\n  match s with | Set l -> Set (List.filter (fun z  -> z != \"z\") l);;\n\nlet testee = Set [2131; 123123; 4];;\n\nlet _ = del 4 testee;;\n","type":"type","out":"Characters 14-20:\n  let _ = del 4 testee;;\n                ^^^^^^\nError: This expression has type int set\n       but an expression was expected of type string set\n       Type int is not compatible with type string \n"}],"event":{"phrases":["","let testee = Set [2131;123123;4]","let mm = [\"z\";\"a\"]","let _ = del 4 testee"],"region":{"start":438,"stop":513},"type":"eval"},"cursor":513,"time":1.446761015680503e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=\"z\") l)\n\nlet delete x l = List.filter (fun z -> z!=x) l\n\nlet testee = Set [2131;123123;4]\n\nlet mm = [\"z\";\"a\"]\nlet _ = del 4 testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n","type":"","out":""},{"in":"let delete x l = List.filter (fun z -> z!=x) l","min":"\nlet delete x l = List.filter (fun z  -> z != x) l;;\n","type":"","out":""},{"in":"let testee = Set [2131;123123;4]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [2131; 123123; 4];;\n","type":"","out":""},{"in":"let mm = [\"z\";\"a\"]","min":"\nlet mm = [\"z\"; \"a\"];;\n","type":"","out":""},{"in":"let _ = del 4 testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testee = Set [2131; 123123; 4];;\n\nlet _ = del 4 testee;;\n","type":"","out":""}],"event":{"phrases":["","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z!=x) l)","let delete x l = List.filter (fun z -> z!=x) l","let testee = Set [2131;123123;4]","let mm = [\"z\";\"a\"]","let _ = del 4 testee"],"region":{"start":314,"stop":511},"type":"eval"},"cursor":511,"time":1.446761026901771e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\nlet delete x l = List.filter (fun z -> z!=x) l\n\nlet testee = Set [2131;123123;4]\n\nlet mm = [\"z\";\"a\"]\nlet _ = del 4 testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"let testee = Set [2131;123123;44;4;4;4;4]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [2131; 123123; 44; 4; 4; 4; 4];;\n","type":"","out":""},{"in":"let _ = del 4 testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z != x) l);;\n\nlet testee = Set [2131; 123123; 44; 4; 4; 4; 4];;\n\nlet _ = del 4 testee;;\n","type":"","out":""}],"event":{"phrases":["","let testee = Set [2131;123123;44;4;4;4;4]","let _ = del 4 testee"],"region":{"start":388,"stop":454},"type":"eval"},"cursor":454,"time":1.446761119759748e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z!=x) l)\n\n\nlet testee = Set [2131;123123;44;4;4;4;4]\n\nlet _ = del 4 testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r         \n","file":"hw1.ml"}
{"ocaml":[{"in":"type 'a set = Set of 'a list","min":"\ntype 'a set =\n  | Set of 'a list;;\n","type":"","out":""},{"in":"let empty = Set []","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n","type":"","out":""},{"in":"let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet rec member x s =\n  match s with\n  | Set [] -> false\n  | Set l -> let h::tl = l in if h = x then true else member x (Set tl);;\n","type":"","out":""},{"in":"let add x s = match s with\n| Set l -> Set (x::l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n","type":"","out":""},{"in":"let union s1 s2 = match s2 with\n| Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n","type":"","out":""},{"in":"let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z<>x) l)","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n","type":"","out":""},{"in":"let testee = Set [\"z\";\"a\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [\"z\"; \"a\"];;\n","type":"","out":""},{"in":"let _ = del \"a\" testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet testee = Set [\"z\"; \"a\"];;\n\nlet _ = del \"a\" testee;;\n","type":"","out":""}],"event":{"phrases":["type 'a set = Set of 'a list","let empty = Set []","let rec member x s = match s with\n| Set [] -> false\n| Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)","let add x s = match s with\n| Set l -> Set (x::l)","let union s1 s2 = match s2 with\n| Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s","let del x s = match s with\n| Set l -> Set(List.filter (fun z -> z<>x) l)","let testee = Set [\"z\";\"a\"]","let _ = del \"a\" testee"],"region":{"start":0,"stop":441},"type":"eval"},"cursor":441,"time":1.446786567262827e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z<>x) l)\n\n\nlet testee = Set [\"z\";\"a\"]\n\nlet _ = del \"a\" testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let testee = Set [4;2]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testee = Set [4; 2];;\n","type":"","out":""},{"in":"let _ = del 2 testee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet testee = Set [4; 2];;\n\nlet _ = del 2 testee;;\n","type":"","out":""}],"event":{"phrases":["","let testee = Set [4;2]","let _ = del 2 testee"],"region":{"start":388,"stop":435},"type":"eval"},"cursor":436,"time":1.446786586809698e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z<>x) l)\n\n\nlet testee = Set [4;2]\n\nlet _ = del 2 testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e4; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let omg = [\"z\"]","min":"\nlet omg = [\"z\"];;\n","type":"","out":""},{"in":"let _ = match omg with \n| [] -> false\n| h::tl -> \"z\" != h","min":"\nlet omg = [\"z\"];;\n\nlet _ = match omg with | [] -> false | h::tl -> \"z\" != h;;\n","type":"","out":""},{"in":"type binop = Plus","min":"\ntype binop =\n  | Plus;;\n","type":"","out":""},{"in":"type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n","type":"","out":""},{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let omg = [\"z\"]","let _ = match omg with \n| [] -> false\n| h::tl -> \"z\" != h","type binop = Plus","type expr = Const of int\n| Var of string\n| Bin of expr * binop * expr\n| Let of string * expr * expr\n| App of expr * expr\n| Fun of string * expr","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":435,"stop":1828},"type":"eval"},"cursor":1830,"time":1.446786660787807e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z<>x) l)\n\n\nlet testee = Set [4;2]\n\nlet _ = del 2 testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union f1 f2)\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"","type":"scope","out":"Error: Unbound value x\nError: Unbound constructor Set\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 229-230:\n  del x (union f1 f2)\n      ^\nError: Unbound value x\n"},{"in":"let isWellFormed e = free e","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x (union f1 f2)\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":674,"stop":1836},"type":"eval"},"cursor":1829,"time":1.446786674000901e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z<>x) l)\n\n\nlet testee = Set [4;2]\n\nlet _ = del 2 testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x (union f1 f2)\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x( union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = free e","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = free e;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = free e;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\ndel x( union f1 f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = free e","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":674,"stop":1836},"type":"eval"},"cursor":1838,"time":1.446786696150537e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z<>x) l)\n\n\nlet testee = Set [4;2]\n\nlet _ = del 2 testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x( union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = free e \n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let isWellFormed e = (free e) = empty","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = (free e) = empty;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = (free e) = empty;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let isWellFormed e = (free e) = empty","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":1436,"stop":1845},"type":"eval"},"cursor":1847,"time":1.446786727100117e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z<>x) l)\n\n\nlet testee = Set [4;2]\n\nlet _ = del 2 testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x( union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = (free e) = empty\n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e1; e2; e3];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = List.map isWellFormed [e1'; e2'; e3']","min":"","type":"scope","out":"Error: This expression has type expr/1500\n       but an expression was expected of type expr/2004\nError: Unbound constructor Set\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 31-34:\n  let _ = List.map isWellFormed [e1'; e2'; e3'];;\n                                 ^^^\nError: This expression has type expr/1500\n       but an expression was expected of type expr/2004\n"}],"event":{"phrases":["","let _ = List.map isWellFormed [e1'; e2'; e3']"],"region":{"start":1802,"stop":1848},"type":"eval"},"cursor":1851,"time":1.446786737899979e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z<>x) l)\n\n\nlet testee = Set [4;2]\n\nlet _ = del 2 testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x( union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = (free e) = empty\n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\nlet _ = List.map isWellFormed [e1'; e2'; e3'];;\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let testeeee = Set[\"x\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testeeee = Set [\"x\"];;\n","type":"","out":""},{"in":"let _ = del \"x\" testeeee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet testeeee = Set [\"x\"];;\n\nlet _ = del \"x\" testeeee;;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1'; e2'; e3']","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in del x (union f1 f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n\nlet isWellFormed e = (free e) = empty;;\n\nlet _ = List.map isWellFormed [e1'; e2'; e3'];;\n","type":"","out":""}],"event":{"phrases":["","let testeeee = Set[\"x\"]","let _ = del \"x\" testeeee","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","let _ = List.map isWellFormed [e1'; e2'; e3']"],"region":{"start":1802,"stop":2232},"type":"eval"},"cursor":2234,"time":1.446786746078983e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z<>x) l)\n\n\nlet testee = Set [4;2]\n\nlet _ = del 2 testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        del x( union f1 f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = (free e) = empty\n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\n\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1'; e2'; e3'];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype 'a set =\n  | Set of 'a list;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n","type":"","out":""},{"in":"let isWellFormed e = (free e) = empty","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n\nlet isWellFormed e = (free e) = empty;;\n","type":"","out":""},{"in":"let e1 = Bin (Const 1, Plus, Const 2)","min":"\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n","type":"","out":""},{"in":"let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n","type":"","out":""},{"in":"let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n","type":"","out":""},{"in":"let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e4 = Let (\"x\", (Const 10), (Bin ((Const 2), Plus, (Var \"x\"))));;\n","type":"","out":""},{"in":"let testeeee = Set[\"x\"]","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet testeeee = Set [\"x\"];;\n","type":"","out":""},{"in":"let _ = del \"x\" testeeee","min":"\ntype 'a set =\n  | Set of 'a list;;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet testeeee = Set [\"x\"];;\n\nlet _ = del \"x\" testeeee;;\n","type":"","out":""},{"in":"let e1' = Bin (Const 1, Plus, Var \"x\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e1' = Bin ((Const 1), Plus, (Var \"x\"));;\n","type":"","out":""},{"in":"let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e2' = Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))));;\n","type":"","out":""},{"in":"let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","min":"\ntype binop =\n  | Plus;;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\nlet e3' =\n  App\n    ((Let (\"z\", (Const 10), (Fun (\"y\", (Bin ((Var \"y\"), Plus, (Var \"z\"))))))),\n      (Var \"z\"));;\n","type":"","out":""},{"in":"let _ = List.map isWellFormed [e1; e2; e3]","min":"\nlet add x s = match s with | Set l -> Set (x :: l);;\n\nlet del x s = match s with | Set l -> Set (List.filter (fun z  -> z <> x) l);;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet union s1 s2 =\n  match s2 with\n  | Set x2s -> List.fold_left (fun s  -> fun x  -> add x s) s1 x2s;;\n\ntype 'a set =\n  | Set of 'a list;;\n\nlet empty = Set [];;\n\nlet rec free e =\n  match e with\n  | Var x -> Set [x]\n  | Const n -> Set []\n  | Bin (e1,op,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | App (e1,e2) -> let f1 = free e1 in let f2 = free e2 in union f1 f2\n  | Let (x,e1,e2) ->\n      let f1 = free e1 in let f2 = free e2 in union f1 (del x f2)\n  | Fun (x,e1) -> del x (free e1);;\n\ntype expr =\n  | Const of int\n  | Var of string\n  | Bin of expr* binop* expr\n  | Let of string* expr* expr\n  | App of expr* expr\n  | Fun of string* expr;;\n\ntype binop =\n  | Plus;;\n\nlet e1 = Bin ((Const 1), Plus, (Const 2));;\n\nlet e2 =\n  Let\n    (\"x\", (Const 1),\n      (Let (\"y\", (Const 2), (Bin ((Var \"x\"), Plus, (Var \"y\"))))));;\n\nlet e3 =\n  Let\n    (\"x\", (Const 10),\n      (App ((Fun (\"y\", (Bin ((Var \"x\"), Plus, (Var \"y\"))))), (Var \"x\"))));;\n\nlet isWellFormed e = (free e) = empty;;\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\n","type":"","out":""}],"event":{"phrases":["","let rec free e = match e with\n| Var x            -> Set[x]\n| Const n          -> Set[]\n| Bin (e1, op, e2) ->\n(* free variables in a binop is the union of\n* free vars in the LR operands *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| App (e1, e2)     ->\n(* free vars in an app are the free vars in the lambda +\n* free vars in the argument.\n* Params of Lambda is not free (see below) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 f2\n| Let (x, e1, e2)  ->\n(* free var in let exp is whatever is free in e1 + free in e2,\n* (sans refs to e1 in e2 because that is bound to x) *)\nlet f1 = free e1 in\nlet f2 = free e2 in\nunion f1 (del x f2)\n| Fun (x, e1)      ->\n(* free vars in a lambda is whatever is free in the body, sans the param *)\ndel x (free e1)","let isWellFormed e = (free e) = empty","let e1 = Bin (Const 1, Plus, Const 2)","let e2 = Let (\"x\", Const 1,\nLet (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\")))","let e3 = Let (\"x\", Const 10,\nApp (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n,Var \"x\"))","let e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))","let testeeee = Set[\"x\"]","let _ = del \"x\" testeeee","let e1' = Bin (Const 1, Plus, Var \"x\")","let e2' = Let (\"y\", Const 2,\nBin (Var \"x\", Plus, Var \"y\"))","let e3' = App (Let (\"z\", Const 10,\nFun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")","let _ = List.map isWellFormed [e1; e2; e3]"],"region":{"start":674,"stop":2229},"type":"eval"},"cursor":2231,"time":1.446786781059218e9,"body":"type 'a set = Set of 'a list\n\nlet empty = Set []\n\nlet rec member x s = match s with\n  | Set [] -> false\n  | Set l -> let (h::tl) = l in if(h = x) then true else member x (Set tl)\n\n\nlet add x s = match s with\n  | Set l -> Set (x::l)\n\nlet union s1 s2 = match s2 with\n  | Set x2s -> List.fold_left (fun s x -> add x s) s1 x2s\n\nlet del x s = match s with\n  | Set l -> Set(List.filter (fun z -> z<>x) l)\n\n\nlet testee = Set [4;2]\n\nlet _ = del 2 testee\n\nlet omg = [\"z\"]\nlet _ = match omg with \n  | [] -> false\n  | h::tl -> \"z\" != h\n\ntype binop = Plus\n\ntype expr = Const of int\n          | Var of string\n          | Bin of expr * binop * expr\n          | Let of string * expr * expr\n          | App of expr * expr\n          | Fun of string * expr\n\nlet rec free e = match e with\n  | Var x            -> Set[x]\n  | Const n          -> Set[]\n  | Bin (e1, op, e2) ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | App (e1, e2)     ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 f2\n  | Let (x, e1, e2)  ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      let f1 = free e1 in\n      let f2 = free e2 in\n        union f1 (del x f2)\n  | Fun (x, e1)      ->\n      (*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*)\n      del x (free e1)\n\nlet isWellFormed e = (free e) = empty\n\nlet e1 = Bin (Const 1, Plus, Const 2)\n\nlet e2 = Let (\"x\", Const 1,\n              Let (\"y\", Const 2,\n                   Bin (Var \"x\", Plus, Var \"y\")))\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3 = Let (\"x\", Const 10,\n              App (Fun (\"y\", Bin (Var \"x\", Plus, Var \"y\"))\n                  ,Var \"x\"))\n(*XXXXXXXXXXXXXXX*)\n\nlet e4 = Let(\"x\", Const 10, Bin(Const 2, Plus, Var \"x\"))\n\n\nlet testeeee = Set[\"x\"]\n\nlet _ = del \"x\" testeeee\n(*XXXXXXXXXXXXXX*)\n\n(*XXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXX\nXXXXXXXXX*)\n\nlet e1' = Bin (Const 1, Plus, Var \"x\")\n(*XXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXX*)\nlet e2' = Let (\"y\", Const 2,\n               Bin (Var \"x\", Plus, Var \"y\"))\n(*XXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXX*)\nlet e3' = App (Let (\"z\", Const 10,\n                    Fun (\"y\", Bin (Var \"y\", Plus, Var \"z\"))),Var \"z\")\n\nlet _ = List.map isWellFormed [e1; e2; e3];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec merge l1 l2 = \nmatch (l1,l2) with\n| ([],l) -> l\n| (l,[]) -> l\n| (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1,tl2)\nelse h2::(merge tl1,tl2)","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: ((merge tl1), tl2) else h2 :: ((merge tl1), tl2);;\n","type":"type","out":"Characters 115-130:\n  | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1,tl2)\n                                               ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}],"event":{"phrases":["let rec merge l1 l2 = \nmatch (l1,l2) with\n| ([],l) -> l\n| (l,[]) -> l\n| (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1,tl2)\nelse h2::(merge tl1,tl2)"],"region":{"start":0,"stop":155},"type":"eval"},"cursor":155,"time":1.446787851351573e9,"body":"let rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1,tl2)\n        else h2::(merge tl1,tl2)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec merge l1 l2 = \nmatch (l1,l2) with\n| ([],l) -> l\n| (l,[]) -> l\n| (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 tl2)\nelse h2::(merge tl1 tl2)","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 tl2) else h2 :: (merge tl1 tl2);;\n","type":"","out":""}],"event":{"phrases":["let rec merge l1 l2 = \nmatch (l1,l2) with\n| ([],l) -> l\n| (l,[]) -> l\n| (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 tl2)\nelse h2::(merge tl1 tl2)"],"region":{"start":0,"stop":155},"type":"eval"},"cursor":156,"time":1.446787864697056e9,"body":"let rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 tl2)\n        else h2::(merge tl1 tl2)\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = merge [2;4;6;8] [1;3;5]","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 tl2) else h2 :: (merge tl1 tl2);;\n\nlet _ = merge [2; 4; 6; 8] [1; 3; 5];;\n","type":"","out":""},{"in":"\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12","min":"","type":"syntax","out":"Characters 43-45:\n  let _ = merge [2;10;20] [1;2;3;4;5;8;10;12;;\n                                            ^^\nError: Syntax error\n"}],"event":{"phrases":["","let _ = merge [2;4;6;8] [1;3;5]","\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12"],"region":{"start":155,"stop":234},"type":"eval"},"cursor":239,"time":1.446787884722944e9,"body":"let rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 tl2)\n        else h2::(merge tl1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\r\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec merge l1 l2 = \nmatch (l1,l2) with\n| ([],l) -> l\n| (l,[]) -> l\n| (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\nelse h2::(merge l1 tl2)","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n","type":"","out":""},{"in":"let _ = merge [2;4;6;8] [1;3;5]","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n\nlet _ = merge [2; 4; 6; 8] [1; 3; 5];;\n","type":"","out":""},{"in":"\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12","min":"","type":"syntax","out":"Characters 43-45:\n  let _ = merge [2;10;20] [1;2;3;4;5;8;10;12;;\n                                            ^^\nError: Syntax error\n"}],"event":{"phrases":["let rec merge l1 l2 = \nmatch (l1,l2) with\n| ([],l) -> l\n| (l,[]) -> l\n| (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\nelse h2::(merge l1 tl2)","let _ = merge [2;4;6;8] [1;3;5]","\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12"],"region":{"start":0,"stop":232},"type":"eval"},"cursor":235,"time":1.446787913488254e9,"body":"let rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\r\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12];;\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = merge [2;10;20] [1;2;3;4;5;8;10;12]","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n\nlet _ = merge [2; 10; 20] [1; 2; 3; 4; 5; 8; 10; 12];;\n","type":"","out":""}],"event":{"phrases":["","let _ = merge [2;10;20] [1;2;3;4;5;8;10;12]"],"region":{"start":186,"stop":233},"type":"eval"},"cursor":233,"time":1.446787927483635e9,"body":"let rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec split l =\nlet base = (0,[],[]) in\nlet fold_fn(i,l1,l2) elmt =\nif (i < l/2) then (i+1,[elmt]@l1,l2)\nelse (i,l1,[elmt]@l2) in\nlet (_,l1,l2) = List.fold_left fold_fn base l in (l1,l2)","min":"\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < (l / 2)\n    then ((i + 1), ([elmt] @ l1), l2)\n    else (i, l1, ([elmt] @ l2)) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n","type":"type","out":"Characters 176-177:\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1,l2);;\n                                              ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["let rec split l =\nlet base = (0,[],[]) in\nlet fold_fn(i,l1,l2) elmt =\nif (i < l/2) then (i+1,[elmt]@l1,l2)\nelse (i,l1,[elmt]@l2) in\nlet (_,l1,l2) = List.fold_left fold_fn base l in (l1,l2)"],"region":{"start":0,"stop":188},"type":"eval"},"cursor":188,"time":1.446788667432153e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < l/2) then (i+1,[elmt]@l1,l2)\n    else (i,l1,[elmt]@l2) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1,l2)\n\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec split l =\nlet base = (0,[],[]) in\nlet fold_fn(i,l1,l2) elmt =\nif (i < l/2) then (i+1,[elmt]@l1,l2)\nelse (i,l1,[elmt]@l2) in\nlet (_,l1,l2) = List.fold_left fold_fn base l \nin (l1,l2)","min":"\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < (l / 2)\n    then ((i + 1), ([elmt] @ l1), l2)\n    else (i, l1, ([elmt] @ l2)) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n","type":"type","out":"Characters 176-177:\n  let (_,l1,l2) = List.fold_left fold_fn base l \n                                              ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}],"event":{"phrases":["let rec split l =\nlet base = (0,[],[]) in\nlet fold_fn(i,l1,l2) elmt =\nif (i < l/2) then (i+1,[elmt]@l1,l2)\nelse (i,l1,[elmt]@l2) in\nlet (_,l1,l2) = List.fold_left fold_fn base l \nin (l1,l2)"],"region":{"start":0,"stop":189},"type":"eval"},"cursor":189,"time":1.446788716003331e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < l/2) then (i+1,[elmt]@l1,l2)\n    else (i,l1,[elmt]@l2) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec split l =\nlet base = (0,[],[]) in\nlet fold_fn(i,l1,l2) elmt =\nif (i < (List.length l) /2) then (i+1,[elmt]@l1,l2)\nelse (i,l1,[elmt]@l2) in\nlet (_,l1,l2) = List.fold_left fold_fn base l \nin (l1,l2)","min":"\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), ([elmt] @ l1), l2)\n    else (i, l1, ([elmt] @ l2)) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n","type":"","out":""}],"event":{"phrases":["let rec split l =\nlet base = (0,[],[]) in\nlet fold_fn(i,l1,l2) elmt =\nif (i < (List.length l) /2) then (i+1,[elmt]@l1,l2)\nelse (i,l1,[elmt]@l2) in\nlet (_,l1,l2) = List.fold_left fold_fn base l \nin (l1,l2)"],"region":{"start":0,"stop":204},"type":"eval"},"cursor":193,"time":1.446788738770641e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,[elmt]@l1,l2)\n    else (i,l1,[elmt]@l2) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = split [23;1;8;3]","min":"\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), ([elmt] @ l1), l2)\n    else (i, l1, ([elmt] @ l2)) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet _ = split [23; 1; 8; 3];;\n","type":"","out":""}],"event":{"phrases":["","let _ = split [23;1;8;3]"],"region":{"start":204,"stop":231},"type":"eval"},"cursor":233,"time":1.446788755589628e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,[elmt]@l1,l2)\n    else (i,l1,[elmt]@l2) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [23;1;8;3];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = split [23;1;8;3]","min":"\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), ([elmt] @ l1), l2)\n    else (i, l1, ([elmt] @ l2)) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet _ = split [23; 1; 8; 3];;\n","type":"","out":""}],"event":{"phrases":["let _ = split [23;1;8;3]"],"region":{"start":207,"stop":231},"type":"eval"},"cursor":233,"time":1.446788757181179e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,[elmt]@l1,l2)\n    else (i,l1,[elmt]@l2) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [23;1;8;3];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec split l =\nlet base = (0,[],[]) in\nlet fold_fn(i,l1,l2) elmt =\nif (i < (List.length l) /2) then (i+1,elmt::l1,l2)\nelse (i,l1,elmt::l2) in\nlet (_,l1,l2) = List.fold_left fold_fn base l \nin (l1,l2)","min":"\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (elmt :: l1), l2)\n    else (i, l1, (elmt :: l2)) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n","type":"","out":""},{"in":"let _ = split [23;1;8;3]","min":"\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (elmt :: l1), l2)\n    else (i, l1, (elmt :: l2)) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet _ = split [23; 1; 8; 3];;\n","type":"","out":""},{"in":"let rec merge l1 l2 = \nmatch (l1,l2) with\n| ([],l) -> l\n| (l,[]) -> l\n| (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\nelse h2::(merge l1 tl2)","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n","type":"","out":""}],"event":{"phrases":["let rec split l =\nlet base = (0,[],[]) in\nlet fold_fn(i,l1,l2) elmt =\nif (i < (List.length l) /2) then (i+1,elmt::l1,l2)\nelse (i,l1,elmt::l2) in\nlet (_,l1,l2) = List.fold_left fold_fn base l \nin (l1,l2)","let _ = split [23;1;8;3]","let rec merge l1 l2 = \nmatch (l1,l2) with\n| ([],l) -> l\n| (l,[]) -> l\n| (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\nelse h2::(merge l1 tl2)"],"region":{"start":0,"stop":386},"type":"eval"},"cursor":255,"time":1.44678878054611e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,elmt::l1,l2)\n    else (i,l1,elmt::l2) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [23;1;8;3];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec split l =\nlet base = (0,[],[]) in\nlet fold_fn(i,l1,l2) elmt =\nif (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\nelse (i,l1,l2@[elmt]) in\nlet (_,l1,l2) = List.fold_left fold_fn base l \nin (l1,l2)","min":"\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (l1 @ [elmt]), l2)\n    else (i, l1, (l2 @ [elmt])) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n","type":"","out":""},{"in":"let _ = split [23;1;8;3]","min":"\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (l1 @ [elmt]), l2)\n    else (i, l1, (l2 @ [elmt])) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet _ = split [23; 1; 8; 3];;\n","type":"","out":""}],"event":{"phrases":["let rec split l =\nlet base = (0,[],[]) in\nlet fold_fn(i,l1,l2) elmt =\nif (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\nelse (i,l1,l2@[elmt]) in\nlet (_,l1,l2) = List.fold_left fold_fn base l \nin (l1,l2)","let _ = split [23;1;8;3]"],"region":{"start":0,"stop":231},"type":"eval"},"cursor":234,"time":1.446788819769905e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [23;1;8;3];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = split [\"a\"]","min":"\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (l1 @ [elmt]), l2)\n    else (i, l1, (l2 @ [elmt])) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet _ = split [\"a\"];;\n","type":"","out":""}],"event":{"phrases":["","let _ = split [\"a\"]"],"region":{"start":204,"stop":226},"type":"eval"},"cursor":228,"time":1.446788840813095e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = split [\"a\"]","min":"\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (l1 @ [elmt]), l2)\n    else (i, l1, (l2 @ [elmt])) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet _ = split [\"a\"];;\n","type":"","out":""}],"event":{"phrases":["let _ = split [\"a\"]"],"region":{"start":207,"stop":226},"type":"eval"},"cursor":228,"time":1.446788847168338e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec merge l1 l2 = \nmatch (l1,l2) with\n| ([],l) -> l\n| (l,[]) -> l\n| (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\nelse h2::(merge l1 tl2)","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n","type":"","out":""},{"in":"let _ = merge [2;4;6;8] [1;3;5]","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n\nlet _ = merge [2; 4; 6; 8] [1; 3; 5];;\n","type":"","out":""},{"in":"let _ = merge [2;10;20] [1;2;3;4;5;8;10;12]","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n\nlet _ = merge [2; 10; 20] [1; 2; 3; 4; 5; 8; 10; 12];;\n","type":"","out":""},{"in":"let rec merge_sort l =\nif(List.length > 1) then let (l1,l2) = split l in merge l1 l2\nelse l","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (l1 @ [elmt]), l2)\n    else (i, l1, (l2 @ [elmt])) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet rec merge_sort l =\n  if List.length > 1 then let (l1,l2) = split l in merge l1 l2 else l;;\n","type":"type","out":"Characters 40-41:\n  if(List.length > 1) then let (l1,l2) = split l in merge l1 l2\n                   ^\nError: This expression has type int but an expression was expected of type\n         'a list -> int\n"}],"event":{"phrases":["","let rec merge l1 l2 = \nmatch (l1,l2) with\n| ([],l) -> l\n| (l,[]) -> l\n| (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\nelse h2::(merge l1 tl2)","let _ = merge [2;4;6;8] [1;3;5]","let _ = merge [2;10;20] [1;2;3;4;5;8;10;12]","let rec merge_sort l =\nif(List.length > 1) then let (l1,l2) = split l in merge l1 l2\nelse l"],"region":{"start":226,"stop":556},"type":"eval"},"cursor":556,"time":1.446789068384872e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if(List.length > 1) then let (l1,l2) = split l in merge l1 l2\n  else l\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec merge_sort l =\nif((List.length  l )> 1) then let (l1,l2) = split l in merge l1 l2\nelse l","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (l1 @ [elmt]), l2)\n    else (i, l1, (l2 @ [elmt])) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet rec merge_sort l =\n  if (List.length l) > 1 then let (l1,l2) = split l in merge l1 l2 else l;;\n","type":"","out":""}],"event":{"phrases":["","let rec merge_sort l =\nif((List.length  l )> 1) then let (l1,l2) = split l in merge l1 l2\nelse l"],"region":{"start":463,"stop":561},"type":"eval"},"cursor":563,"time":1.446789083598945e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then let (l1,l2) = split l in merge l1 l2\n  else l\r\n","file":"hw1.ml"}
{"ocaml":[{"in":"let rec merge_sort l =\nif((List.length  l )> 1) then \nlet (l1,l2) = split l in \nlet l1m = merge_sort l1 in\nlet l2m = merge_sort l2 in\nmerge l1m l2m\nelse l","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (l1 @ [elmt]), l2)\n    else (i, l1, (l2 @ [elmt])) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet rec merge_sort l =\n  if (List.length l) > 1\n  then\n    let (l1,l2) = split l in\n    let l1m = merge_sort l1 in let l2m = merge_sort l2 in merge l1m l2m\n  else l;;\n","type":"","out":""},{"in":"let _ = merge_sort [2;10;3;2;1]","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (l1 @ [elmt]), l2)\n    else (i, l1, (l2 @ [elmt])) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet rec merge_sort l =\n  if (List.length l) > 1\n  then\n    let (l1,l2) = split l in\n    let l1m = merge_sort l1 in let l2m = merge_sort l2 in merge l1m l2m\n  else l;;\n\nlet _ = merge_sort [2; 10; 3; 2; 1];;\n","type":"","out":""}],"event":{"phrases":["","let rec merge_sort l =\nif((List.length  l )> 1) then \nlet (l1,l2) = split l in \nlet l1m = merge_sort l1 in\nlet l2m = merge_sort l2 in\nmerge l1m l2m\nelse l","let _ = merge_sort [2;10;3;2;1]"],"region":{"start":463,"stop":653},"type":"eval"},"cursor":655,"time":1.446789170566726e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [2;10;3;2;1];;\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = merge_sort [2;10;3;2;1]","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (l1 @ [elmt]), l2)\n    else (i, l1, (l2 @ [elmt])) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet rec merge_sort l =\n  if (List.length l) > 1\n  then\n    let (l1,l2) = split l in\n    let l1m = merge_sort l1 in let l2m = merge_sort l2 in merge l1m l2m\n  else l;;\n\nlet _ = merge_sort [2; 10; 3; 2; 1];;\n","type":"","out":""}],"event":{"phrases":["","let _ = merge_sort [2;10;3;2;1]"],"region":{"start":619,"stop":653},"type":"eval"},"cursor":655,"time":1.446789188793962e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [2;10;3;2;1];;\n","file":"hw1.ml"}
{"ocaml":[{"in":"let _ = merge_sort [-10;0;10;-20;100;-100]","min":"\nlet rec merge l1 l2 =\n  match (l1, l2) with\n  | ([],l) -> l\n  | (l,[]) -> l\n  | (h1::tl1,h2::tl2) ->\n      if h1 < h2 then h1 :: (merge tl1 l2) else h2 :: (merge l1 tl2);;\n\nlet rec split l =\n  let base = (0, [], []) in\n  let fold_fn (i,l1,l2) elmt =\n    if i < ((List.length l) / 2)\n    then ((i + 1), (l1 @ [elmt]), l2)\n    else (i, l1, (l2 @ [elmt])) in\n  let (_,l1,l2) = List.fold_left fold_fn base l in (l1, l2);;\n\nlet rec merge_sort l =\n  if (List.length l) > 1\n  then\n    let (l1,l2) = split l in\n    let l1m = merge_sort l1 in let l2m = merge_sort l2 in merge l1m l2m\n  else l;;\n\nlet _ = merge_sort [(-10); 0; 10; (-20); 100; (-100)];;\n","type":"","out":""}],"event":{"phrases":["","let _ = merge_sort [-10;0;10;-20;100;-100]"],"region":{"start":619,"stop":664},"type":"eval"},"cursor":666,"time":1.446789199771328e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n","file":"hw1.ml"}
{"ocaml":[{"in":"let app fs v = List.map (fun x -> x v) l","min":"\nlet app fs v = List.map (fun x  -> x v) l;;\n","type":"scope","out":"Characters 39-40:\n  let app fs v = List.map (fun x -> x v) l;;\n                                         ^\nError: Unbound value l\n"}],"event":{"phrases":["","let app fs v = List.map (fun x -> x v) l"],"region":{"start":664,"stop":709},"type":"eval"},"cursor":709,"time":1.446789478344954e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) l\n","file":"hw1.ml"}
{"ocaml":[{"in":"let app fs v = List.map (fun x -> x v) fs","min":"\nlet app fs v = List.map (fun x  -> x v) fs;;\n","type":"","out":""}],"event":{"phrases":["","let app fs v = List.map (fun x -> x v) fs"],"region":{"start":664,"stop":710},"type":"eval"},"cursor":710,"time":1.446789482542309e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n","file":"hw1.ml"}
{"ocaml":[{"in":"let incr x = x+1","min":"\nlet incr x = x + 1;;\n","type":"","out":""},{"in":"let decr x = x-1","min":"\nlet decr x = x - 1;;\n","type":"","out":""},{"in":"let _ = app [incr;decr] 10","min":"\nlet app fs v = List.map (fun x  -> x v) fs;;\n\nlet decr x = x - 1;;\n\nlet incr x = x + 1;;\n\nlet _ = app [incr; decr] 10;;\n","type":"","out":""}],"event":{"phrases":["","let incr x = x+1","let decr x = x-1","let _ = app [incr;decr] 10"],"region":{"start":710,"stop":778},"type":"eval"},"cursor":780,"time":1.446789524081473e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"let [f1;f2] = app [(=);(<)] 2","min":"\nlet app fs v = List.map (fun x  -> x v) fs;;\n\nlet f1::f2::[] = app [(=); (<)] 2;;\n","type":"","out":""}],"event":{"phrases":["","let [f1;f2] = app [(=);(<)] 2"],"region":{"start":778,"stop":811},"type":"eval"},"cursor":814,"time":1.446789570199082e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\nlet [f1;f2] = app [(=);(<)] 2;;\r\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"\nlet _ = f2 ","min":"\nlet _ = f2;;\n","type":"","out":""}],"event":{"phrases":["","\nlet _ = f2 "],"region":{"start":811,"stop":826},"type":"eval"},"cursor":827,"time":1.446789635399345e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\nlet [f1;f2] = app [(=);(<)] 2;;\r\nlet _ = f2 1\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"\nlet _ = f2 ","min":"\nlet _ = f2;;\n","type":"","out":""}],"event":{"phrases":["\nlet _ = f2 "],"region":{"start":814,"stop":826},"type":"eval"},"cursor":827,"time":1.446789642401428e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\nlet [f1;f2] = app [(=);(<)] 2;;\r\nlet _ = f2 1\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"\nlet _ = f2 ","min":"\nlet _ = f2;;\n","type":"","out":""}],"event":{"phrases":["\nlet _ = f2 "],"region":{"start":814,"stop":826},"type":"eval"},"cursor":829,"time":1.446789647371125e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\nlet [f1;f2] = app [(=);(<)] 2;;\r\nlet _ = f2 1;;\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"\nlet _ = (f2 1","min":"","type":"syntax","out":"Characters 9-10:\n  let _ = (f2 1;;\n          ^\nSyntax error: ')' expected, the highlighted '(' might be unmatched\n"}],"event":{"phrases":["","\nlet _ = (f2 1"],"region":{"start":811,"stop":828},"type":"eval"},"cursor":829,"time":1.446789654120613e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\nlet [f1;f2] = app [(=);(<)] 2;;\r\nlet _ = (f2 1)\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"\nlet _ = (f2) ","min":"\nlet _ = f2;;\n","type":"","out":""}],"event":{"phrases":["","\nlet _ = (f2) "],"region":{"start":811,"stop":828},"type":"eval"},"cursor":829,"time":1.446789662754718e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\nlet [f1;f2] = app [(=);(<)] 2;;\r\nlet _ = (f2) 1\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"f2 1","min":"\nlet _ = f2 1;;\n","type":"","out":""}],"event":{"phrases":["","f2 1"],"region":{"start":811,"stop":819},"type":"eval"},"cursor":819,"time":1.446789675025865e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\nlet [f1;f2] = app [(=);(<)] 2;;\n\nf2 1\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"f2 3","min":"\nlet _ = f2 3;;\n","type":"","out":""}],"event":{"phrases":["","f2 3"],"region":{"start":811,"stop":819},"type":"eval"},"cursor":819,"time":1.446789679380867e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\nlet [f1;f2] = app [(=);(<)] 2;;\n\nf2 3\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"f2 2","min":"\nlet _ = f2 2;;\n","type":"","out":""}],"event":{"phrases":["","f2 2"],"region":{"start":811,"stop":819},"type":"eval"},"cursor":819,"time":1.446789682824227e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\nlet [f1;f2] = app [(=);(<)] 2;;\n\nf2 2\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"f1 2","min":"\nlet _ = f1 2;;\n","type":"","out":""}],"event":{"phrases":["","f1 2"],"region":{"start":811,"stop":819},"type":"eval"},"cursor":819,"time":1.446789686508851e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\nlet [f1;f2] = app [(=);(<)] 2;;\n\nf1 2\n\r","file":"hw1.ml"}
{"ocaml":[{"in":"f1 3","min":"\nlet _ = f1 3;;\n","type":"","out":""}],"event":{"phrases":["","f1 3"],"region":{"start":811,"stop":819},"type":"eval"},"cursor":819,"time":1.446789688898341e9,"body":"let rec split l =\n  let base = (0,[],[]) in\n  let fold_fn(i,l1,l2) elmt =\n    if (i < (List.length l) /2) then (i+1,l1@[elmt],l2)\n    else (i,l1,l2@[elmt]) in\n  let (_,l1,l2) = List.fold_left fold_fn base l \n  in (l1,l2)\n\n\nlet _ = split [\"a\"];;\n\nlet rec merge l1 l2 = \n  match (l1,l2) with\n    | ([],l) -> l\n    | (l,[]) -> l\n    | (h1::tl1,h2::tl2) -> if (h1 < h2) then h1::(merge tl1 l2)\n        else h2::(merge l1 tl2)\n\nlet _ = merge [2;4;6;8] [1;3;5];;\n\nlet _ = merge [2;10;20] [1;2;3;4;5;8;10;12]\n\nlet rec merge_sort l =\n  if((List.length  l )> 1) then \n    let (l1,l2) = split l in \n    let l1m = merge_sort l1 in\n    let l2m = merge_sort l2 in\n      merge l1m l2m\n  else l\r\n\nlet _ = merge_sort [-10;0;10;-20;100;-100];;\n\n\nlet app fs v = List.map (fun x -> x v) fs\n\nlet incr x = x+1;;\n\nlet decr x = x-1;;\n\nlet _ = app [incr;decr] 10;;\n\nlet [f1;f2] = app [(=);(<)] 2;;\n\nf1 3\n\r","file":"hw1.ml"}
